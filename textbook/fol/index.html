<!doctype html>
<html lang="en" data-bs-theme="light">
  <head>
    <meta charset="utf-8"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <title>logicalmethods.ai &ndash; FOL </title>
    <link rel="icon" type="image/x-icon" href="https://logicalmethods.ai/favicon.ico"></link>
    <link href="https://logicalmethods.ai/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/icons/font/bootstrap-icons.min.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/layout.css"></link>
    <link href="https://logicalmethods.ai/css/textbook.css" rel="stylesheet"></link>
    <style>
      
    :root {
      --chapter: "8";
    }

    </style>
    
      <link rel="stylesheet" href="https://logicalmethods.ai/katex/katex.min.css">
<script defer src="https://logicalmethods.ai/katex/katex.min.js"></script>
<script defer src="https://logicalmethods.ai/katex/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},     
        {left: '\\[', right: '\\]', display: true},   
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>


    
  </head>
  <body class="bg-black d-flex flex-column m-0 p-0">
    <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvas-nav" aria-labelledby="offcanvas-navLabel" data-bs-theme="dark" data-bs-backdrop="false">
  <div class="offcanvas-header">
    <div class="h5 offcanvas-title" id="offcanvas-navLabel">
      Browse course
    </div>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  
  <div class="offcanvas-body">
    <ul class="navbar-nav">
      
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/about/"><i class="bi-file-person-fill"></i> &nbsp;&nbsp; About</a>
          </div>
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link fw-bold active" href="/textbook/"><i class="bi bi-book"></i> &nbsp;&nbsp; Textbook</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/textbook/"
            id="navbarSectiontxt-home" data-bs-toggle="collapse"
            data-bs-target="#collapsetxt-home"  
            aria-expanded="true"
            aria-controls="collapsetxt-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse show" id="collapsetxt-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >5. 
                <i class="bi bi-lock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >6. 
                <i class="bi bi-lock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >7. 
                <i class="bi bi-lock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                fw-bold active
                link-opacity-50
                "
                href="javascript:;"
              >8. 
                <i class="bi bi-lock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >9. 
                <i class="bi bi-lock-fill"></i>
                 FOL Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logic-based learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/slides/"><i class="bi bi-rocket-takeoff-fill"></i> &nbsp;&nbsp; Slides</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/slides/"
            id="navbarSectionsli-home" data-bs-toggle="collapse"
            data-bs-target="#collapsesli-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapsesli-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapsesli-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/teaser/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >5. 
                <i class="bi bi-lock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >6. 
                <i class="bi bi-lock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >7. 
                <i class="bi bi-lock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >8. 
                <i class="bi bi-lock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >9. 
                <i class="bi bi-lock-fill"></i>
                 FOL inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/exercises/"><i class="bi-gear-fill"></i> &nbsp;&nbsp; Exercises</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/exercises/"
            id="navbarSectionexe-home" data-bs-toggle="collapse"
            data-bs-target="#collapseexe-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseexe-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseexe-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/preamble/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >4. 
                <i class="bi bi-lock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >5. 
                <i class="bi bi-lock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >6. 
                <i class="bi bi-lock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >7. 
                <i class="bi bi-lock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >8. 
                <i class="bi bi-lock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >9. 
                <i class="bi bi-lock-fill"></i>
                 FOL inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/assignments/"><i class="bi bi-house-gear-fill"></i> &nbsp;&nbsp; Assignments</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/assignments/"
            id="navbarSectionass-home" data-bs-toggle="collapse"
            data-bs-target="#collapseass-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseass-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseass-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/assignments/assignment_1/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Assignment 1 (due 09/19/2025)
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      
      
      
    </ul>
  </div>
</div>



    <header class="align-self-center d-flex flex-column m-0 mb-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="header-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="https://logicalmethods.ai/">
    <img src="https://logicalmethods.ai/img/nav_id.png" class="inert-img img-fluid m-2" draggable="false" width="400px">
    </a>
    <button class="navbar-toggler border-0" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas-nav" aria-controls="offcanvas-nav">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
</nav>

      
      
    </header>
    
    <main class="align-self-center d-flex flex-column flex-fill bg-white m-md-1 p-0" data-bs-theme="light">
      <ul class="navbar-nav flex-row justify-content-center mt-2">

  <li class="nav-item">
    <a href="/textbook/" class="btn" style="font-size: 20pt;" tabindex="-1" role="button" aria-disabled="false">
      <i class="bi bi-house-up"></i>
    </a>
  </li>
</ul>
<div class="container chapter">
  <p>By: <em>Johannes Korbmacher</em></p>
  <div class="m-4"><h1 id="fol">FOL<button class="btn btn-back-to-top">
    
  </button>
</h1>
<hr>

<p>In this chapter, you&rsquo;ll learn about <strong>first order logic (FOL)</strong>, which is the
benchmark for logical systems. FOL is one of the most expressive logic systems
in widespread use, and it finds applications from mathematics, the sciences, to
AI research.</p>
<p>In AI research, the main application of FOL is as a benchmark background system,
in which &ldquo;everything&rsquo;s possible&rdquo;. The impressive expressive strength of FOL
allows us to formalize almost any problem we might come across, which makes FOL
a great tool for <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Knowledge_engineering"
  target="_blank">knowledge
engineering</a>. At the same
time, FOL has important limitations that limits its direct use for AI applications.</p>
<p>In this chapter, you&rsquo;ll learn about the:</p>
<ul>
<li>
<a class="link-dark" href="#syntax">syntax</a> and</li>
<li>
<a class="link-dark" href="#semantics">semantics</a></li>
</ul>
<p>for FOL. After this, we&rsquo;ll briefly turn to the 
<a class="link-dark" href="#limitations">limitations</a> of
FOL. In the next chapter, we&rsquo;ll talk about the proof theory and inference
strategies for FOL.</p>
<h2 id="syntax">Syntax<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>You&rsquo;ve already seen the syntax of FOL as an example in



<a href="https://logicalmethods.ai/textbook/formal-languages//#examples"
   
   
   
   
   
   > 
  Chapter 3. Formal languages </a>

.</p>
<p>As quick recap, the <strong>alphabet</strong> for FOL contains:</p>
<p><strong>Non-logical symbols</strong></p>
<ul>
<li>
<p><em>Individual constants</em>: Typically <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">a,b,c,\dots</span> but in KR also mnemonic, like
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">Alan</span> or <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">Ada</span>. These stand for proper names, like “Alan” or “Ada”.</p>
</li>
<li>
<p><em>Function symbols</em>: Typically <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">f,g,h,\dots</span>, but in KR also mnemonic, like
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">MotherOf</span> or <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">BirthplaceOf</span>. These stand for functional/one-to-one relations between
objects: everybody has a (biological) mother, everybody has a birthplace, &hellip;</p>
</li>
<li>
<p><em>Predicates</em>: Typically, <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">P,Q,R,\dots</span> but also mnemonic, like <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">Blue</span> or
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">BiggerThan</span>. These stand for properties and relations, like something <em>being
blue</em> or one thing <em>being bigger than</em> another.</p>
</li>
</ul>
<p>Both function symbols and predicates have a so-called <em>arity</em>, which says how
many arguments they take. For example, <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">BiggerThan</span> has arity 2, since two
things stand in the relation of being bigger than: one is bigger than the other.</p>
<p><strong>Logical symbols</strong></p>
<ul>
<li>
<p><em>Variables</em>: Typically <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">x,y,z,\dots</span> but some authors use
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\alpha,\beta,\delta,\dots</span> and other symbols. Variables stand for arbitrary but
concrete objects and they play a fundamental role in quantification, which we&rsquo;ll
discuss below.</p>
</li>
<li>
<p><em>Sentential connectives</em>: We have the usual connectives
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\neg,\land,\lor,\to,\leftrightarrow</span>. These work just like before.</p>
</li>
<li>
<p><em>Quantifiers</em>: The universal quantifier <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall</span>, which stands for the
phrase &ldquo;for all&rdquo;, and the existential quantifier <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists</span>, which stands for
&ldquo;there is&rdquo;.</p>
</li>
</ul>
<p><strong>Auxiliaries</strong></p>
<ul>
<li>We have the usual auxiliaries parentheses <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">(,)</span> and the comma <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">,</span>.</li>
</ul>
<p>These symbols construct formulas according to the following <strong>grammar</strong>:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle const\rangle ::= a \mid b\mid \dots </div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle var\rangle ::= x \mid y\mid \dots </div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle unop\rangle ::= \neg</div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle binop\rangle ::= \land\mid\lor\mid\to\mid\leftrightarrow</div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle quant\rangle ::= \forall\mid\exists</div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle fun^n\rangle ::= f^n\mid g^n\mid \dots </div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle term\rangle::= \langle const\rangle\mid\langle variable\rangle\mid
\langle fun^n\rangle(\overbrace{\langle term\rangle,\dots,\langle term\rangle}^{n\text{ times}})</div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle pred^n\rangle ::= P^n\mid Q^n\mid \dots </div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle atom\rangle::= \langle pred^n\rangle(\underbrace{\langle term\rangle,\dots\langle term\rangle}_{n\text{ times}})</div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\langle fml\rangle::=\langle atom\rangle\mid\langle unop\rangle\langle fml\rangle\mid
(\langle fml\rangle\langle binop\rangle \langle fml\rangle)\mid \langle quant\rangle \langle
var\rangle\langle fml\rangle</div>
<p>Let&rsquo;s talk for a second about what this rather complex syntax means, informally
and how it can be used to express knowledge claims for the purpose of KR.</p>
<p>The traditional approach to natural language grammar highlights the
<strong>term-predicate</strong> structure of simple sentences. A sentence like:</p>
<ul>
<li>The robot is smart.</li>
</ul>
<p>says of a thing, <em>the robot</em>, that it has a property, <em>being smart</em>. The sentence
talks about the robot via the <em>singular term</em> &ldquo;the robot&rsquo;&rsquo; and it talks about
being smart using the <em>predicate</em> &ldquo;&hellip; is smart.''</p>
<p><strong>Atomic formulas</strong>, <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\langle atom\rangle</span> in the grammar, model the term-predicate
structure of simple sentences. Their main purpose in AI is to formalize simple
pieces knowledge, like:</p>
<ul>
<li><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{LLM}(ChatGPT)</span> to say that ChatGPT is a large language model.</li>
<li><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Sister}(Ada,Clara)</span> to say that Ada and Clara are sisters.</li>
<li><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Between}(Munich,Hamburg,Rome)</span> to say that Munich is between Hamburg
and Rome.</li>
</ul>
<p>Using these formulas, we can directly input most basic facts into a given
knowledge base.</p>
<p>The expressions we use to refer to objects are called <strong>terms</strong>, <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\langle
term\rangle</span> in the formal grammar. When doing knowledge representation with
FOL, we distinguish three different kinds of terms:</p>
<ul>
<li><em>proper names</em>, like &ldquo;Ada&rdquo; or &ldquo;Alan&rdquo;</li>
<li><em>pronouns</em>, like &ldquo;he,&rdquo; &ldquo;she,&rdquo; and &ldquo;it&rdquo;</li>
<li><em>functional terms</em>, like &ldquo;the birthplace of Ada Lovelace&rdquo;</li>
</ul>
<p>To each of these kinds of terms corresponds a syntactic category:</p>
<ul>
<li>The <strong>constants</strong>, <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\langle const\rangle</span>, formalize proper names.</li>
<li>The <strong>variables</strong>, <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\langle var\rangle</span>, formalize pronouns.</li>
<li>The <strong>function expressions</strong>, <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\langle fun^n\rangle(\langle term\rangle,\dots,\langle
term\rangle)</span>, formalize functional terms.</li>
</ul>
<p>Using these kinds of expressions, we can talk about most things we might want to
put information about in our knowledge base:</p>
<ul>
<li><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{AI}(Hal_{9000})</span> says that Hal 9000 is an AI-system.</li>
<li><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Sister}(Ada,x)</span> says that <em>they</em> (person <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">x</span>) is Ada&rsquo;s sister.</li>
<li><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Lord}(\mathsf{FatherOf}(Ada))</span> says that the father of Ada Lovelace
was a Lord (<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Lord_Byron"
  target="_blank">Byron</a>).</li>
</ul>
<p>The crucial addition in FOL, however, are the <strong>quantifiers</strong>, they are what
gives the logic its expressive strength.</p>
<p>In FOL we have the quantifiers <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall</span> for &ldquo;for all&rdquo; and <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists</span> for &ldquo;there
is&rsquo;&rsquo; (and synonymous expressions like &ldquo;every,&rsquo;&rsquo; &ldquo;some,&rsquo;&rsquo; &hellip;).</p>
<p>The quantifiers allow us to formalize <strong>general knowledge claims</strong>, such as:</p>
<ul>
<li>
<p><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists x(\mathsf{KB}(x)\land \mathsf{Trivial}(x))</span> to say that there is a
trivial knowledge base.</p>
</li>
<li>
<p><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall x(\mathsf{LLM}(x)\to \mathsf{StatsBased}(x))</span> to say that (all) LLMs
are statistic based.</p>
</li>
</ul>
<p>The variables play a crucial role in making this work. Here&rsquo;s how. Take the
claim that there&rsquo;s a trivial knowledge base. What underlies our formalization</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\exists x(\mathsf{KB}(x)\land \mathsf{Trivial}(x))</div> is the reading:
<ul>
<li>There is a thing and it is a knowledge base and it is trivial.</li>
</ul>
<p>Here &ldquo;it&rdquo; is an indefinite term that stands for an arbitrary but fixed object
which we say exists and is a trivial knowledge base. This indefinite term is,
logically speaking, a variable, which is why in our formalization &ldquo;it&rdquo; becomes
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">x</span>.</p>
<p>In many contexts, we add a <strong>distinguished identity predicate</strong> to our language
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">=</span>. Syntactically, <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">=</span> works just like any other binary predicate: flanked by
two terms it forms a formula <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">t_1=t_2</div> to say that the terms <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">t_1,t_2</span> denote
the same object. When we have <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">=</span>, we often use <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">t_1\neq t_2</div> to abbreviate
the formula <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\neg t_1=t_2.</div></p>
<p>Parsing in FOL works just like in any other language. But note that the parsing
tree for a formula also parses the terms involved. Here&rsquo;s an example:</p>


<img src="https://logicalmethods.ai/textbook/fol/img/parsing-tree.png" class="img-thumbnail"    alt="" >


<h2 id="semantics">Semantics<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>There are different ways to interpret FOL in AI. Here, we&rsquo;ll discuss the
standard <strong>set-theoretic semantics</strong>. It&rsquo;s the most general form of semantics
for FOL, which summarizes other approaches, like database semantics or
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Knowledge_graph"
  target="_blank">knowledge graphs</a>.</p>
<p>


<a href="https://logicalmethods.ai/textbook/boolean/"
   
   
   
   
   
   > Boolean algebra </a>

 is not
enough to interpret FOL. Even though Boolean truth-values and truth-function
will  we need more expressive structures to interpret FOL. What we need to
interpret the language of FOL are the <em>objects</em> that our language talks about.</p>
<p>These object together make up the <strong>domain (of discourse)</strong>. In a model for FOL,
typically denoted <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathcal{M}</span>, we denote the domain by <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathcal{D}</span>. The
domain can contain all sorts of things, but in KR-settings usually are just
representations of the objects our KB talks about. In a knowledge graph, for
example, we&rsquo;d represent the individuals as nodes in a graph. When we&rsquo;re using a
database as a model for FOL, we&rsquo;d use data to model the objects.</p>
<p>Given a domain, we need to say what our terms and predicates stand for. For the
terms, that&rsquo;s <em>relatively</em> straight-forward. For each constant, <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">c</span>, we assign a
<strong>denotation</strong> from among the objects of our model:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">c^\mathcal{M}\in\mathcal{D}</div>. So, we'd have, for example, a denotation
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">Ada^\mathcal{M}</span> which is our model's representation of Ada Lovelace. Depending
on what our domain looks like, this would be a node in a graph, an entry in a
database, or perhaps even a real person.
<p>For function symbols, the denotation is simply a <strong>(mathematical) function</strong>
over the domain. That means that if <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">f</span> is an <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">n</span>-ary function symbol, then</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">f^\mathcal{M}:\mathcal{D}^n\to \mathcal{D}</div> is an <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">n</span>-ary function, which
takes <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">n</span> inputs from the domain and assigns an output to them. For example,
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">Father^\mathcal{M}</span> would be a function which assigns to the representation of
each object in our model the representation of their father. We should have, for
example, <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\mathsf{Father}^\mathcal{M}(Ada^\mathcal{M})=Byron^\mathcal{M}</div> In
other words, the function <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Father}^\mathcal{M}</span> assigns to our
representation of Ada Lovelace the representation of Lord Byron, her father.
<p>Variables are a bit trickier to deal with. For them, we need an <strong>assignment</strong>,
which tells us what they stand for. An <strong>assigment</strong> in a model with domain
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathcal{D}</span> is a function <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\alpha:\Set{x,y,z,\dots}\to\mathcal{D}</div>, which says
for each variable what it stands for. For example, we might have</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\alpha(x)=Ada^\mathcal{M},</div> which would mean that <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">x</span> stands for the
representation of Ada. Assignments play an important role in FOL inference,
which we'll talk about more later. 
<p>Once we&rsquo;ve interpreted all our term-forming expressions over a domain, we can
assign denotations to arbitrary terms using recursion:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">t^\mathcal{M}_\alpha::=\\begin{cases} c^\mathcal{M} & \\text{if }t=c\\\\
\alpha(x) & \\text{if }t=x \\\\ f^\mathcal{M}(t_1^\mathcal{M}, \dots
t_n^\mathcal{M}) & \\text{if }t=f(t_1,\dots,t_n)\\end{cases}</div>
In this way, we get a denotation for each term <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\langle term\rangle</span> given a
model <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathcal{M}</span> and assignment <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\alpha</span>.
<p>The only thing that we haven&rsquo;t interpreted yet are the predicates. How does this
work? Let&rsquo;s look at unary predicates like <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Red}</span> first.
The idea is that for each predicate <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">P</span>, we need to say which of the
things in the domain <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathcal{D}</span> have the property &ldquo;being <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">P</span>&rdquo;. We do this
directly by assigning a set <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">P^\mathcal{M}\subseteq \mathcal{D}</span> to the predicate
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">P</span>. This set is called the <strong>extension</strong> of the predicate. In the case of
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Red}</span>, for example, we&rsquo;d set <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Red}^\mathcal{M}</span> to be the set
of all things our model represents as red.</p>
<p>This generalizes to <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">n</span>-ary predicates. If we have <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{BiggerThan}</span>, for
example, we&rsquo;d assign the set
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{BiggerThan}^\mathcal{M}\subseteq\mathcal{D}\times\mathcal{D}</span>, which
contains pairs of the form <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\langle object_1,object_2\rangle</span>, where <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">object_1</span>
is bigger than <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">object_2</span>. Here we use the standard set-theoretic notation
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathcal{D}^n</span> to denote all the sequences of <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">n</span> objects from the domain.</p>
<p>In sum, the basic concept concept of FOL semantics is that of a <strong>model</strong>,
typically <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathcal{M}</span>, which consists of:</p>
<ul>
<li>A <strong>domain</strong> <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathcal{D}</span>, which contains all the individuals that we talk
about.</li>
<li>A <strong>denotation</strong> <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">a^\mathcal{M}\in \mathcal{D}</span> for each constant <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">a</span>.</li>
<li>A <strong>function</strong> <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">f^\mathcal{M}:\mathcal{D}^n\to \mathcal{D}</span> for each function
symbol.</li>
<li>An <strong>extension</strong> <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">P^\mathcal{M}\subseteq \mathcal{D}^n</span> for each
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">n</span>-ary predicate.</li>
</ul>
<p>Additionally, we have assignments <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\alpha: \Set{x,y,z,\dots}\to\mathcal{D}</span>.</p>
<p>With all of this setup, we can re-introduce truth-values into the semantics. For
FOL, our setting remains classical meaning we have the two truth-values
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\Set{0,1}</span> for false and true respectively.</p>
<p>Our aim is to assign a truth-value <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\nu(A)\in\Set{0,1}</span> to each FOL-formula. We
do this by recursion. Once we look at how we interpreted our language, the base
case is pretty clear. Take <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Sister}(Ada,Clara)</span> for example. Our model
gives us:</p>
<ul>
<li><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">Ada^\mathcal{M}</span>, which is a representation of Ada.</li>
<li><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">Clara^\mathcal{M}</span>, which is a representation of Clara.</li>
<li><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathsf{Sister}^\mathcal{M}</span>, which is a set of pairs <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\langle
object_1,object_2\rangle</span> where <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">object_1</span> represents the sister of <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">object_2</span>.</li>
</ul>
<p>Given this reading, we should set:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu(\mathsf{Sister}(Ada^\mathcal{M},Clara^\mathcal{M}))=1\Leftrightarrow
\langle Ada^\mathcal{M},Clara^\mathcal{M}\rangle\in\mathsf{Sister}^\mathcal{M}</div>
<p>That is, in our model, the formula which says that Ada and Clara are sisters
should be true just in case the pair is a member of the set of things that
represent sisters.</p>
<p>What if variables are involved? Well, then we need assignments and our
truth-value becomes relative to an assignment. So, for example, we&rsquo;d have</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(\mathsf{Blue}(x))=1\Leftrightarrow \alpha(x)\in\mathsf{Blue}^\mathcal{M}</div>
<p>So, in general, then, the definition should be:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(P(t_1,\dots,t_n))=1\Leftrightarrow \langle
(t_1)^\mathcal{M}\_\alpha,\dots,(t_n)^\mathcal{M}_\alpha\rangle\in P^\mathcal{M}</div>
<p>At this point it might be important to mention that in a model, we can represent
things in different ways. Of course, we should also allow models where Ada and
Clara aren&rsquo;t sisters, even if in reality they are.</p>
<p>An important exception to this is the identity predicate <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">=</span> around. We are not allowed to freely re-interpret this predicate, it always stands for identity. That means that it&rsquo;s subject to a special clause, which is:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(t_1=t_2)=1\Leftrightarrow t_1^\mathcal{M}=t_2^\mathcal{M}</div>
<p>Now, when it comes to the connectives <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\neg,\land,\lor,\to,\dots</span>, we
can fall back to the usual 


<a href="https://logicalmethods.ai/textbook/boolean//#truth-functions"
   
   
   
   
   
   >
Boolean truth-functions </a>

:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(\neg A)=-\nu_\alpha(A)</div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(A\land B)=\nu_\alpha(A)\times \nu_\alpha(B)</div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(A\lor B)=\nu_\alpha(A)+\nu_\alpha(B)</div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(A\to B)=\nu_\alpha(A)\Rightarrow\nu_\alpha(B)</div>
<p>It gets interesting when it comes to the quantifiers. In addition to the Boolean
truth-functions , we&rsquo;ll need to find corresponding truth-functions
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">f_\forall,f_\exists</span> for the quantifiers <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall,\exists</span>.</p>
<p>How does this work? Let&rsquo;s start with <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall</span> and take <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall
x\mathsf{Blue}(x)</span>, for example. What we want is to say that <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall
x\mathsf{Blue}(x)</span> is true just in case all the things in our model are blue. To
formally represent this, let&rsquo;s introduce for each object <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">o\in\mathcal{D}</span> an
ad-hoc name <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathbf{o}</span> into our language with the stipulation that</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\mathbf{o}^\mathcal{M}=o.</div> This constant, then, allows us to consider the
truth-value sequence
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(\mathsf{Blue}(\mathbf{o_1})),\nu_\alpha(\mathsf{Blue}(\mathbf{o_2})),\dots</div>
for _all_ the objects <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">o_1,o_2,\dots</span> in the domain.
<p>When do we want to say that <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall x\mathsf{Blue}(x)</span> is true? The answer
seems to be when the sequence above just is <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">1,1,1,\dots.</div> In other words,
when <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\nu_\alpha(\mathsf{Blue}(\mathbf{o}))=1</span> for all objects <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">o\in\mathcal{D}</span></p>
<p>Think about a product <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">x\times y\times z\times\dots</div> where
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">x,y,z\in\Set{0,1}</span>. This number is <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">1</span> precisely when the sequence</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">x,y,z,\dots</div> is the sequence <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">1,1,1,\dots.</div> This means we can give the
following truth-functional analysis of the quantifiers:
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu\_\alpha(\forall x\mathsf{Blue}(x))=\nu_\alpha(\mathsf{Blue}(\mathbf{o}_1))\times\nu\_\alpha(\mathsf{Blue}(\mathbf{o}_2)\times\dots</div>
where <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">o_1,o_2,\dots</span> are all the objects in <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathcal{D}</span>
<p>We can write this in a more concise form using the mathematical notation for
&ldquo;long&rdquo; products:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu\_\alpha(\forall
x\mathsf{Blue}(x))=\nu_\alpha(\mathsf{Blue}(\mathbf{o}_1))\times\nu\_\alpha(\mathsf{Blue}(\mathbf{o}\_2))\times\dots=\prod\_{o\in\mathcal{D}}\nu\_\alpha(\mathsf{Blue}(\mathbf{o}))</div>
<p>Similar reasoning works for <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists</span>. In order for <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\nu_\alpha(\exists x\mathsf{Blue}(x))=1</span>, we would want to have at least one <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">1</span> in the sequence:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu\_\alpha(\mathsf{Blue}(\mathbf{o}\_1)),\nu_\alpha(\mathsf{Blue}(\mathbf{o}_2)),\dots</div>
<p>We can express this using the Boolean <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">+</span> by saying that:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(\exists x\mathsf{Blue}(x))=\nu_\alpha(\mathsf{Blue}(\mathbf{o}\_1))+\nu\_\alpha(\mathsf{Blue}(\mathbf{o}\_2)+\dots</div>
<p>Mathematically, we can write this:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(\exists x\mathsf{Blue}(x))=\nu\_\alpha(\mathsf{Blue}(\mathbf{o}_1))+\nu\_\alpha(\mathsf{Blue}(\mathbf{o}_2))+\dots=\sum\_{o\in\mathcal{D}}\nu\_\alpha(\mathsf{Blue}(\mathbf{o}))</div>
<p>The only thing left to do is to generalize this from the formulas <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall
x\mathsf{Blue}(x),\exists x\mathsf{Blue}(x)</span> to arbitrary formulas of the form
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall xA</span> and <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists xA</span>. For this, we just need a piece of notation: we
write <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall xA(x)</span> to indicate that <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">A</span> contains the variable <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">x</span> that we
quantify &ldquo;over&rdquo; and then write <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">A(\mathbf{o})</span> for the result of replacing all
the occurrences of <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">x</span> in <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">A</span>, which are not involved in another quantifier with
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\mathbf{o}</span>.</p>
<p>So, for example, if <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall xA(x)</span> is <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\forall x(\mathsf{Student}(x)\to
\mathsf{OlderThan}(x,18))</div> then <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">A(x)=\mathsf{Student}(x)\to
\mathsf{OlderThan}(x,18))</div> and <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">A(\mathbf{o})=\mathsf{Student}(\mathbf{o})\to
\mathsf{OlderThan}(\mathbf{o},18)).</div></p>
<p>Using this notation, we can finally give the full recursive clauses for
<span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall,\exists</span>:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(\forall xA(x))=\prod_{o\in\mathcal{D}}\nu_\alpha(A(\mathbf{o}))</div>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">\nu_\alpha(\exists xA(x))=\sum_{o\in\mathcal{D}}\nu_\alpha(A(\mathbf{o}))</div>
<p>This completes the rather long definition of a model for FOL, variable
assignments <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\alpha</span>, of  and the associated valuation function <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\nu</span>.</p>
<p>One way of looking at the <strong>aim of knowledge representation in FOL</strong> is to
describe an adequate model of the way we know/think the world is like using
FOL-formulas.</p>
<p>At this stage, we can give a definition of valid inference in FOL. We simply use
the idea from 


<a href="https://logicalmethods.ai/textbook/valid-inference//#examples"
   
   
   
   
   
   > Chapter
2. Valid inference </a>

 of modeling deductively valid inference
as truth-preservation from premises to conclusion in all models:</p>
<div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">P_1,P_2,\dots \vDash C\Leftrightarrow \text{ for all
}\mathcal{M},\nu,\alpha,\text{ if
}\nu_\alpha(P_1)=1,\nu_\alpha(P_2)=1,\dots\text{, then }\nu_\alpha(C)=1.</div>
<p>This definition gives rise to a series of <strong>FOL laws</strong>. The following
<strong>quantifier laws</strong> are especially important:</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th>   </th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Duality of <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists/\forall</span></td>
          <td></td>
          <td><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists xA\vDash \neg\forall x\neg A\qquad \neg\forall x\neg A\vDash \exists xA</span></td>
      </tr>
      <tr>
          <td>Duality of <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall/\exists</span></td>
          <td></td>
          <td><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall xA\vDash \neg\exists x\neg A\qquad \neg\exists x\neg A\vDash \forall xA</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>Distribution <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall/\land</span></td>
          <td></td>
          <td><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall x(A\land B)\vDash \forall xA\land \forall xB\qquad \forall x A\land \forall x B\vDash \forall x(A\land B)</span></td>
      </tr>
      <tr>
          <td>Distribution <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists/\lor</span></td>
          <td></td>
          <td><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists x(A\lor B)\vDash \exists xA\lor \exists xB\qquad \exists x A\lor \exists x B\vDash \exists x(A\lor B)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>Commutativity <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall</span></td>
          <td></td>
          <td><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\forall x\forall yA\vDash \forall y\forall xA</span></td>
      </tr>
      <tr>
          <td>Commutativity <span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists</span></td>
          <td></td>
          <td><span class="excalifont" style="  font-size: clamp(0.9rem, 1vw + 0.5rem, 1.4rem);">\exists x\exists yA\vDash \exists y\exists xA</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>There are more quantifier laws, some of which you&rsquo;ll explore in the exercises.</p>
<h2 id="limitations">Limitations<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>While <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem"
  target="_blank">Gödel&rsquo;s original completeness theorem</a> showed that the Hilbert system for FOL is sound and complete, i.e. we have <div class="text-center my-4 excalifont" style="font-size: clamp(1.4rem, 1vw + 0.5rem, 2rem);">P_1,P_2,\dots\vDash C\Leftrightarrow P_1,P_2,\dots\vdash C</div> in FOL, there are two important limiting results about FOL with severe implications for AI.</p>
<p>We&rsquo;ve already mentioned these results in 


<a href="https://logicalmethods.ai/textbook/logic-and-ai//#as-a-foundation"
   
   
   
   
   
   > Chapter 1. Logic and AI </a>

:</p>
<ul>
<li>
<p>Gödel&rsquo;s <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems"
  target="_blank"><strong>(first) incompleteness
theorem</strong></a>,
which implies that for every logical system that is free of internal
contradictions and models basic mathematical reasoning, there is a mathematical
statement that is <em>undecidable</em> in the system, meaning that the statement can
neither be proven nor refuted in that system.</p>
</li>
<li>
<p>Turing&rsquo;s <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Decidability_%28logic%29"
  target="_blank"><strong>undecidability
theorem</strong></a>, which states
that validity in the standard system of predicate logic is <em>(algorithmically)
undecidable</em>, meaning that  there is no algorithm and there can never be an
algorithm that correctly determines in finitely many steps whether any given
inference in the system of predicate logic is valid.</p>
<p>This result seems to show directly that we cannot &ldquo;fully automate&rdquo; validity
checking using AI and maintain absolute reliability.</p>
</li>
</ul>
<p>These two results are explicitly <strong>about FOL</strong>. Gödel&rsquo;s incompleteness theorem
is concerns possible extensions of FOL axiomatizations of arithmetic, the theory
of natural numbers.</p>
<p>While the proof of the incompleteness theorem is out of scope for this book, the
result involves an impressive illustration of the expressive power of FOL:</p>
<ul>
<li>
<p>The standard theory of the natural numbers, which is the basis for <em>all</em>
modern number theory is <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Peano_axioms"
  target="_blank">Peano arithmetic</a> is a FOL-theory.</p>
</li>
<li>
<p>The proof of Gödel&rsquo;s result involves showing that FOL can develop a theory of
syntax <em>in general</em>. That is, the theory of formal languages we&rsquo;ve covered in 


<a href="https://logicalmethods.ai/textbook/formal-languages/"
   
   
   
   
   
   > Chapter 3. Formal languages </a>

 is itself a FOL-theory.</p>
</li>
</ul>
<p>On the other hand, Gödel&rsquo;s result shows that we <em>cannot</em>, not matter how hard we
try, develop an expert system involving a consistent knowledge bank that
contains <em>all</em> mathematical truths. In other words, we cannot develop a
consistent, mathematically omniscient AI.</p>
<p>Turing&rsquo;s result is also about FOL. It concerns the perhaps surprising fact that
while our best proof systems for FOL are sound and complete, there&rsquo;s no
algorithm for determining whether any given inference is valid or not. This
makes inference in FOL a <em>hard</em> topic, which we&rsquo;ll look into in the next
chapter.</p>
<p>Just like with Gödel&rsquo;s theorem, the proof of Turing&rsquo;s theorem is out of scope.
But what we&rsquo;ll be able to appreciate are the pitfalls that naive inference
algorithms in FOL can fall into, such as <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Infinite_loop"
  target="_blank">infinite
loops</a> in proof search, for
example.</p>


  </div>
   <p><em>Last edited: </em>09/10/2024</p>
</div>


<ul class="navbar-nav flex-row justify-content-between mt-auto">
  
  <li class="nav-item">
    <a href="/textbook/proofs/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-left"></i>
    </a>
    
  </li>
  <li class="nav-item">
    <button class="btn btn-back-to-top">
    <i class="bi bi-chevron-double-up"></i>
  </button>
  </li>
  <li class="nav-item">
    
    <a href="/textbook/fol-inference/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-right"></i>
    </a>
    
  </li>
</ul>

    </main>
    <footer class="align-self-center d-flex flex-column mt-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="footer-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="/about" aria-label="copyright-link">&copy; 2025 jkorbmacher et al. </a>
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link fs-6" href="https://github.com/jkorb/logicalmethods.ai" target="_blank"><i class="bi bi-github"></i></a>
      </li>
    </ul>
  </div>
</nav>
 
      <script src="https://logicalmethods.ai/js/helpers.js"></script>
      <script src="https://logicalmethods.ai/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
      
      
    </footer>
  </body>
</html>
