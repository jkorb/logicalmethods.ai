<!doctype html>
<html lang="en" data-bs-theme="light">
  <head>
    <meta charset="utf-8"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <title>logicalmethods.ai &ndash; FOL </title>
    <link rel="icon" type="image/x-icon" href="https://logicalmethods.ai/favicon.ico"></link>
    <link href="https://logicalmethods.ai/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/icons/font/bootstrap-icons.min.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/layout.css"></link>
    <link href="https://logicalmethods.ai/css/textbook.css" rel="stylesheet"></link>
    <style>
      
    :root {
      --chapter: "8";
    }

    </style>
    
      <link rel="stylesheet" href="https://logicalmethods.ai/katex/katex.min.css">
<script defer src="https://logicalmethods.ai/katex/katex.min.js"></script>
<script defer src="https://logicalmethods.ai/katex/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},     
        {left: '\\[', right: '\\]', display: true},   
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>


    
  </head>
  <body class="bg-black d-flex flex-column m-0 p-0">
    <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvas-nav" aria-labelledby="offcanvas-navLabel" data-bs-theme="dark">
  <div class="offcanvas-header">
    <div class="h5 offcanvas-title" id="offcanvas-navLabel">
      Browse course
    </div>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  
  <div class="offcanvas-body">
    <ul class="navbar-nav"><li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link fw-bold active" href="/textbook/"><i class="bi bi-book"></i> &nbsp;&nbsp; Textbook</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/textbook/"
            id="navbarSectiontxt-home" data-bs-toggle="collapse"
            data-bs-target="#collapsetxt-home"  
            aria-expanded="true"
            aria-controls="collapsetxt-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse show" id="collapsetxt-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item " href="/textbook/logic-and-ai/">1. Logic and AI</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/valid-inference/">2. Valid Inference</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/formal-languages/">3. Formal languages</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/boolean/">4. Boolean algebra</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/sat/">5. Boolean satisfiability</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/conditionals/">6. Logical conditionals</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/proofs/">7. Logical proofs</a>
            </li>
            
            <li>
              <a class="dropdown-item fw-bold active" href="/textbook/fol/">8. FOL</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/fol-inference/">9. FOL Inference</a>
            </li>
            </ul>
        </div>
        
      </li>
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/slides/"><i class="bi bi-rocket-takeoff-fill"></i> &nbsp;&nbsp; Slides</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/slides/"
            id="navbarSectionsli-home" data-bs-toggle="collapse"
            data-bs-target="#collapsesli-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapsesli-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapsesli-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item " href="/slides/logic-and-ai/">1. Logic and AI</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/valid-inference/">2. Valid inference</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/formal-languages/">3. Formal languages</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/boolean/">4. Boolean algebra</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/sat/">5. Boolean satisfiability</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/conditionals/">6. Logical conditionals</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/proof/">7. Logical proofs</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/fol/">8. FOL</a>
            </li>
            </ul>
        </div>
        
      </li>
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/exercises/"><i class="bi-gear-fill"></i> &nbsp;&nbsp; Exercises</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/exercises/"
            id="navbarSectionexe-home" data-bs-toggle="collapse"
            data-bs-target="#collapseexe-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseexe-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseexe-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item " href="/exercises/logic-and-ai/">1. Logic and AI</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/valid-inference/">2. Valid inference</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/formal-languages/">3. Formal languages</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/boolean/">4. Boolean algebra</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/sat/">5. Boolean satisfiability</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/conditionals/">6. Logical conditionals</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/proof/">7. Logical proofs</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/fol/">8. FOL</a>
            </li>
            </ul>
        </div>
        
      </li>
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/about/"><i class="bi-file-person-fill"></i> &nbsp;&nbsp; About</a>
          </div>
      </li>
      <hr>
      
    </ul>
  </div>
</div>

    <header class="align-self-center d-flex flex-column m-0 mb-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="header-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="https://logicalmethods.ai/"><span style="margin-right:-4px;vertical-align: middle;transform-origin: 50%  49%;transform:rotate(180deg);display:inline-block">IA</span>
<i class="bi bi-caret-right-fill"></i>logicalmethods.ai</a>
    <button class="navbar-toggler border-0" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas-nav" aria-controls="offcanvas-nav">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
</nav>

      
      
    </header>
    
    <main class="align-self-center d-flex flex-column flex-fill bg-light m-md-1 p-0" data-bs-theme="light">
      <ul class="navbar-nav flex-row justify-content-between mt-2">
  
  <li class="nav-item">
    <a href="/textbook/proofs/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-left"></i>
    </a>
    
  </li>
  <li class="nav-item">
    <a href="/textbook/" class="btn " tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-house-up"></i>
    </a>
  </li>
  <li class="nav-item">
    
    <a href="/textbook/fol-inference/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-right"></i>
    </a>
    
  </li>
</ul>
<div class="container chapter">
  <p>By: <em>Johannes Korbmacher</em></p><h1 id="fol">FOL<button class="btn btn-back-to-top">
    
  </button>
</h1>
<hr>

<p>In this chapter, you&rsquo;ll learn about <strong>first order logic (FOL)</strong>, which is the
benchmark for logical systems. FOL is one of the most expressive logic systems
in widespread use, and it finds applications from mathematics, the sciences, to
AI research.</p>
<p>In AI research, the main application of FOL is as a benchmark background system,
in which &ldquo;everything&rsquo;s possible&rdquo;. The impressive expressive strength of FOL
allows us to formalize almost any problem we might come across, which makes FOL
a great tool for <a href="https://en.wikipedia.org/wiki/Knowledge_engineering"
  target="_blank">knowledge
engineering</a>. At the same
time, FOL has important limitations that limits its direct use for AI applications.</p>
<p>In this chapter, you&rsquo;ll learn about the:</p>
<ul>
<li><a href="#syntax">syntax</a> and</li>
<li><a href="#semantics">semantics</a></li>
</ul>
<p>for FOL. After this, we&rsquo;ll briefly turn to the <a href="#limitations">limitations</a> of
FOL. In the next chapter, we&rsquo;ll talk about the proof theory and inference
strategies for FOL.</p>
<h2 id="syntax">Syntax<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>You&rsquo;ve already seen the syntax of FOL as an example in



<a href="https://logicalmethods.ai/textbook/formal-languages//#examples"
   
   
   
   
   
   > 
  Chapter 3. Formal languages </a>

.</p>
<p>As quick recap, the <strong>alphabet</strong> for FOL contains:</p>
<p><strong>Non-logical symbols</strong></p>
<ul>
<li>
<p><em>Individual constants</em>: Typically $a,b,c,\dots$ but in KR also mnemonic, like
$Alan$ or $Ada$. These stand for proper names, like “Alan” or “Ada”.</p>
</li>
<li>
<p><em>Function symbols</em>: Typically $f,g,h,\dots$, but in KR also mnemonic, like
$MotherOf$ or $BirthplaceOf$. These stand for functional/one-to-one relations between
objects: everybody has a (biological) mother, everybody has a birthplace, &hellip;</p>
</li>
<li>
<p><em>Predicates</em>: Typically, $P,Q,R,\dots$ but also mnemonic, like $Blue$ or
$BiggerThan$. These stand for properties and relations, like something <em>being
blue</em> or one thing <em>being bigger than</em> another.</p>
</li>
</ul>
<p>Both function symbols and predicates have a so-called <em>arity</em>, which says how
many arguments they take. For example, $BiggerThan$ has arity 2, since two
things stand in the relation of being bigger than: one is bigger than the other.</p>
<p><strong>Logical symbols</strong></p>
<ul>
<li>
<p><em>Variables</em>: Typically $x,y,z,\dots$ but some authors use
$\alpha,\beta,\delta,\dots$ and other symbols. Variables stand for arbitrary but
concrete objects and they play a fundamental role in quantification, which we&rsquo;ll
discuss below.</p>
</li>
<li>
<p><em>Sentential connectives</em>: We have the usual connectives
$\neg,\land,\lor,\to,\leftrightarrow$. These work just like before.</p>
</li>
<li>
<p><em>Quantifiers</em>: The universal quantifier $\forall$, which stands for the
phrase &ldquo;for all&rdquo;, and the existential quantifier $\exists$, which stands for
&ldquo;there is&rdquo;.</p>
</li>
</ul>
<p><strong>Auxiliaries</strong></p>
<ul>
<li>We have the usual auxiliaries parentheses $(,)$ and the comma $,$.</li>
</ul>
<p>These symbols construct formulas according to the following <strong>grammar</strong>:</p>
<p>$$\langle const\rangle ::= a \mid b\mid \dots $$
$$\langle var\rangle ::= x \mid y\mid \dots $$
$$\langle unop\rangle ::= \neg$$
$$\langle binop\rangle ::= \land\mid\lor\mid\to\mid\leftrightarrow$$
$$\langle quant\rangle ::= \forall\mid\exists$$
$$\langle fun^n\rangle ::= f^n\mid g^n\mid \dots $$
$$\langle term\rangle::= \langle const\rangle\mid\langle variable\rangle\mid
\langle fun^n\rangle(\overbrace{\langle term\rangle,\dots,\langle term\rangle}^{n\text{ times}})$$
$$\langle pred^n\rangle ::= P^n\mid Q^n\mid \dots $$
$$\langle atom\rangle::= \langle pred^n\rangle(\underbrace{\langle term\rangle,\dots\langle term\rangle}_{n\text{ times}})$$
$$\langle fml\rangle::=\langle atom\rangle\mid\langle unop\rangle\langle fml\rangle\mid
(\langle fml\rangle\langle binop\rangle \langle fml\rangle)\mid \langle quant\rangle \langle
var\rangle\langle fml\rangle$$</p>
<p>Let&rsquo;s talk for a second about what this rather complex syntax means, informally
and how it can be used to express knowledge claims for the purpose of KR.</p>
<p>The traditional approach to natural language grammar highlights the
<strong>term-predicate</strong> structure of simple sentences. A sentence like:</p>
<ul>
<li>The robot is smart.</li>
</ul>
<p>says of a thing, <em>the robot</em>, that it has a property, <em>being smart</em>. The sentence
talks about the robot via the <em>singular term</em> &ldquo;the robot&rsquo;&rsquo; and it talks about
being smart using the <em>predicate</em> &ldquo;&hellip; is smart.''</p>
<p><strong>Atomic formulas</strong>, $\langle atom\rangle$ in the grammar, model the term-predicate
structure of simple sentences. Their main purpose in AI is to formalize simple
pieces knowledge, like:</p>
<ul>
<li>$\mathsf{LLM}(ChatGPT)$ to say that ChatGPT is a large language model.</li>
<li>$\mathsf{Sister}(Ada,Clara)$ to say that Ada and Clara are sisters.</li>
<li>$\mathsf{Between}(Munich,Hamburg,Rome)$ to say that Munich is between Hamburg
and Rome.</li>
</ul>
<p>Using these formulas, we can directly input most basic facts into a given
knowledge base.</p>
<p>The expressions we use to refer to objects are called <strong>terms</strong>, $\langle
term\rangle$ in the formal grammar. When doing knowledge representation with
FOL, we distinguish three different kinds of terms:</p>
<ul>
<li><em>proper names</em>, like &ldquo;Ada&rdquo; or &ldquo;Alan&rdquo;</li>
<li><em>pronouns</em>, like &ldquo;he,&rdquo; &ldquo;she,&rdquo; and &ldquo;it&rdquo;</li>
<li><em>functional terms</em>, like &ldquo;the birthplace of Ada Lovelace&rdquo;</li>
</ul>
<p>To each of these kinds of terms corresponds a syntactic category:</p>
<ul>
<li>The <strong>constants</strong>, $\langle const\rangle$, formalize proper names.</li>
<li>The <strong>variables</strong>, $\langle var\rangle$, formalize pronouns.</li>
<li>The <strong>function expressions</strong>, $\langle fun^n\rangle(\langle term\rangle,\dots,\langle
term\rangle)$, formalize functional terms.</li>
</ul>
<p>Using these kinds of expressions, we can talk about most things we might want to
put information about in our knowledge base:</p>
<ul>
<li>$\mathsf{AI}(Hal_{9000})$ says that Hal 9000 is an AI-system.</li>
<li>$\mathsf{Sister}(Ada,x)$ says that <em>they</em> (person $x$) is Ada&rsquo;s sister.</li>
<li>$\mathsf{Lord}(\mathsf{FatherOf}(Ada))$ says that the father of Ada Lovelace
was a Lord (<a href="https://en.wikipedia.org/wiki/Lord_Byron"
  target="_blank">Byron</a>).</li>
</ul>
<p>The crucial addition in FOL, however, are the <strong>quantifiers</strong>, they are what
gives the logic its expressive strength.</p>
<p>In FOL we have the quantifiers $\forall$ for &ldquo;for all&rdquo; and $\exists$ for &ldquo;there
is&rsquo;&rsquo; (and synonymous expressions like &ldquo;every,&rsquo;&rsquo; &ldquo;some,&rsquo;&rsquo; &hellip;).</p>
<p>The quantifiers allow us to formalize <strong>general knowledge claims</strong>, such as:</p>
<ul>
<li>
<p>$\exists x(\mathsf{KB}(x)\land \mathsf{Trivial}(x))$ to say that there is a
trivial knowledge base.</p>
</li>
<li>
<p>$\forall x(\mathsf{LLM}(x)\to \mathsf{StatsBased}(x))$ to say that (all) LLMs
are statistic based.</p>
</li>
</ul>
<p>The variables play a crucial role in making this work. Here&rsquo;s how. Take the
claim that there&rsquo;s a trivial knowledge base. What underlies our formalization
$$\exists x(\mathsf{KB}(x)\land \mathsf{Trivial}(x))$$ is the reading:</p>
<ul>
<li>There is a thing and it is a knowledge base and it is trivial.</li>
</ul>
<p>Here &ldquo;it&rdquo; is an indefinite term that stands for an arbitrary but fixed object
which we say exists and is a trivial knowledge base. This indefinite term is,
logically speaking, a variable, which is why in our formalization &ldquo;it&rdquo; becomes
$x$.</p>
<p>In many contexts, we add a <strong>distinguished identity predicate</strong> to our language
$=$. Syntactically, $=$ works just like any other binary predicate: flanked by
two terms it forms a formula $$t_1=t_2$$ to say that the terms $t_1,t_2$ denote
the same object. When we have $=$, we often use $$t_1\neq t_2$$ to abbreviate
the formula $$\neg t_1=t_2.$$</p>
<p>Parsing in FOL works just like in any other language. But note that the parsing
tree for a formula also parses the terms involved. Here&rsquo;s an example:</p>


<img src="https://logicalmethods.ai/textbook/fol/img/parsing-tree.png" class="img-thumbnail"  alt="" >


<h2 id="semantics">Semantics<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>There are different ways to interpret FOL in AI. Here, we&rsquo;ll discuss the
standard <strong>set-theoretic semantics</strong>. It&rsquo;s the most general form of semantics
for FOL, which summarizes other approaches, like database semantics or
<a href="https://en.wikipedia.org/wiki/Knowledge_graph"
  target="_blank">knowledge graphs</a>.</p>
<p>


<a href="https://logicalmethods.ai/textbook/boolean/"
   
   
   
   
   
   > Boolean algebra </a>

 is not
enough to interpret FOL. Even though Boolean truth-values and truth-function
will  we need more expressive structures to interpret FOL. What we need to
interpret the language of FOL are the <em>objects</em> that our language talks about.</p>
<p>These object together make up the <strong>domain (of discourse)</strong>. In a model for FOL,
typically denoted $\mathcal{M}$, we denote the domain by $\mathcal{D}$. The
domain can contain all sorts of things, but in KR-settings usually are just
representations of the objects our KB talks about. In a knowledge graph, for
example, we&rsquo;d represent the individuals as nodes in a graph. When we&rsquo;re using a
database as a model for FOL, we&rsquo;d use data to model the objects.</p>
<p>Given a domain, we need to say what our terms and predicates stand for. For the
terms, that&rsquo;s <em>relatively</em> straight-forward. For each constant, $c$, we assign a
<strong>denotation</strong> from among the objects of our model:
$$c^\mathcal{M}\in\mathcal{D}$$. So, we&rsquo;d have, for example, a denotation
$Ada^\mathcal{M}$ which is our model&rsquo;s representation of Ada Lovelace. Depending
on what our domain looks like, this would be a node in a graph, an entry in a
database, or perhaps even a real person.</p>
<p>For function symbols, the denotation is simply a <strong>(mathematical) function</strong>
over the domain. That means that if $f$ is an $n$-ary function symbol, then
$$f^\mathcal{M}:\mathcal{D}^n\to \mathcal{D}$$ is an $n$-ary function, which
takes $n$ inputs from the domain and assigns an output to them. For example,
$Father^\mathcal{M}$ would be a function which assigns to the representation of
each object in our model the representation of their father. We should have, for
example, $$\mathsf{Father}^\mathcal{M}(Ada^\mathcal{M})=Byron^\mathcal{M}$$ In
other words, the function $\mathsf{Father}^\mathcal{M}$ assigns to our
representation of Ada Lovelace the representation of Lord Byron, her father.</p>
<p>Variables are a bit trickier to deal with. For them, we need an <strong>assignment</strong>,
which tells us what they stand for. An <strong>assigment</strong> in a model with domain
$\mathcal{D}$ is a function $$\alpha:\Set{x,y,z,\dots}\to\mathcal{D}$$, which says
for each variable what it stands for. For example, we might have
$$\alpha(x)=Ada^\mathcal{M},$$ which would mean that $x$ stands for the
representation of Ada. Assignments play an important role in FOL inference,
which we&rsquo;ll talk about more later.</p>
<p>Once we&rsquo;ve interpreted all our term-forming expressions over a domain, we can
assign denotations to arbitrary terms using recursion:
$$t^\mathcal{M}_\alpha::=\begin{cases} c^\mathcal{M} &amp; \text{if }t=c\\
\alpha(x) &amp; \text{if }t=x \\ f^\mathcal{M}(t_1^\mathcal{M}, \dots
t_n^\mathcal{M}) &amp; \text{if }t=f(t_1,\dots,t_n)\end{cases}$$
In this way, we get a denotation for each term $\langle term\rangle$ given a
model $\mathcal{M}$ and assignment $\alpha$.</p>
<p>The only thing that we haven&rsquo;t interpreted yet are the predicates. How does this
work? Let&rsquo;s look at unary predicates like $\mathsf{Red}$ first.
The idea is that for each predicate $P$, we need to say which of the
things in the domain $\mathcal{D}$ have the property &ldquo;being $P$&rdquo;. We do this
directly by assigning a set $P^\mathcal{M}\subseteq \mathcal{D}$ to the predicate
$P$. This set is called the <strong>extension</strong> of the predicate. In the case of
$\mathsf{Red}$, for example, we&rsquo;d set $\mathsf{Red}^\mathcal{M}$ to be the set
of all things our model represents as red.</p>
<p>This generalizes to $n$-ary predicates. If we have $\mathsf{BiggerThan}$, for
example, we&rsquo;d assign the set
$\mathsf{BiggerThan}^\mathcal{M}\subseteq\mathcal{D}\times\mathcal{D}$, which
contains pairs of the form $\langle object_1,object_2\rangle$, where $object_1$
is bigger than $object_2$. Here we use the standard set-theoretic notation
$\mathcal{D}^n$ to denote all the sequences of $n$ objects from the domain.</p>
<p>In sum, the basic concept concept of FOL semantics is that of a <strong>model</strong>,
typically $\mathcal{M}$, which consists of:</p>
<ul>
<li>A <strong>domain</strong> $\mathcal{D}$, which contains all the individuals that we talk
about.</li>
<li>A <strong>denotation</strong> $a^\mathcal{M}\in \mathcal{D}$ for each constant $a$.</li>
<li>A <strong>function</strong> $f^\mathcal{M}:\mathcal{D}^n\to \mathcal{D}$ for each function
symbol.</li>
<li>An <strong>extension</strong> $P^\mathcal{M}\subseteq \mathcal{D}^n$ for each
$n$-ary predicate.</li>
</ul>
<p>Additionally, we have assignments $\alpha: \Set{x,y,z,\dots}\to\mathcal{D}$.</p>
<p>With all of this setup, we can re-introduce truth-values into the semantics. For
FOL, our setting remains classical meaning we have the two truth-values
$\Set{0,1}$ for false and true respectively.</p>
<p>Our aim is to assign a truth-value $\nu(A)\in\Set{0,1}$ to each FOL-formula. We
do this by recursion. Once we look at how we interpreted our language, the base
case is pretty clear. Take $\mathsf{Sister}(Ada,Clara)$ for example. Our model
gives us:</p>
<ul>
<li>$Ada^\mathcal{M}$, which is a representation of Ada.</li>
<li>$Clara^\mathcal{M}$, which is a representation of Clara.</li>
<li>$\mathsf{Sister}^\mathcal{M}$, which is a set of pairs $\langle
object_1,object_2\rangle$ where $object_1$ represents the sister of $object_2$.</li>
</ul>
<p>Given this reading, we should set:</p>
<p>$$\nu(\mathsf{Sister}(Ada^\mathcal{M},Clara^\mathcal{M}))=1\Leftrightarrow
\langle Ada^\mathcal{M},Clara^\mathcal{M}\rangle\in\mathsf{Sister}^\mathcal{M}$$</p>
<p>That is, in our model, the formula which says that Ada and Clara are sisters
should be true just in case the pair is a member of the set of things that
represent sisters.</p>
<p>What if variables are involved? Well, then we need assignments and our
truth-value becomes relative to an assignment. So, for example, we&rsquo;d have
$$\nu_\alpha(\mathsf{Blue}(x))=1\Leftrightarrow \alpha(x)\in\mathsf{Blue}^\mathcal{M}$$</p>
<p>So, in general, then, the definition should be:</p>
<p>$$\nu_\alpha(P(t_1,\dots,t_n))=1\Leftrightarrow \langle
(t_1)^\mathcal{M}_\alpha,\dots,(t_n)^\mathcal{M}_\alpha\rangle\in P^\mathcal{M}$$</p>
<p>At this point it might be important to mention that in a model, we can represent
things in different ways. Of course, we should also allow models where Ada and
Clara aren&rsquo;t sisters, even if in reality they are.</p>
<p>An important exception to this is the identity predicate $=$ around. We are not allowed to freely re-interpret this predicate, it always stands for identity. That means that it&rsquo;s subject to a special clause, which is:</p>
<p>$$\nu_\alpha(t_1=t_2)=1\Leftrightarrow t_1^\mathcal{M}=t_2^\mathcal{M}$$</p>
<p>Now, when it comes to the connectives $\neg,\land,\lor,\to,\dots$, we
can fall back to the usual 


<a href="https://logicalmethods.ai/textbook/boolean//#truth-functions"
   
   
   
   
   
   >
Boolean truth-functions </a>

:</p>
<p>$$\nu_\alpha(\neg A)=-\nu_\alpha(A)$$
$$\nu_\alpha(A\land B)=\nu_\alpha(A)\times \nu_\alpha(B)$$
$$\nu_\alpha(A\lor B)=\nu_\alpha(A)+\nu_\alpha(B)$$
$$\nu_\alpha(A\to B)=\nu_\alpha(A)\Rightarrow\nu_\alpha(B)$$</p>
<p>It gets interesting when it comes to the quantifiers. In addition to the Boolean
truth-functions , we&rsquo;ll need to find corresponding truth-functions
$f_\forall,f_\exists$ for the quantifiers $\forall,\exists$.</p>
<p>How does this work? Let&rsquo;s start with $\forall$ and take $\forall
x\mathsf{Blue}(x)$, for example. What we want is to say that $\forall
x\mathsf{Blue}(x)$ is true just in case all the things in our model are blue. To
formally represent this, let&rsquo;s introduce for each object $o\in\mathcal{D}$ an
ad-hoc name $\mathbf{o}$ into our language with the stipulation that
$$\mathbf{o}^\mathcal{M}=o.$$ This constant, then, allows us to consider the
truth-value sequence
$$\nu_\alpha(\mathsf{Blue}(\mathbf{o_1})),\nu_\alpha(\mathsf{Blue}(\mathbf{o_2})),\dots$$
for <em>all</em> the objects $o_1,o_2,\dots$ in the domain.</p>
<p>When do we want to say that $\forall x\mathsf{Blue}(x)$ is true? The answer
seems to be when the sequence above just is $$1,1,1,\dots.$$ In other words,
when $\nu_\alpha(\mathsf{Blue}(\mathbf{o}))=1$ for all objects $o\in\mathcal{D}$</p>
<p>Think about a product $$x\times y\times z\times\dots$$ where
$x,y,z\in\Set{0,1}$. This number is $1$ precisely when the sequence
$$x,y,z,\dots$$ is the sequence $$1,1,1,\dots.$$ This means we can give the
following truth-functional analysis of the quantifiers:
$$\nu_\alpha(\forall x\mathsf{Blue}(x))=\nu_\alpha(\mathsf{Blue}(\mathbf{o}_1))\times\nu_\alpha(\mathsf{Blue}(\mathbf{o}_2)\times\dots$$
where $o_1,o_2,\dots$ are all the objects in $\mathcal{D}$</p>
<p>We can write this in a more concise form using the mathematical notation for
&ldquo;long&rdquo; products:
$$\nu_\alpha(\forall
x\mathsf{Blue}(x))=\nu_\alpha(\mathsf{Blue}(\mathbf{o}_1))\times\nu_\alpha(\mathsf{Blue}(\mathbf{o}_2))\times\dots=\prod_{o\in\mathcal{D}}\nu_\alpha(\mathsf{Blue}(\mathbf{o}))$$</p>
<p>Similar reasoning works for $\exists$. In order for $\nu_\alpha(\exists x\mathsf{Blue}(x))=1$, we would want to have at least one $1$ in the sequence:</p>
<p>$$\nu_\alpha(\mathsf{Blue}(\mathbf{o}_1)),\nu_\alpha(\mathsf{Blue}(\mathbf{o}_2)),\dots$$</p>
<p>We can express this using the Boolean $+$ by saying that:</p>
<p>$$\nu_\alpha(\exists x\mathsf{Blue}(x))=\nu_\alpha(\mathsf{Blue}(\mathbf{o}_1))+\nu_\alpha(\mathsf{Blue}(\mathbf{o}_2)+\dots$$</p>
<p>Mathematically, we can write this:
$$\nu_\alpha(\exists x\mathsf{Blue}(x))=\nu_\alpha(\mathsf{Blue}(\mathbf{o}_1))+\nu_\alpha(\mathsf{Blue}(\mathbf{o}_2))+\dots=\sum_{o\in\mathcal{D}}\nu_\alpha(\mathsf{Blue}(\mathbf{o}))$$</p>
<p>The only thing left to do is to generalize this from the formulas $\forall
x\mathsf{Blue}(x),\exists x\mathsf{Blue}(x)$ to arbitrary formulas of the form
$\forall xA$ and $\exists xA$. For this, we just need a piece of notation: we
write $\forall xA(x)$ to indicate that $A$ contains the variable $x$ that we
quantify &ldquo;over&rdquo; and then write $A(\mathbf{o})$ for the result of replacing all
the occurrences of $x$ in $A$, which are not involved in another quantifier with
$\mathbf{o}$.</p>
<p>So, for example, if $\forall xA(x)$ is $$\forall x(\mathsf{Student}(x)\to
\mathsf{OlderThan}(x,18))$$ then $$A(x)=\mathsf{Student}(x)\to
\mathsf{OlderThan}(x,18))$$ and $$A(\mathbf{o})=\mathsf{Student}(\mathbf{o})\to
\mathsf{OlderThan}(\mathbf{o},18)).$$</p>
<p>Using this notation, we can finally give the full recursive clauses for
$\forall,\exists$:</p>
<p>$$\nu_\alpha(\forall xA(x))=\prod_{o\in\mathcal{D}}\nu_\alpha(A(\mathbf{o}))$$
$$\nu_\alpha(\exists xA(x))=\sum_{o\in\mathcal{D}}\nu_\alpha(A(\mathbf{o}))$$</p>
<p>This completes the rather long definition of a model for FOL, variable
assignments $\alpha$, of  and the associated valuation function $\nu$.</p>
<p>One way of looking at the <strong>aim of knowledge representation in FOL</strong> is to
describe an adequate model of the way we know/think the world is like using
FOL-formulas.</p>
<p>At this stage, we can give a definition of valid inference in FOL. We simply use
the idea from 


<a href="https://logicalmethods.ai/textbook/valid-inference//#examples"
   
   
   
   
   
   > Chapter
2. Valid inference </a>

 of modeling deductively valid inference
as truth-preservation from premises to conclusion in all models:</p>
<p>$$P_1,P_2,\dots \vDash C\Leftrightarrow \text{ for all
}\mathcal{M},\nu,\alpha,\text{ if
}\nu_\alpha(P_1)=1,\nu_\alpha(P_2)=1,\dots\text{, then }\nu_\alpha(C)=1.$$</p>
<p>This definition gives rise to a series of <strong>FOL laws</strong>. The following
<strong>quantifier laws</strong> are especially important:</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left">   </th>
          <th style="text-align: left"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">Duality of $\exists/\forall$</td>
          <td style="text-align: left"></td>
          <td style="text-align: left">$\exists xA\vDash \neg\forall x\neg A\qquad \neg\forall x\neg A\vDash \exists xA$</td>
      </tr>
      <tr>
          <td style="text-align: left">Duality of $\forall/\exists$</td>
          <td style="text-align: left"></td>
          <td style="text-align: left">$\forall xA\vDash \neg\exists x\neg A\qquad \neg\exists x\neg A\vDash \forall xA$</td>
      </tr>
      <tr>
          <td style="text-align: left"> </td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">Distribution $\forall/\land$</td>
          <td style="text-align: left"></td>
          <td style="text-align: left">$\forall x(A\land B)\vDash \forall xA\land \forall xB\qquad \forall x A\land \forall x B\vDash \forall x(A\land B)$</td>
      </tr>
      <tr>
          <td style="text-align: left">Distribution $\exists/\lor$</td>
          <td style="text-align: left"></td>
          <td style="text-align: left">$\exists x(A\lor B)\vDash \exists xA\lor \exists xB\qquad \exists x A\lor \exists x B\vDash \exists x(A\lor B)$</td>
      </tr>
      <tr>
          <td style="text-align: left"> </td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">Commutativity $\forall$</td>
          <td style="text-align: left"></td>
          <td style="text-align: left">$\forall x\forall yA\vDash \forall y\forall xA$</td>
      </tr>
      <tr>
          <td style="text-align: left">Commutativity $\exists$</td>
          <td style="text-align: left"></td>
          <td style="text-align: left">$\exists x\exists yA\vDash \exists y\exists xA$</td>
      </tr>
      <tr>
          <td style="text-align: left"> </td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
  </tbody>
</table>
<p>There are more quantifier laws, some of which you&rsquo;ll explore in the exercises.</p>
<h2 id="limitations">Limitations<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>While <a href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem"
  target="_blank">Gödel&rsquo;s original completeness theorem</a> showed that the Hilbert system for FOL is sound and complete, i.e. we have $$P_1,P_2,\dots\vDash C\Leftrightarrow P_1,P_2,\dots\vdash C$$ in FOL, there are two important limiting results about FOL with severe implications for AI.</p>
<p>We&rsquo;ve already mentioned these results in 


<a href="https://logicalmethods.ai/textbook/logic-and-ai//#as-a-foundation"
   
   
   
   
   
   > Chapter 1. Logic and AI </a>

:</p>
<ul>
<li>
<p>Gödel&rsquo;s <a href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems"
  target="_blank"><strong>(first) incompleteness
theorem</strong></a>,
which implies that for every logical system that is free of internal
contradictions and models basic mathematical reasoning, there is a mathematical
statement that is <em>undecidable</em> in the system, meaning that the statement can
neither be proven nor refuted in that system.</p>
</li>
<li>
<p>Turing&rsquo;s <a href="https://en.wikipedia.org/wiki/Decidability_%28logic%29"
  target="_blank"><strong>undecidability
theorem</strong></a>, which states
that validity in the standard system of predicate logic is <em>(algorithmically)
undecidable</em>, meaning that  there is no algorithm and there can never be an
algorithm that correctly determines in finitely many steps whether any given
inference in the system of predicate logic is valid.</p>
<p>This result seems to show directly that we cannot &ldquo;fully automate&rdquo; validity
checking using AI and maintain absolute reliability.</p>
</li>
</ul>
<p>These two results are explicitly <strong>about FOL</strong>. Gödel&rsquo;s incompleteness theorem
is concerns possible extensions of FOL axiomatizations of arithmetic, the theory
of natural numbers.</p>
<p>While the proof of the incompleteness theorem is out of scope for this book, the
result involves an impressive illustration of the expressive power of FOL:</p>
<ul>
<li>
<p>The standard theory of the natural numbers, which is the basis for <em>all</em>
modern number theory is <a href="https://en.wikipedia.org/wiki/Peano_axioms"
  target="_blank">Peano arithmetic</a> is a FOL-theory.</p>
</li>
<li>
<p>The proof of Gödel&rsquo;s result involves showing that FOL can develop a theory of
syntax <em>in general</em>. That is, the theory of formal languages we&rsquo;ve covered in 


<a href="https://logicalmethods.ai/textbook/formal-languages/"
   
   
   
   
   
   > Chapter 3. Formal languages </a>

 is itself a FOL-theory.</p>
</li>
</ul>
<p>On the other hand, Gödel&rsquo;s result shows that we <em>cannot</em>, not matter how hard we
try, develop an expert system involving a consistent knowledge bank that
contains <em>all</em> mathematical truths. In other words, we cannot develop a
consistent, mathematically omniscient AI.</p>
<p>Turing&rsquo;s result is also about FOL. It concerns the perhaps surprising fact that
while our best proof systems for FOL are sound and complete, there&rsquo;s no
algorithm for determining whether any given inference is valid or not. This
makes inference in FOL a <em>hard</em> topic, which we&rsquo;ll look into in the next
chapter.</p>
<p>Just like with Gödel&rsquo;s theorem, the proof of Turing&rsquo;s theorem is out of scope.
But what we&rsquo;ll be able to appreciate are the pitfalls that naive inference
algorithms in FOL can fall into, such as <a href="https://en.wikipedia.org/wiki/Infinite_loop"
  target="_blank">infinite
loops</a> in proof search, for
example.</p>
 <p><em>Last edited: </em>09/10/2024</p>
</div>


<ul class="navbar-nav flex-row justify-content-between mt-auto">
  
  <li class="nav-item">
    <a href="/textbook/proofs/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-left"></i>
    </a>
    
  </li>
  <li class="nav-item">
    <button class="btn btn-back-to-top">
    <i class="bi bi-chevron-double-up"></i>
  </button>
  </li>
  <li class="nav-item">
    
    <a href="/textbook/fol-inference/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-right"></i>
    </a>
    
  </li>
</ul>

    </main>
    <footer class="align-self-center d-flex flex-column mt-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="footer-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="/about" aria-label="copyright-link">&copy; 2024 jkorbmacher et al. </a>
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link fs-6" href="https://github.com/jkorb/logicalmethods.ai" target="_blank"><i class="bi bi-github"></i></a>
      </li>
    </ul>
  </div>
</nav>
 
      <script src="https://logicalmethods.ai/js/helpers.js"></script>
      <script src="https://logicalmethods.ai/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
      
      
    </footer>
  </body>
</html>
