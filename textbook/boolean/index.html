<!doctype html>
<html lang="en" data-bs-theme="light">
  <head>
    <meta charset="utf-8"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <title>logicalmethods.ai &ndash; Boolean algebra </title>
    <link rel="icon" type="image/x-icon" href="https://logicalmethods.ai/favicon.ico"></link>
    <link href="https://logicalmethods.ai/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/icons/font/bootstrap-icons.min.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/layout.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/syntax_hl.css"></link>
    <link href="https://logicalmethods.ai/css/textbook.css" rel="stylesheet"></link>
    <style>
      
    :root {
      --chapter: "4";
    }

    </style>
    
      <link rel="stylesheet" href="https://logicalmethods.ai/katex/katex.min.css">
<script defer src="https://logicalmethods.ai/katex/katex.min.js"></script>
<script defer src="https://logicalmethods.ai/katex/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},     
        {left: '\\[', right: '\\]', display: true},   
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>


    
  </head>
  <body class="bg-black d-flex flex-column m-0 p-0">
    <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvas-nav" aria-labelledby="offcanvas-navLabel" data-bs-theme="dark" data-bs-backdrop="false">
  <div class="offcanvas-header">
    <div class="h5 offcanvas-title" id="offcanvas-navLabel">
      Browse course
    </div>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  
  <div class="offcanvas-body">
    <ul class="navbar-nav">
      
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/about/"><i class="bi-file-person-fill"></i> &nbsp;&nbsp; About</a>
          </div>
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link fw-bold active" href="/textbook/"><i class="bi bi-book"></i> &nbsp;&nbsp; Textbook</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/textbook/"
            id="navbarSectiontxt-home" data-bs-toggle="collapse"
            data-bs-target="#collapsetxt-home"  
            aria-expanded="true"
            aria-controls="collapsetxt-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse show" id="collapsetxt-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                fw-bold active
                
                "
                href="/textbook/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/conditionals/"
              >6. 
                <i class="bi bi-unlock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/proofs/"
              >7. 
                <i class="bi bi-unlock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >8. 
                <i class="bi bi-lock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >9. 
                <i class="bi bi-lock-fill"></i>
                 FOL Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logic-based learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/slides/"><i class="bi bi-rocket-takeoff-fill"></i> &nbsp;&nbsp; Slides</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/slides/"
            id="navbarSectionsli-home" data-bs-toggle="collapse"
            data-bs-target="#collapsesli-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapsesli-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapsesli-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/teaser/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/conditionals/"
              >6. 
                <i class="bi bi-unlock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >7. 
                <i class="bi bi-lock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >8. 
                <i class="bi bi-lock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >9. 
                <i class="bi bi-lock-fill"></i>
                 FOL inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/exercises/"><i class="bi-gear-fill"></i> &nbsp;&nbsp; Exercises</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/exercises/"
            id="navbarSectionexe-home" data-bs-toggle="collapse"
            data-bs-target="#collapseexe-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseexe-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseexe-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/preamble/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/conditionals/"
              >6. 
                <i class="bi bi-unlock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >7. 
                <i class="bi bi-lock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >8. 
                <i class="bi bi-lock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >9. 
                <i class="bi bi-lock-fill"></i>
                 FOL inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/assignments/"><i class="bi bi-house-gear-fill"></i> &nbsp;&nbsp; Assignments</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/assignments/"
            id="navbarSectionass-home" data-bs-toggle="collapse"
            data-bs-target="#collapseass-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseass-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseass-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/assignments/assignment_1/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Assignment 1 (due 09/19/2025)
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/assignments/assignment_2/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Assignment 2 (due 03/10/2025)
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      
      
      
    </ul>
  </div>
</div>



    <header class="align-self-center d-flex flex-column m-0 mb-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="header-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="https://logicalmethods.ai/">
    <img src="https://logicalmethods.ai/img/nav_id.png" class="inert-img img-fluid m-2" draggable="false" width="400px">
    </a>
    <button class="navbar-toggler border-0" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas-nav" aria-controls="offcanvas-nav">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
</nav>

      
      
    </header>
    
    <main class="align-self-center d-flex flex-column flex-fill bg-white m-md-1 p-0" data-bs-theme="light">
      <ul class="navbar-nav flex-row justify-content-center mt-2">

  <li class="nav-item">
    <a href="/textbook/" class="btn" style="font-size: 20pt;" tabindex="-1" role="button" aria-disabled="false">
      <i class="bi bi-house-up"></i>
    </a>
  </li>
</ul>
<div class="container chapter">
  <p>By: <em>Johannes Korbmacher</em></p>
  <div class="m-4"><h1 id="boolean-algebra">Boolean algebra<button class="btn btn-back-to-top">
    
  </button>
</h1>
<hr>

<p>
<img src="https://logicalmethods.ai/textbook/boolean/img/low_level.png" class="rounded  float-end inert-img img-fluid mx-3"  width="300px"  alt="" >

Boolean algebra—the logic of 0&rsquo;s, 1&rsquo;s, not, and, or, …—is the ultimate logical
foundation of modern computers, and by extension <em>all</em> AI systems. The study of
Boolean logic has its roots in the work of <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/George_Boole"
  target="_blank">George
Boole</a> from the mid 19th century.
But it wasn&rsquo;t until AI-pioneer <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Claude_Shannon"
  target="_blank">Claude
Shannon</a> connected the theory to
the basic workings of electronic circuits that the importance of Boolean algebra
for the development of information technologies became apparent. While Shannon
was investigating <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Relay"
  target="_blank">relays</a>—essentially
electronically operated switches—and not
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Semiconductor"
  target="_blank">semiconductors</a>, which are the
actual technology used to implement computers today, the fundamental principles
are the same. Boolean algebra is the logic of low-level computing, and the way
that computers add, subtract, multiply, etc. are ultimately grounded in Boolean
logic.</p>
<p>But the importance of Boolean algebra to AI is not restricted to the low level.
Propositional reasoning on all levels follows the laws of Boolean algebra.
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Conditional_%28computer_programming%29"
  target="_blank">Conditionals</a>
in most programming languages, such as C, Python, or Java, rely on Boolean
connectives:

<img src="https://logicalmethods.ai/textbook/boolean/img/python_snippet.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="400px"  alt="" >

To write good conditionals and understand code that others have written, you
need a solid understanding of Boolean logic.</p>
<p>Even on the highest level, deductive reasoning with propositional information stored in
<abbr title="knowledge bases"><a  class="link-underline-opacity-0 link-body-emphasis"> KBs</a></abbr> follows the laws of Boolean
algebra:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/mp_kb.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="400px"  alt="" >

<p>In short, the importance of Boolean logic for AI can hardly be overstated.</p>
<p>At the end of this chapter, you&rsquo;ll be able to:</p>
<ul>
<li>
<p>explain the basic principles of Boolean algebra</p>
</li>
<li>
<p>implement the Boolean truth-functions using simple circuits</p>
</li>
<li>
<p>derive logical laws from the Boolean laws</p>
</li>
<li>
<p>build and apply adders from Boolean circuits</p>
</li>
<li>
<p>test propositional inferences for deductive validity using Boolean models</p>
</li>
</ul>
<h2 id="boolean-truth-values">Boolean truth-values<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>Boolean algebra is the logic of the proverbial 0&rsquo;s and 1&rsquo;s. That is, the Boolean
truth-values are:</p>
<div class="text-center my-4 excalifont">{0, 1}</div>
<p>These values have many different interpretations depending on the reasoning
context we&rsquo;re in: on/off, high/low, true/false, ….</p>
<p>In logic, the true/false interpretation is the most common. If we&rsquo;re dealing
with a propositional language that has a propositional letter
<span class="excalifont">SUN</span> to express that the sun is shining,
assigning it the value 1 means that the sun is indeed shining, while assigning
<span class="excalifont">SUN</span> the value 0 means that it is not.</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/sun_boolean.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="400px"  alt="" >

<p>In Boolean logic, there is no <em>third</em> truth-value for facts that are undecided,
unknown, indeterminate. From a logical perspective, this is a <strong>modelling
assumption</strong>, which means that Boolean logic is only applicable in situations,
where things are clear-cut, true or false. But luckily, there are many such
situations, ranging from the behavior of semiconductors to simple facts of
everyday life.</p>
<h2 id="truth-functions">Truth-functions<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>The basic operations of Boolean algebra are the so-called <em>truth-functions</em>.
These are <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Function_%28mathematics%29"
  target="_blank">functions</a> in
the mathematical sense, which take one or more Boolean truth-values as input and
return exactly one Boolean truth-value as output.</p>
<p>For now, we&rsquo;ll restrict ourselves to the basic functions <span class="excalifont"><span class="Boolean">NOT</span></span>, <span class="excalifont"><span class="Boolean">AND</span></span>, and
<span class="excalifont"><span class="Boolean">OR</span></span>. These are not the most fundamental truth-functions in any sense of the
word, but <em>are</em> the most commonly used truth-functions in logical theory. In
computer science, instead, especially when we&rsquo;re thinking about basic
semiconductor circuits <span class="excalifont"><span class="Boolean">XOR</span></span> and especially when we&rsquo;re
thinking about basic semiconductor circuits <span class="excalifont"><span class="Boolean">NAND</span></span> are more commonly used as
basic functions.</p>
<p>The truth-functions are given by the following functional tables, where the
first input is in the first column and the second input in the first row. In the
case of the binary functions—the ones with two inputs—the output is read-off by
intersecting the two input columns:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/function_tables.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>So, for example, <span class="excalifont"><span class="Boolean">NOT</span> 0 = 1</span> and
<span class="excalifont">1 <span class="Boolean">OR</span> 0 = 1</span>.</p>
<p>The truth-functions <span class="excalifont"><span class="Boolean">NOT</span></span>, <span class="excalifont"><span class="Boolean">AND</span></span>, and <span class="excalifont"><span class="Boolean">OR</span></span> are sufficient to express <em>any</em>
truth-function whatsoever. This mathematical fact is known as the joint
<strong>truth-functional completeness</strong> of these operators, and we&rsquo;ll investigate it
in the exercises. <span class="excalifont"><span class="Boolean">NOT</span></span>, <span class="excalifont"><span class="Boolean">AND</span></span>, and <span class="excalifont"><span class="Boolean">OR</span></span> are not the only collection of
truth-functions with this property, not even the smallest one. But especially
in logical contexts, they are the most commonly used ones, since using these
truth-functions, we can easily describe many different important concepts and
algorithms with relative ease.</p>
<p>To get a better understanding of how these truth-functions work, we&rsquo;ll look at
an implementation using
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Relay"
  target="_blank">relays</a>—essentially tracing some of
Shannon&rsquo;s ideas. A relay is, essentially, an electronically operated switch. For
our purposes, we&rsquo;ll work with the following two kinds of relays:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/relays.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>Both relays have two inputs and one output. One input leads to an electromagnet,
which if it receives power exerts a magnetic force on the switch connected to
the other input and flips it. In the 
<span class="excalifont ">default
  "off"</span>
 relay, this closes the circuit and the output receives
power in case the input does. With the 
<span class="excalifont ">default
  "on"</span>
 relay, it&rsquo;s the other way around: if the electromagnet
receives power, the output gets disconnected from the input, breaking the
circuit.</p>
<p>So, if the <span class="excalifont">default  &ldquo;on&rdquo;</span> circuit receives
constant power to the right circuit, this is how turning the power to the magnet
off and on affects the behavior of the circuit:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/relay_behavior.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>The <span class="excalifont">default  &ldquo;on&rdquo;</span> relay, of course, behaves
dually.</p>
<p>We can use these two relays to implement our three Boolean truth-functions. For
this, we assume that following set-up:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/implementation_setup.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>We have:</p>
<ul>
<li>
<p>a constant source of power <span class="excalifont">POWER</span></p>
</li>
<li>
<p>two switchable inputs, <span class="excalifont">X</span> and <span class="excalifont">Y</span></p>
</li>
<li>
<p>a single output, which is connected to an indicator lamp</p>
</li>
</ul>
<p>We interpret <span class="excalifont">X</span> being <span class="excalifont">off</span> as the first input being <span class="excalifont">0</span> and <span class="excalifont">X</span> being <span class="excalifont">on</span> as
the first input being <span class="excalifont">1</span>, and analogously for <span class="excalifont">Y</span> and the second input. The
lamp represents the output in the same way: if it is <span class="excalifont">off</span>, the output is <span class="excalifont">0</span>,
if it is <span class="excalifont">on</span> the output is <span class="excalifont">1</span>. So, the set-up is depicted in the configuration
for the first and second input both being <span class="excalifont">0</span>. Since we haven&rsquo;t implemented
anything yet, the output is also <span class="excalifont">0</span>.</p>
<p>We can implement the <span class="excalifont"><span class="Boolean">NOT</span></span> function with a single <span class="excalifont">default &ldquo;on&rdquo;</span> relay:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/negation_impl.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>Depicted are both states of the circuit: if the first input is <span class="excalifont">0</span> (<span class="excalifont">X</span> is
<span class="excalifont">off</span>), the output is <span class="excalifont">1</span> (the lamp is <span class="excalifont">on</span>); and if the first input is <span class="excalifont">1</span> (<span class="excalifont">X</span>
is <span class="excalifont">on</span>), the output is <span class="excalifont">0</span> (the lamp is <span class="excalifont">off</span>). The second input doesn&rsquo;t
matter, of course.</p>
<p>We can implement <span class="excalifont"><span class="Boolean">AND</span></span> using the other kind of relay as follows:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/conjunction_impl.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>There are four possible states of the circuits, but as you can see: only if both
inputs are <span class="excalifont">1</span> the output is
<span class="excalifont">1</span>. In all other configurations, the output is
<span class="excalifont">0</span>—just like the
<span class="excalifont"><span class="Boolean">AND</span></span> function, requires.</p>
<p>Implementing the <span class="excalifont"><span class="Boolean">OR</span></span> function using the relays
is one of the exercises. If you want to try more, you can try the amazing
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://nandgame.com/"
  target="_blank">nandgame</a>, which allows you to implement an entire
computer &ldquo;by hand&rdquo;.</p>
<h2 id="the-laws-of-boolean-algebra">The Laws of Boolean algebra<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>
<img src="https://logicalmethods.ai/textbook/boolean/img/laws_of_logic.png" class="rounded  float-end inert-img img-fluid mx-3"  width="300px"  alt="" >

The behavior of the Boolean truth-functions is
governed by a series of <strong>algebraic laws</strong>, that is <em>identities</em> describing
their interaction. These identities are formulated using <strong>variables</strong> <span class="excalifont">X,Y,…</span>,
which can assume arbitrary values from among the set <span class="excalifont">{0, 1}</span>. Take, for
example, the <em>Boolean equation</em>:</p>
<div class="text-center my-4">
<code class="customCode">(X <span class="Boolean">AND</span> Y) = (Y <span class="Boolean">AND</span> X)</code>
</div>
<p>This equation says that for any pair of values <span class="excalifont">X,Y</span> from 
<span class="excalifont ">{0,
  1}</span>
, the result of applying <span class="excalifont"><span class="Boolean">AND</span></span> with <span class="excalifont">X</span> as the first
input and <span class="excalifont">Y</span> as the second is the same as applying <span class="excalifont"><span class="Boolean">AND</span></span> with <span class="excalifont">Y</span> as the
first input and <span class="excalifont">X</span> as the second.</p>
<p>You can verify this law by inspecting the function table for <span class="excalifont"><span class="Boolean">AND</span></span> and
going through all possible values for <span class="excalifont">X</span> and <span class="excalifont">Y</span>. Here are the corresponding
calculations:</p>
<div class="text-center my-4">
<p><code class="customCode">(0 <span class="Boolean">AND</span> 0)   =   (0 <span class="Boolean">AND</span> 0)</code></p>
<p><code class="customCode">(0 <span class="Boolean">AND</span> 1) = 0 = (1 <span class="Boolean">AND</span> 0)</code></p>
<p><code class="customCode">(1 <span class="Boolean">AND</span> 0) = 0 = (0 <span class="Boolean">AND</span> 1)</code></p>
<p><code class="customCode">(1 <span class="Boolean">AND</span> 1)   =   (1 <span class="Boolean">AND</span> 1)</code></p>
</div>
<p>Only the second and third line are &ldquo;interesting&rdquo; calculations, the first and
last are &ldquo;trivial&rdquo;.</p>
<p>This law is called the law of <span class="excalifont">Commutativity</span> for
<span class="excalifont"><span class="Boolean">AND</span></span>, which states that for
<span class="excalifont"><span class="Boolean">AND</span></span>, the order of its inputs doesn&rsquo;t matter.
Many laws of Boolean algebra have such names.</p>
<p>Here are the most important laws and their corresponding names:</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code class="customCode">(X <span class="Boolean">OR</span> (Y <span class="Boolean">OR</span> Z)) = ((X <span class="Boolean">OR</span> Y) <span class="Boolean">OR</span> Z)</code><br><code class="customCode">(X <span class="Boolean">AND</span> (Y <span class="Boolean">AND</span> Z)) = ((X <span class="Boolean">AND</span> Y) <span class="Boolean">AND</span> Z)</code></td>
          <td>   </td>
          <td><span class="excalifont">(&ldquo;Associativity&rdquo;)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td><code class="customCode">(X <span class="Boolean">OR</span> Y) = (Y <span class="Boolean">OR</span> X)</code><br><code class="customCode">(X <span class="Boolean">AND</span> Y) = (Y <span class="Boolean">AND</span> X)</code></td>
          <td></td>
          <td><span class="excalifont">(&ldquo;Commutativity&rdquo;)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td><code class="customCode">(X <span class="Boolean">OR</span> (X <span class="Boolean">AND</span> Y) = X </code><br><code class="customCode">(X <span class="Boolean">AND</span> (X <span class="Boolean">OR</span> Y) = X </code></td>
          <td></td>
          <td><span class="excalifont">(&ldquo;Absorption&rdquo;)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td><code class="customCode">(X <span class="Boolean">OR</span> (Y <span class="Boolean">AND</span> Z)) = ((X <span class="Boolean">OR</span> Y) <span class="Boolean">AND</span> (X <span class="Boolean">OR</span> Z) </code> <br><code class="customCode">(X <span class="Boolean">AND</span> (Y <span class="Boolean">OR</span> Z)) = ((X <span class="Boolean">AND</span> Y) <span class="Boolean">OR</span> (X <span class="Boolean">AND</span> Z) </code></td>
          <td></td>
          <td><span class="excalifont">(&ldquo;Distributivity&rdquo;)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td><code class="customCode">(X <span class="Boolean">OR</span> <span class="Boolean">NOT</span> X) = 1 </code> <br><code class="customCode">(X <span class="Boolean">AND</span> <span class="Boolean">NOT</span> X) = 0 </code></td>
          <td></td>
          <td><span class="excalifont">(&ldquo;Complementation&rdquo;)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td><code class="customCode">(X <span class="Boolean">OR</span> 0) = X </code> <br> <code class="customCode">(X <span class="Boolean">AND</span> 1) = X </code></td>
          <td></td>
          <td><span class="excalifont">(&ldquo;Identity&rdquo;)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td><code class="customCode">(X <span class="Boolean">AND</span> 0) = 0 </code> <br><code class="customCode">(X <span class="Boolean">OR</span> 1) = 1 </code></td>
          <td></td>
          <td><span class="excalifont">(&ldquo;Domination&rdquo;)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>You can (and should!) verify all these laws, just like we did for
<span class="excalifont">Commutativity</span>. Don&rsquo;t worry, you don&rsquo;t need to
memorize all of these laws. But at the same time, knowing them can be incredibly
helpful in showing facts about Boolean algebras.</p>
<p>In particular, you can use these laws to derive other laws in an algebraic way,
that is by manipulating equations. For example, you can derive the following
important family of laws known as the <strong>de Morgan laws</strong>:</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code class="customCode"><span class="Boolean">NOT</span> (X <span class="Boolean">OR</span> Y) = (<span class="Boolean">NOT</span> X <span class="Boolean">AND</span> <span class="Boolean">NOT</span> Y)</code><br><code class="customCode"><span class="Boolean">NOT</span> (X <span class="Boolean">AND</span> Y) = (<span class="Boolean">NOT</span> X <span class="Boolean">OR</span> <span class="Boolean">NOT</span> Y) </code></td>
          <td>   </td>
          <td><span class="excalifont">(&ldquo;De Morgan Identities&rdquo;)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td><code class="customCode"><span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X = X </code></td>
          <td></td>
          <td><span class="excalifont">(&ldquo;Double Negation&rdquo;)</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>Let&rsquo;s look at how to derive 
<span class="excalifont ">("Double
  Negation")</span>
:</p>
<ol>
<li>
<p>We start with</p>
<div class="customBlock text-center my-4"><code class="customCode">
<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X = ((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> 1),
</code></div>
<p>which we know by <span class="excalifont">&ldquo;Identity&rdquo;</span>.</p>
</li>
<li>
<p>We then apply the fact that <code class="customCode">X <span class="Boolean">OR</span> <span class="Boolean">NOT</span> X = 1</code>, that is <span class="excalifont">&ldquo;Complementation&rdquo;</span>, which gives us that</p>
<div class="customBlock text-center my-4"><code class="customCode">
<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X = ((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (X <span class="Boolean">OR</span> <span class="Boolean">NOT</span> X)),
</code></div>
</li>
<li>
<p>By <span class="excalifont">&ldquo;Distributivity&rdquo;</span>, we have</p>
<div class="customBlock text-center my-4"><code class="customCode">
((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (X <span class="Boolean">OR</span> <span class="Boolean">NOT</span> X))= ((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> X) <span class="Boolean">OR</span> ((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> <span class="Boolean">NOT</span> X),
</code></div>
<p>so we can conclude that</p>
<div class="customBlock text-center my-4"><code class="customCode">
<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X = ((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> X) <span class="Boolean">OR</span> ((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> <span class="Boolean">NOT</span> X).
</code></div>
</li>
<li>
<p>Now, notice that  <code class="customCode">((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> <span class="Boolean">NOT</span> X) = 0</code> by <span class="excalifont">&ldquo;Complementation&rdquo;</span>. So step 3. simplifies to:</p>
<div class="customBlock text-center my-4"><code class="customCode">
 <span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X = ((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> X) <span class="Boolean">OR</span> 0.
</code></div>
<p>which by <span class="excalifont">&ldquo;Identity&rdquo;</span> simplifies further
down to:</p>
<div class="customBlock text-center my-4"><code class="customCode">
 <span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X = (<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> X.
</code></div>
</li>
<li>
<p>Going a bit faster, we can see by analogous reasoning that</p>
<div class="customBlock text-center my-4"><code class="customCode">
 X = X <span class="Boolean">AND</span> 1 = X <span class="Boolean">AND</span> ((<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">OR</span> <span class="Boolean">NOT</span> X),
</code></div>
<p>using <span class="excalifont">&ldquo;Identity&rdquo;</span> and <span class="excalifont">&ldquo;Complementation&rdquo;</span> like before.</p>
</li>
<li>
<p>Using <span class="excalifont">&ldquo;Distributivity&rdquo;</span>, this gives us</p>
<div class="customBlock text-center my-4"><code class="customCode">
 X = (X <span class="Boolean">AND</span> <span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">OR</span> (X <span class="Boolean">AND</span> <span class="Boolean">NOT</span> X).
</code></div>
</li>
<li>
<p>But since <code class="customCode">
<span class="excalifont ">(X <span class="Boolean">AND</span> <span class="Boolean">NOT</span> X) = 0</span>
</code>, we now get</p>
<div class="customBlock text-center my-4"><code class="customCode">
 X = (X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X))
</code></div>
<p>using <span class="excalifont">&ldquo;Identity&rdquo;</span> and <span class="excalifont">&ldquo;Complementation&rdquo;</span>.</p>
</li>
<li>
<p>But now we know that both:</p>
<div class="customBlock text-center my-4"><code class="customCode">
<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X = (<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> X
</code></div>
<div class="customBlock text-center my-4"><code class="customCode">
X = (X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X)), 
</code></div>
</li>
</ol>
<p>where the latter is just <code class="customCode">X = (<span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X) <span class="Boolean">AND</span>
X,</code> using <span class="excalifont">&ldquo;Commutativity&rdquo;</span> to reorder. So, we can conclude that:</p>
   <div class="customBlock text-center my-4"><code class="customCode">
    <span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X = X
   </code></div>
<p>This derivation may seem a bit tedious—especially since we can prove the fact
that <span class="excalifont"><span class="Boolean">NOT</span> <span class="Boolean">NOT</span> X = X</span> fact by simply inspecting
the function tables: <code class="customCode"><span class="Boolean">NOT</span> <span class="Boolean">NOT</span> 1 = 1<span class="excalifont"> and </span><span class="Boolean">NOT</span> <span class="Boolean">NOT</span> 0 = 0</code>.</p>
<p>But there are also questions where the laws are much more efficient at giving
you the answer than inspecting the tables. Take for example the Boolean
expression:</p>
  <div class="customBlock text-center my-4"><code class="customCode">
  X <span class="Boolean">AND</span> ((Y <span class="Boolean">AND</span> Z) <span class="Boolean">OR</span> <span class="Boolean">NOT</span> (Y <span class="Boolean">AND</span> Z))
  </code></div>
<p>It turns out that this expression reduces to simply
<span class="excalifont">X</span>. To see this by truth-table inspection, we
need to go through <span class="excalifont">2³ = 8</span> different
combinations of truth-values for <span class="excalifont">X, Y, Z</span> and
for each combination, we need to calculate <span class="excalifont">5</span> different operations. That&rsquo;s a
lot of calculations.</p>
<p>Using the laws of Boolean algebra, however, we can recognize that</p>
  <div class="customBlock text-center my-4"><code class="customCode">
  ((Y <span class="Boolean">AND</span> Z) <span class="Boolean">OR</span> <span class="Boolean">NOT</span> (Y <span class="Boolean">AND</span> Z))
  </code></div>
<p>is of the form</p>
  <div class="customBlock text-center my-4"><code class="customCode">
  [something] <span class="Boolean">OR</span> <span class="Boolean">NOT</span> [something], 
  </code></div>
<p>where <code class="customCode">[something] = (Y <span class="Boolean">AND</span> Z)</code>. So, by
<span class="excalifont">&ldquo;Complementation&rdquo;</span>, we can reduce</p>
  <div class="customBlock text-center my-4"><code class="customCode">
  X <span class="Boolean">AND</span> ((Y
  <span class="Boolean">AND</span> Z) <span class="Boolean">OR</span> <span class="Boolean">NOT</span> (Y
  <span class="Boolean">AND</span> Z))
  </code></div>
down to 
  <div class="customBlock text-center my-4"><code class="customCode">
  X <span class="Boolean">AND</span> 1, 
  </code></div>
<p>which by <span class="excalifont">&ldquo;Identity&rdquo;</span> is just <code class="customCode">X</code>.</p>
<p>
<img src="https://logicalmethods.ai/textbook/boolean/img/ai_tools.png" class="rounded  float-end inert-img img-fluid mx-3"  width="100px"  alt="" >

The derivation also illustrates an important point: the above laws of Boolean
algebra allow us to derive further laws that don&rsquo;t look like they&rsquo;re covered by
the initial list. In fact, we can derive <em>all</em> valid identities of Boolean
algebra from these laws. The list of laws is <strong>complete</strong> in this sense.
Having a complete list of laws for a subject matter is an incredibly feat: <em>all
there is to know about Boolean algebras is encoded in these laws</em>. And as the
example of <code class="customCode">X <span class="Boolean">AND</span> ((Y <span class="Boolean">AND</span> Z) <span class="Boolean">OR</span> <span class="Boolean">NOT</span> (Y <span class="Boolean">AND</span> Z))</code> shows, this
can be a handy tool in the toolbox of any AI researcher.</p>
<p>On a more historical note, the set of laws we&rsquo;ve discussed are originally due to
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Alfred_North_Whitehead"
  target="_blank">Alfred North Whitehead</a>.
But it is not the only collection of complete laws and certainly not the
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Minimal_axioms_for_Boolean_algebra"
  target="_blank">minimal one</a>.
It turns out that the following single law is enough to derive all the other
laws of Boolean algebra (expressed using  only
<span class="excalifont"><span class="Boolean">NOT</span></span> and <span class="excalifont"><span class="Boolean">OR</span></span>):</p>
<div class="customBlock text-center my-4"><code class="customCode">
<span class="Boolean">NOT</span> (<span class="Boolean">NOT</span> (<span class="Boolean">NOT</span> (X <span class="Boolean">OR</span> Y) <span class="Boolean">OR</span> Z) <span class="Boolean">OR</span> <span class="Boolean">NOT</span> (X <span class="Boolean">OR</span> <span class="Boolean">NOT</span> (<span class="Boolean">NOT</span> Z <span class="Boolean">OR</span> <span class="Boolean">NOT</span> (Z <span class="Boolean">OR</span> U)))) = Z
</code></div>
<p>But that&rsquo;s a story for another day.</p>
<h2 id="adders">Adders<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>To illustrate the usefulness of Boolean algebra, let&rsquo;s look an important
application: the implementation of addition via
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Adder_%28electronics%29"
  target="_blank">adders</a>.</p>
<p>
<img src="https://logicalmethods.ai/textbook/boolean/img/ai_calculating.png" class="rounded  float-end inert-img img-fluid mx-3"  width="250px"  alt="" >

An <strong>adder</strong> is a circuit that performs addition on numbers. We can implement
adders using Boolean truth-functions, but first, we need to translate the
numbers into something a Boolean function can understand. We need to talk about
<strong>binary numbers</strong>.</p>
<p>The fundamental idea of <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Binary_number"
  target="_blank">binary
numbers</a> is that we can represent
any natural number as a sequence of <span class="excalifont">0</span>&rsquo;s and <span class="excalifont">1</span>&rsquo;s. Here&rsquo;s how this works. Take
the string <div class="text-center my-4 excalifont">1101,</div> for example. This string is the binary representation of
the number <span class="excalifont">13</span>. Here&rsquo;s how this works:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/binary_example.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>The <span class="excalifont">0</span>&rsquo;s and <span class="excalifont">1</span>&rsquo;s are also called
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Bit"
  target="_blank">bits</a>—short for binary digits—especially in
computer science contexts. For simplicity, we count the bits of a binary number
backwards from the end of the string (right-to-left rather than left-to-right).
You&rsquo;ll see in a second why. We also start counting at <span class="excalifont">0</span>, which might be
unusual at first, but is also common in computer science. So, the first bit of <span class="excalifont">1101</span>, for example, is what would normally be called &ldquo;the second digit from the end&rdquo;, i.e. <span class="excalifont">0</span>:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/bits_example.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="200px"  alt="" >

<p>To calculate the number represented by a string, you go through the digits one.
Let&rsquo;s call the <span class="excalifont">n</span>th bit <span class="excalifont">dₙ</span>. So, in our example, we have: <div class="text-center my-4 excalifont">d₀ = 1, d₁ = 0,
d₂ = 1, d₃ = 1</div></p>
<p>Then you multiply the <span class="excalifont">n-th</span> bit with the <span class="excalifont">n-th</span> power of <span class="excalifont">2</span>, that is, you
calculate: <div class="text-center my-4 excalifont">(dₙ x 2ⁿ)</div>
And then you sum up the results for all the digits:</p>
<div class="text-center my-4 excalifont">(d₀ x 2⁰) + (d₁ x 2¹) + (d₂ x 2²) + …</div>
This is the general formula for calculating the number represented by a binary
string. In our case of <span class="excalifont">1101</span>, this formula gives us precisely the calculation
from above. In more general mathematical notation, we can write this as:

<img src="https://logicalmethods.ai/textbook/boolean/img/representation_formula.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="200px"  alt="" >

<p>But this is just &ldquo;fancy notation&rdquo;&quot; to say exactly the same thing we just said.</p>
<p>The number <span class="excalifont">1101</span> is what&rsquo;s called a <span class="excalifont">4</span>-bit number, since it represents a
number using four bits. Typically, we&rsquo;re dealing with binary numbers of a fixed
number of bits. In implementations, this restriction is enforced by hardware
limitations: while mathematicians are happy dealing with strings of infinite
length in their minds, it&rsquo;s slightly complicated to stuff them into a computer
chip. This is why we have <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/64-bit_computing"
  target="_blank"><span class="excalifont">64</span>-bit computing</a> and not &ldquo;∞-bit computing&rdquo;.</p>
<p>But there are also practical advantages to have a fixed bit-size. For example,
if we have two binary numbers of the same length, they are incredibly easy to
add. Here&rsquo;s an example of how this works:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/addition_example.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="500px"  alt="" >

<p>Essentially, what we do here is to add the two numbers by adding their binary
components one by one, taking care along the way to &ldquo;carry over&rdquo; any overspill.
The way this works is that you start from the end again and you add the two
<span class="excalifont">0</span>th digits according to the following rules:</p>
<ul>
<li>
<p>If one digit is a <span class="excalifont">0</span> and the other is a <span class="excalifont">1</span>, the result is <span class="excalifont">1</span>, since <div class="text-center my-4 excalifont">(0 x
2⁰) + (1 x 2⁰) = (1 x
2⁰) + (0 x 2⁰) = 1</div></p>
</li>
<li>
<p>If both digits are a <span class="excalifont">0</span>, then the result is <span class="excalifont">0</span>, since</p>
</li>
</ul>
<div class="text-center my-4 excalifont">(0 x 2⁰) + (0 x 2⁰) = 0</div>
<ul>
<li>
<p>If both digits are a <span class="excalifont">1</span>, then the result is <span class="excalifont">0</span> with a <strong>carry</strong> of <span class="excalifont">1</span> (this
is the little red number in the next column), since</p>

    <img src="https://logicalmethods.ai/textbook/boolean/img/half_adder_rule.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="500px"  alt="" >

</li>
</ul>
<p>Now you might already see that what&rsquo;s going on here is just Boolean
truth-functions being applied to the <span class="excalifont">0</span>th digit. Basically, what we have here
are two inputs: the <span class="excalifont">0</span>th digit of our first number and the <span class="excalifont">0</span>th digit of our
second number. Let&rsquo;s call them <span class="excalifont">d₀</span> and <span class="excalifont">e₀</span> respectively. What we need to
calculate are two things: the <span class="excalifont">0</span>th digit of our result, and any potential
carry.</p>
<p>According to the rules, the first output, the <span class="excalifont">0</span>th digit of our addition, is
<span class="excalifont">1</span> just in case exactly one (and not both) of <span class="excalifont">d₀</span> and <span class="excalifont">e₀</span> is <span class="excalifont">1</span>. Otherwise, if
either <span class="excalifont">d₀ = e₀ = 0</span> or <span class="excalifont">d₀ = e₀ = 1</span>, the output is <span class="excalifont">0</span>. This describes a
truth-function, which is known as <span class="excalifont"><span class="Boolean">XOR</span></span> (&ldquo;exclusive or&rdquo;), which has the
following function table:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/xor_table.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="500px"  alt="" >

<p>We can actually express this function using only <span class="excalifont"><span class="Boolean">NOT</span>, <span class="Boolean">AND</span>, <span class="Boolean">OR</span></span>, but
using <span class="excalifont"><span class="Boolean">XOR</span></span> directly it&rsquo;s much easier.</p>
<p>The carry, instead, is <span class="excalifont">1</span> just in case both <span class="excalifont">d₀</span> and <span class="excalifont">e₀</span> are <span class="excalifont">1</span> and <span class="excalifont">0</span>
otherwise. But that&rsquo;s just the specification of <span class="excalifont"><span class="Boolean">AND</span></span>. So, we can describe the
rule as follows using Boolean truth-functions:</p>
<ul>
<li>
<p>the <span class="excalifont">0</span>th digit of our addition is <span class="excalifont">d₀ <span class="Boolean">XOR</span> e₀</span></p>
</li>
<li>
<p>the carry is <span class="excalifont">d₀ <span class="Boolean">AND</span> e₀</span></p>
</li>
</ul>
<p>If we&rsquo;ve implemented <span class="excalifont"><span class="Boolean">XOR</span></span> and <span class="excalifont"><span class="Boolean">AND</span></span> using relays or semiconductors, following
the ideas sketched above, we can implement this rule using the following
circuit known as a <strong>half-adder</strong>:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/half_adder.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="500px"  alt="" >

<p>
<img src="https://logicalmethods.ai/textbook/boolean/img/ai_half_adder.png" class="rounded  float-start inert-img img-fluid mx-3"  width="100px"  alt="" >

The idea is that the blue boxes are implementations of <span class="excalifont"><span class="Boolean">XOR</span></span> and <span class="excalifont"><span class="Boolean">AND</span></span>
respectively, which take two inputs and give two outputs. The input switches
represent <span class="excalifont">d₀</span> and <span class="excalifont">e₀</span> respectively, on meaning <span class="excalifont">1</span> and off meaning <span class="excalifont">0</span>. The
two lamps stand for the results, the <span class="excalifont">0</span>th digit and the carry, respectively. A
lamp being on means the relevant output is <span class="excalifont">1</span>, otherwise its <span class="excalifont">0</span>. What&rsquo;s
depicted here is the configuration that corresponds to our example, i.e. <span class="excalifont">d₀ =
1</span> and <span class="excalifont">e₀ = 1</span>.</p>
<p>Now, let&rsquo;s return to the <span class="excalifont">1</span>st (meaning second from the end) digit of our
result:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/calculation_focus.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="300px"  alt="" >

<p>You might notice that here, we no longer have just two inputs, but <em>three</em>: the
<span class="excalifont">1</span>st digit of the first
<abbr title="number to be added"><a  class="link-underline-opacity-0 link-body-emphasis"> summand</a></abbr> (<span class="excalifont">d₁</span>), the <span class="excalifont">1</span>st digit
of the second
<abbr title="number to be added"><a  class="link-underline-opacity-0 link-body-emphasis"> summand</a></abbr> (<span class="excalifont">e₀</span>), <em>plus</em> the
carry from the previous step (let&rsquo;s call it <span class="excalifont">c₀</span>). Like in the first step, we
need to calculate two outputs: the <span class="excalifont">1</span>st digit of our sum, and any potential
carry that might result.</p>
<p>The <span class="excalifont">1</span>st digit of our sum is rather straight-forward to calculate: it should
be <span class="excalifont">1</span> just in case exactly one input is <span class="excalifont">1</span> <em>or</em> all three inputs are <span class="excalifont">1</span>. The
reasoning is like in the two input case from before:</p>
<ul>
<li>
<p>If there&rsquo;s no <span class="excalifont">1</span>, we get:</p>
  <div class="text-center my-4 excalifont">(0 x 2¹) + (0 x 2¹) + (0 x 2¹)</div>
  
    <img src="https://logicalmethods.ai/textbook/boolean/img/addition_full_0.png" class="rounded mx-auto d-block inert-img img-fluid "  width="150px"  alt="" >

</li>
<li>
<p>If there&rsquo;s precisely one <span class="excalifont">1</span>, we have:</p>
  <div class="text-center my-4 excalifont">(1 x 2¹) + (0 x 2¹) + (0 x 2¹)</div>
  <div class="text-center my-4 excalifont">= (0 x 2¹) + (1 x 2¹) + (0 x 2¹)</div>
  <div class="text-center my-4 excalifont">= (0 x 2¹) + (0 x 2¹) + (1 x 2¹)</div>
  
    <img src="https://logicalmethods.ai/textbook/boolean/img/addition_full_1.png" class="rounded mx-auto d-block inert-img img-fluid "  width="150px"  alt="" >

</li>
<li>
<p>If there&rsquo;s exactly two <span class="excalifont">1</span>&rsquo;s, we get:</p>
  <div class="text-center my-4 excalifont">(1 x 2¹) + (1 x 2¹) + (0 x 2¹)</div>
  <div class="text-center my-4 excalifont">= (1 x 2¹) + (0 x 2¹) + (1 x 2¹)</div>
  <div class="text-center my-4 excalifont">= (0 x 2¹) + (1 x 2¹) + (1 x 2¹)</div>
  
    <img src="https://logicalmethods.ai/textbook/boolean/img/addition_full_2.png" class="rounded mx-auto d-block inert-img img-fluid"  width="300px"  alt="" >

</li>
<li>
<p>And if there&rsquo;s three <span class="excalifont">1</span>&rsquo;s, we have:</p>
  <div class="text-center my-4 excalifont">= (1 x 2¹) + (1 x 2¹) + (1 x 2¹)</div>
  
    <img src="https://logicalmethods.ai/textbook/boolean/img/addition_full_3.png" class="rounded mx-auto d-block inert-img img-fluid"  width="300px"  alt="" >

</li>
</ul>
<p>The Boolean truth-function which gives us precisely the desired output for the
<span class="excalifont">1</span>st digit of our computation is:</p>
<div class="text-center my-4 excalifont">(d₁ <span class="Boolean">XOR</span> e₁ ) <span class="Boolean">XOR</span> c₀</div>
<p>But what should the carry be? Inspecting the cases, we can see that we should
carry a <span class="excalifont">1</span> in one of two scenarios: if there&rsquo;s exactly two <span class="excalifont">1</span>&rsquo;s and if there&rsquo;s
precisely three. How can we express this in terms of truth-functions? While
there are different ways of doing this, here&rsquo;s a common one using <span class="excalifont"><span class="Boolean">AND</span>, <span class="Boolean">OR</span>,</span> and
<span class="excalifont"><span class="Boolean">XOR</span></span>:</p>
<div class="text-center my-4 excalifont">(d₁ <span class="Boolean">AND</span> e₁ ) <span class="Boolean">OR</span> (c₀ <span class="Boolean">AND</span> (d₁ <span class="Boolean">XOR</span> e₁))</div>
<p>The reasoning is that we can analyze our two scenarios (exactly two <span class="excalifont">1</span>&rsquo;s and
exactly three <span class="excalifont">1</span>&rsquo;s) in a slightly different way: either both inputs are <span class="excalifont">1</span> or
exactly one input is <span class="excalifont">1</span> and the carry from before is <span class="excalifont">1</span>. You can—and—
should!—verify that this works.</p>
<p>It&rsquo;s a bit more tedious to implement this using circuits, but of course it can
be done:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/full_adder.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>This circuit, here depicted in the configuration from our example, is called a
<strong>full adder</strong>, and can also be implemented using two half adders.

<img src="https://logicalmethods.ai/textbook/boolean/img/ai_two_half.png" class="rounded  float-start inert-img img-fluid mx-3"  width="600px"  alt="" >
</p>
<p>We can use full adders to implement full addition on fixed-bit integers: just
chain full adders to calculate the individual output bits, ensuring to always
carry over when necessary.</p>
<p>This example shows that Boolean inference is at the very heart of computation
and its implementation: one of the—if not <em>the</em>—most basic mathematical
operations is implemented using Boolean logic. In fact, addition becomes a form
of Boolean inference.</p>
<h2 id="models">Models<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>Turning from low-level reasoning—viz. the implementation of arithmetic—to more
high-level reasoning, we look at deductive reasoning in propositional logic
next. This is the kind of inference that is involved in conditionals in
programming languages, but also in automated inference with
<abbr title="knowledge  bases"><a  class="link-underline-opacity-0 link-body-emphasis"> KB</a></abbr>&rsquo;s, for example in expert
systems. It is common in everyday reasoning, as well, when we make inferences
like:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/ai_key.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>We can use Boolean algebra to define the notion of a <em>model</em> for a propositional language. This will give us the notion of deductively valid inference using the schema:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/deductive_inference.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>In essence what we need to do is very similar to the case of addition above:
before we could implement addition using Boolean algebra, we needed to
translate numbers into something that Boolean algebra can understand.
Essentially, we need to do the same thing for logic: before we can apply
Boolean algebra to inferences, we need to translate the formulas of our formal
language into something that Boolean algebra can work with—which turns out to
be truth-values.</p>
<p>Suppose that we have a propositional language, <span class="excalifont">L</span>, which has two propositional
variables <span class="excalifont">SUN</span> and <span class="excalifont">RAIN</span>, which we interpret as saying that it&rsquo;s sunny and
that it&rsquo;s rainy, respectively.</p>
<p>There are <em>four</em> logically relevant reasoning scenarios for inference in this
language. It could be:</p>
<ol>
<li>
<p>Sunny and rainy.</p>
</li>
<li>
<p>Sunny, but not rainy.</p>
</li>
<li>
<p>Not sunny, but rainy.</p>
</li>
<li>
<p>Neither sunny, nor rainy.</p>
</li>
</ol>
<p>That is, our logical space should look something like this:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/logical_space.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>Our aim is to implement a definition of a model for <span class="excalifont">L</span> that adequately
reflects this idea. To achieve this goal, we&rsquo;ll use the thought mentioned
before that we can <em>assign</em> truth-values to propositional variables, where
assigning the value <span class="excalifont">1</span> to <span class="excalifont">SUN</span>, say, means that <span class="excalifont">SUN</span> is true (it&rsquo;s sunny),
and assigning it the value <span class="excalifont">0</span> means that <span class="excalifont">SUN</span> is not true (it&rsquo;s not sunny).</p>
<p>Mathematically, we typically express such an assignment of values using the function symbol <span class="excalifont">v</span>, like so:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/assignments.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>When more than one assignment viewed as a model is under consideration at the
same time, we disambiguate with the use of subscripts. So, for example, there
is the assignment <span class="excalifont">v₁</span>, such that <span class="excalifont">v₁(SUN)=1</span> and <span class="excalifont">v₁(RAIN)=1</span>, as well as the
assignment <span class="excalifont">v₂</span>, such that <span class="excalifont">v₂(SUN)=1</span>, but <span class="excalifont">v₂(RAIN)=0</span>.</p>
<p>Since there are two propositional variables (<span class="excalifont">SUN</span> and <span class="excalifont">RAIN</span>), there are <span class="excalifont">2² =
4</span> possible ways of assigning truth-values from among <span class="excalifont">{0, 1}</span> in this way.
Each of these assignments corresponds to one of our reasoning situations. More
generally, if there are <span class="excalifont">n</span> propositional variables, where <span class="excalifont">n</span> is any number,
then there are <span class="excalifont">2ⁿ</span> different ways of assigning truth-values from <span class="excalifont">{0, 1}</span> to
the propositional variables. In our case, the relevant assignments and
corresponding scenarios are:</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><span class="excalifont">M₁</span>: 
<img src="https://logicalmethods.ai/textbook/boolean/img/m1.png" class="inert-img" height="48px"  style="ZgotmplZ" alt="" >
</td>
          <td>  </td>
          <td><span class="excalifont">v₁(RAIN) = 1</span> and <span class="excalifont">v₁(SUN) = 1</span></td>
          <td>  </td>
          <td><span class="excalifont">M₃</span>: 
<img src="https://logicalmethods.ai/textbook/boolean/img/m3.png" class="inert-img" height="48px"  style="ZgotmplZ" alt="" >
</td>
          <td>  </td>
          <td><span class="excalifont">v₃(RAIN) = 0</span> and <span class="excalifont">v₃(SUN) = 1</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
          <td></td>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td><span class="excalifont">M₂</span>: 
<img src="https://logicalmethods.ai/textbook/boolean/img/m2.png" class="inert-img" height="48px"  style="ZgotmplZ" alt="" >
</td>
          <td>  </td>
          <td><span class="excalifont">v₂(RAIN) = 1</span> and <span class="excalifont">v₂(SUN) = 0</span></td>
          <td></td>
          <td><span class="excalifont">M₄</span>: 
<img src="https://logicalmethods.ai/textbook/boolean/img/m4.png" class="inert-img" height="48px"  style="ZgotmplZ" alt="" >
</td>
          <td>  </td>
          <td><span class="excalifont">v₄(RAIN) = 1</span> and <span class="excalifont">v₄(SUN) = 1</span></td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>The idea is to <em>identify</em> the possible reasoning scenarios—from a logical
perspective—with these assignments. That is, we say that a <strong>model</strong> for the
language <span class="excalifont">L</span> <em>is</em> an assignment of Boolean truth-values to the propositional
variables. In short: <div class="text-center my-4 excalifont">Mᵢ = vᵢ</div></p>
<p>Each model tells us what the truth-values for the propositional variables are.
This allows as, for example, to determine the proposition <span class="excalifont">[SUN]</span> as follows:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/prop_sun.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>But to determine the truth-values of complex formulas, such as <span class="excalifont">SUN v
RAIN</span>, we first need to think about the connectives. For now, we&rsquo;ll focus on the connectives

<img src="https://logicalmethods.ai/textbook/boolean/img/negation.png" class="inert-img" height="20px"  style="ZgotmplZ" alt="" >
 (&ldquo;negation&rdquo;), 
<img src="https://logicalmethods.ai/textbook/boolean/img/conjunction.png" class="inert-img" height="20px"  style="ZgotmplZ" alt="" >
 (&ldquo;conjunction&rdquo;), and 
<img src="https://logicalmethods.ai/textbook/boolean/img/disjunction.png" class="inert-img" height="20px"  style="ZgotmplZ" alt="" >
.</p>
<p>Let&rsquo;s start with negation. In which models should we say that

<img src="https://logicalmethods.ai/textbook/boolean/img/neg_sun.png" class="inert-img" height="28px"  style="ZgotmplZ" alt="" >
, say, is true? A straight-forward answer
is: 
<img src="https://logicalmethods.ai/textbook/boolean/img/neg_sun.png" class="inert-img" height="28px"  style="ZgotmplZ" alt="" >
 says that it&rsquo;s not sunny, so the formula
should be true in precisely those models, where <span class="excalifont">SUN</span> is <em>not</em> true: <div class="text-center my-4 excalifont">v(
<img src="https://logicalmethods.ai/textbook/boolean/img/neg_sun.png" class="inert-img" height="34px"  style="ZgotmplZ" alt="" >
) = 1 just in case v(SUN) = 0.</div></p>
<p>But do you recognize it? This is exactly what the Boolean truth-function <span class="excalifont"><span class="Boolean">NOT</span></span>
does! That is, we can implement the proposal using <span class="excalifont"><span class="Boolean">NOT</span></span> as follows: <div class="text-center my-4 excalifont">v(
<img src="https://logicalmethods.ai/textbook/boolean/img/neg_sun.png" class="inert-img" height="34px"  style="ZgotmplZ" alt="" >
) = <span class="Boolean">NOT</span> v(SUN)</div></p>
<p>This means that 
<img src="https://logicalmethods.ai/textbook/boolean/img/neg_sun.png" class="inert-img" height="34px"  style="ZgotmplZ" alt="" >
 gets the following semantic content:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/prop_neg_sun.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>Turning to conjunction, in which models is 
<img src="https://logicalmethods.ai/textbook/boolean/img/sun_and_rain.png" class="inert-img" height="30px"  style="ZgotmplZ" alt="" >
 true? Since
the formula says that it&rsquo;s both sunny and raining, the answer is: precisely in
those models where both <span class="excalifont">SUN</span> and <span class="excalifont">RAIN</span> are true. In all other models, 
<img src="https://logicalmethods.ai/textbook/boolean/img/sun_and_rain.png" class="inert-img" height="30px"  style="ZgotmplZ" alt="" >
 is false. That is:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/condition_sun_and_rain.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="850px"  alt="" >

<p>But that&rsquo;s just what <span class="excalifont"><span class="Boolean">AND</span></span> does! So, we can implement this by saying:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/clause_and.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>Completely analogously, we can handle the case of disjunction. 
<img src="https://logicalmethods.ai/textbook/boolean/img/sun_and_rain.png" class="inert-img" height="30px"  style="ZgotmplZ" alt="" >
 says that it&rsquo;s either sunny or rainy. So it should be true in all and only those models where at least one of them is the case.</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/condition_sun_or_rain.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="800px"  alt="" >

<p>This we can implement using the Boolean <span class="excalifont"><span class="Boolean">OR</span></span> by saying that:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/clause_or.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>In sum, 
<img src="https://logicalmethods.ai/textbook/boolean/img/sun_and_rain.png" class="inert-img" height="30px"  style="ZgotmplZ" alt="" >
 and 
<img src="https://logicalmethods.ai/textbook/boolean/img/sun_or_rain.png" class="inert-img" height="30px"  style="ZgotmplZ" alt="" >
 get the following semantic content:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/prop_sun_and_or_rain.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>Using this idea, we can calculate the proposition <span class="excalifont">[A]</span> expressed by any
formula <span class="excalifont">A</span> of our language. Just apply the following clauses to calculate the
truth-values under an assignment:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/clauses.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>For example, we can calculate the proposition expressed by 
<img src="https://logicalmethods.ai/textbook/boolean/img/complex_fml.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
 as follows:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/complex_proposition.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="900px"  alt="" >

<p>The most difficult part to work out in this example is, as you might have
noticed, for which <span class="excalifont">v</span> we have <span class="excalifont">v(SUN) <span class="Boolean">OR</span> (v(RAIN) <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> v(SUN))) =
1</span>. Basically, you need to go through all the valuations and calculate the
value of the Boolean expression. This is tedious work! In the next chapter,
we&rsquo;ll discuss methods for making our lives a bit easier using the method of
truth-tables for this.</p>
<p>This is, in a nutshell, the standard implementation of the Boolean semantics
for propositional logic. Let&rsquo;s use it to check some inferences for deductive validity!</p>
<p>We&rsquo;ll do two examples:</p>
<ul>
<li>
<p>We&rsquo;ll show that 
<img src="https://logicalmethods.ai/textbook/boolean/img/ds_inf.png" class="inert-img" height="38px"  style="ZgotmplZ" alt="" >
 is deductively valid, i.e. 
<img src="https://logicalmethods.ai/textbook/boolean/img/ds_val.png" class="inert-img" height="38px"  style="ZgotmplZ" alt="" >
</p>
</li>
<li>
<p>We&rsquo;ll show that 
<img src="https://logicalmethods.ai/textbook/boolean/img/aff_inf.png" class="inert-img" height="38px"  style="ZgotmplZ" alt="" >
 is deductively invalid, i.e. 
<img src="https://logicalmethods.ai/textbook/boolean/img/aff_val.png" class="inert-img" height="38px"  style="ZgotmplZ" alt="" >
</p>
</li>
</ul>
<p>The first inference is an instance of <span class="excalifont">Disjunctive Syllogism</span>, which we&rsquo;ve
identified as a paradigmatic example of valid inference. Here, we&rsquo;ll show that
the concrete instance is valid. In the exercises, you&rsquo;ll show that the general
<em>schema</em> is valid for all instances.</p>
<p>To test the inference for validity, what we need to do is to check whether the following condition is satisfied:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/ds_condition.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>So, let&rsquo;s check in logical space:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/ds_validity.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="800px"  alt="" >

<p>Indeed! Once we&rsquo;ve worked out the relevant propositions, we can see that the only member of 
<img src="https://logicalmethods.ai/textbook/boolean/img/proposition_intersection.png" class="inert-img" height="32px"  style="ZgotmplZ" alt="" >
 is <span class="excalifont">M₄</span>, in which it is raining, i.e. <span class="excalifont">v₄(RAIN) = 1 </span> and so <span class="excalifont">M₄ ∈ [RAIN]</span>. But that just means that our condition is satisfied:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/ds_condition.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="500px"  alt="" >

<p>We can conclude that, indeed, 
<img src="https://logicalmethods.ai/textbook/boolean/img/ds_val.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="500px"  alt="" >
</p>
<p>The second inference is an instance of <span class="excalifont">Affirming a Disjunct</span>, which we&rsquo;ve
identified as a traditional fallacy. Let&rsquo;s see. For the inference to be valid, the following would need to be the case:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/aff_condition.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="600px"  alt="" >

<p>When we check logical space, we find the following:</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/aff_countermodel.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="800px"  alt="" >

<p>Once we&rsquo;ve worked out the propositions, we can see that 
<img src="https://logicalmethods.ai/textbook/boolean/img/countermodel.png" class="inert-img" height="40px"  style="ZgotmplZ" alt="" >
. This makes <span class="excalifont">M₁</span> a <strong>countermodel</strong> for the inference, which shows that</p>

<img src="https://logicalmethods.ai/textbook/boolean/img/aff_inval.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="500px"  alt="" >

<p>This means that, indeed: 
<img src="https://logicalmethods.ai/textbook/boolean/img/aff_val.png" class="rounded mx-auto d-block inert-img img-fluid my-4"  width="500px"  alt="" >
</p>
<p>Note, however, that the invalidity crucially depends on us interpreting 
<img src="https://logicalmethods.ai/textbook/boolean/img/disjunction.png" class="inert-img" height="32px"  style="ZgotmplZ" alt="" >
 using <span class="excalifont"><span class="Boolean">OR</span></span>. If we read the operation as an <span class="excalifont"><span class="Boolean">XOR</span></span>, the story changes—which you&rsquo;ll see in the exercises.</p>
<h2 id="further-readings">Further readings<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<ul>
<li>George Boole&rsquo;s <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/The_Laws_of_Thought"
  target="_blank">The Laws of Thought</a> is an enticing <em>historical</em> read.</li>
</ul>


  </div>
   <p><em>Last edited: </em>13/09/2024</p>
</div>


<ul class="navbar-nav flex-row justify-content-between mt-auto">
  
  <li class="nav-item">
    <a href="/textbook/valid-inference/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-left"></i>
    </a>
    
  </li>
  <li class="nav-item">
    <button class="btn btn-back-to-top">
    <i class="bi bi-chevron-double-up"></i>
  </button>
  </li>
  <li class="nav-item">
    
    <a href="/textbook/sat/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-right"></i>
    </a>
    
  </li>
</ul>

    </main>
    <footer class="align-self-center d-flex flex-column mt-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="footer-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="/about" aria-label="copyright-link">&copy; 2025 jkorbmacher et al. </a>
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link fs-6" href="https://github.com/jkorb/logicalmethods.ai" target="_blank"><i class="bi bi-github"></i></a>
      </li>
    </ul>
  </div>
</nav>
 
      <script src="https://logicalmethods.ai/js/helpers.js"></script>
      <script src="https://logicalmethods.ai/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
      
      
    </footer>
  </body>
</html>
