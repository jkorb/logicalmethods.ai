<!doctype html>
<html lang="en" data-bs-theme="light">
  <head>
    <meta charset="utf-8"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <title>logicalmethods.ai &ndash; Formal languages </title>
    <link rel="icon" type="image/x-icon" href="https://logicalmethods.ai/favicon.ico"></link>
    <link href="https://logicalmethods.ai/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/icons/font/bootstrap-icons.min.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/layout.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/syntax_hl.css"></link>
    <link href="https://logicalmethods.ai/css/textbook.css" rel="stylesheet"></link>
    <style>
      
    :root {
      --chapter: "2";
    }

    </style>
    
      <link rel="stylesheet" href="https://logicalmethods.ai/katex/katex.min.css">
<script defer src="https://logicalmethods.ai/katex/katex.min.js"></script>
<script defer src="https://logicalmethods.ai/katex/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},     
        {left: '\\[', right: '\\]', display: true},   
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>


    
  </head>
  <body class="bg-black d-flex flex-column m-0 p-0">
    <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvas-nav" aria-labelledby="offcanvas-navLabel" data-bs-theme="dark" data-bs-backdrop="false">
  <div class="offcanvas-header">
    <div class="h5 offcanvas-title" id="offcanvas-navLabel">
      Browse course
    </div>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  
  <div class="offcanvas-body">
    <ul class="navbar-nav">
      
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/about/"><i class="bi-file-person-fill"></i> &nbsp;&nbsp; About</a>
          </div>
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link fw-bold active" href="/textbook/"><i class="bi bi-book"></i> &nbsp;&nbsp; Textbook</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/textbook/"
            id="navbarSectiontxt-home" data-bs-toggle="collapse"
            data-bs-target="#collapsetxt-home"  
            aria-expanded="true"
            aria-controls="collapsetxt-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse show" id="collapsetxt-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                fw-bold active
                
                "
                href="/textbook/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/conditionals/"
              >6. 
                <i class="bi bi-unlock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/proofs/"
              >7. 
                <i class="bi bi-unlock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/fol/"
              >8. 
                <i class="bi bi-unlock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/fol-inference/"
              >9. 
                <i class="bi bi-unlock-fill"></i>
                 FOL Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/many-valued/"
              >10. 
                <i class="bi bi-unlock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logic-based learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/slides/"><i class="bi bi-rocket-takeoff-fill"></i> &nbsp;&nbsp; Slides</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/slides/"
            id="navbarSectionsli-home" data-bs-toggle="collapse"
            data-bs-target="#collapsesli-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapsesli-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapsesli-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/teaser/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/conditionals/"
              >6. 
                <i class="bi bi-unlock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/proof/"
              >7. 
                <i class="bi bi-unlock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/fol/"
              >8. 
                <i class="bi bi-unlock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/fol-inference/"
              >9. 
                <i class="bi bi-unlock-fill"></i>
                 FOL Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/exercises/"><i class="bi-gear-fill"></i> &nbsp;&nbsp; Exercises</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/exercises/"
            id="navbarSectionexe-home" data-bs-toggle="collapse"
            data-bs-target="#collapseexe-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseexe-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseexe-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/preamble/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/conditionals/"
              >6. 
                <i class="bi bi-unlock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/proof/"
              >7. 
                <i class="bi bi-unlock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/fol/"
              >8. 
                <i class="bi bi-unlock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/fol-inference/"
              >9. 
                <i class="bi bi-unlock-fill"></i>
                 FOL inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/assignments/"><i class="bi bi-house-gear-fill"></i> &nbsp;&nbsp; Assignments</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/assignments/"
            id="navbarSectionass-home" data-bs-toggle="collapse"
            data-bs-target="#collapseass-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseass-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseass-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/assignments/assignment_1/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Assignment 1 (due 09/19/2025)
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/assignments/assignment_2/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Assignment 2 (due 03/10/2025)
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      
      
      
    </ul>
  </div>
</div>



    <header class="align-self-center d-flex flex-column m-0 mb-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="header-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="https://logicalmethods.ai/">
    <img src="https://logicalmethods.ai/img/nav_id.png" class="inert-img img-fluid m-2" draggable="false" width="400px">
    </a>
    <button class="navbar-toggler border-0" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas-nav" aria-controls="offcanvas-nav">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
</nav>

      
      
    </header>
    
    <main class="align-self-center d-flex flex-column flex-fill bg-white m-md-1 p-0" data-bs-theme="light">
      <ul class="navbar-nav flex-row justify-content-center mt-2">

  <li class="nav-item">
    <a href="/textbook/" class="btn" style="font-size: 20pt;" tabindex="-1" role="button" aria-disabled="false">
      <i class="bi bi-house-up"></i>
    </a>
  </li>
</ul>
<div class="container chapter">
  <p>By: <em>Rick Nouwen and Johannes Korbmacher</em></p>
  <div class="m-4"><h1 id="formal-languages">Formal languages<button class="btn btn-back-to-top">
    
  </button>
</h1>
<hr>

<p>
<img src="https://logicalmethods.ai/textbook/formal-languages/img/ai_language.png" class="rounded  float-start inert-img img-fluid m-2"  width="350px"  alt="" >

When we try to develop AI systems, we immediately run into an issue: computers,
which are the basis for any modern AI technology, &ldquo;speak&rdquo; a different language
than us—the proverbial 1&rsquo;s and 0&rsquo;s.</p>
<p>That is, even if we understand what intelligent behavior is and we manage to
break it down into instructions that a computer can, in principle, follow, we
still need to express these instructions in an unambiguous language that the
computer can &ldquo;understand&rdquo; (i.e. execute).

<img src="https://logicalmethods.ai/textbook/formal-languages/img/ai_understand.png" class="rounded  float-end inert-img img-fluid m-2"  width="350px"  alt="" >

We need to write <em>code</em>.</p>
<p>Moreover, since intelligent behavior involves knowledge about the world and
acting on the basis of such knowledge, we need to be able to communicate such
knowledge to any prospective AI system. That is, we need a way to <em>represent</em>
our knowledge about the world.</p>
<p>The solution to the first problem are—of course—<em>programming languages</em>, which
are precisely defined, rule-based systems for expressing unambiguous
instructions in a language that we can understand, but which we can
automatically transform into instructions that a computer can understand. The
solution to the second problem are <em>knowledge representation languages</em>, which
are systems of precisely defined expressions that can represent various facts
about the world.</p>
<p>It turns out that, fundamentally, both programming languages and knowledge
representation languages are instances of the same kind of mathematical
structure: they are <em>formal languages</em>.</p>
<p>Formal languages have their origin in the study of valid inference—in logical
theory—but today they are one of the most widely used logical tools in AI and
other disciplines that employ logical tools.</p>
<p>In this chapter, we&rsquo;ll study formal languages, how they are defined
mathematically, and how they are used in logical theory and AI.</p>
<p>At the end of this chapter, you&rsquo;ll be able to:</p>
<ul>
<li>explain the ambiguity and over-expressiveness of natural language using
examples</li>
<li>define formal languages using formal grammars</li>
<li>parse logical formulas using rewrite rules and parsing trees</li>
<li>represent simple facts about the world using the language of propositional
logic</li>
<li>name standard examples of formal languages and their use cases</li>
</ul>
<h2 id="formal-vs-natural-languages">Formal vs. natural languages<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p><em>English</em>, <em><i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Lillooet_language"
  target="_blank">St̓át̓imcets</a></em> and
<em><i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Ripuarian_language"
  target="_blank">Ripuarian</a></em> are examples of
natural languages. <em>Python</em>, <em>propositional logic</em> and <em><i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Algebraic_notation_%28chess%29"
  target="_blank">algebraic chess
notation</a></em> are
examples of formal languages. What makes a language a natural language and what
makes it a formal one?</p>
<p>We all speak at least one natural language and many of us speak multiple. A
natural language is a naturally evolved system that you learn spontaneously, for
instance by interacting with your parents and other people around you when you
are very young. Native speakers of English, St̓át̓imcets or Ripuarian didn&rsquo;t learn
their native language at school or by studying grammar books, but simply by
being in an environment where the language was used. Because natural languages
are acquired in this way, they are also very susceptible to change. They
constantly evolve, just by being used and passed on to next generations.</p>
<p>
<img src="https://logicalmethods.ai/textbook/formal-languages/img/ai_learning_language.png" class="rounded float-start inert-img img-fluid mx-2 my-1"  width="450px"  alt="" >

In contrast, nobody learns Python, propositional logic or algebraic chess
notation simply by interacting with their parents. Also, these languages clearly
didn&rsquo;t evolve naturally and while the conventions of these languages may change
over time, they do not do so spontaneously, but rather because a community of
users explicitly decides to make a certain change.</p>
<p>Having command of a natural language is an extremely powerful skill. It allows
you to communicate with others about your desires, your thoughts, your
observations, your plans. It allows you to learn things in school, to teach
other people what you have learned, to enjoy art in the form of literature,
poetry and song lyrics, to laugh at jokes, to persuade others to change their
actions, etc. etc.</p>
<p>Most of the recent advances in AI make use of the fact that natural language is
such a pervasive part of our lives. Because language is everywhere, it creates
an enormous wealth of data about many facets of human existence and human
cognition, ready as input for machine learning. Given this, why don&rsquo;t we just
use natural language for everything in AI? What do we need formal languages for?</p>
<p>There are many different reasons formal languages are important in general and
for AI in particular. One reason that is relatively quick to appreciate is that
powerful large language models trained on natural language are developed using
programming languages, which are formal languages. We cannot construct a neural
network using natural language. So even sub-symbolic approaches to AI rely on
formalisms that have symbolic roots.</p>
<p>More generally, however, natural languages
have some properties that make them unsuitable for doing logic or maths and,
equally importantly, that make them unsuitable for storing human knowledge. Two
such properties stand out:</p>
<ul>
<li>
<p>Natural languages are <em>ambiguous</em>: Statements formulated in a natural language
can often be interpreted in multiple ways. As a consequence, if we choose to use
natural language as a basis for drawing inferences, we can&rsquo;t always be sure that
rules or facts that we want would want an AI system to benefit from are
understood in the appropriate way.</p>
</li>
<li>
<p>Natural languages are <em>over-expressive</em>: Specific statements made in a natural
language tend to describe highly specific thoughts. This makes natural language
unsuitable for studying <em>generalities</em> in valid inference.</p>
</li>
</ul>
<p>Let us discuss both these properties in more detail.</p>
<h3 id="ambiguity">Ambiguity<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h3>
<hr>

<p>Imagine that we want to build an AI system that gives out safety advice on
eating foraged mushrooms. We have access to a lot of expert knowledge about
mushrooms. One idea could be to feed this knowledge to the AI system in the form
of natural language statements. For instance, we could give the system lots of
English language sentences that together make up all our knowledge. Say, these
sentences include the following:</p>
<p class="text-center">
<span class="excalifont ">S = If a mushroom has red spots and gills, then
it's not poisonous.</span>

<p>Also, we prompt the AI system with another English language sentence:</p>
<p class="text-center">
<span class="excalifont ">T = The mushroom in front of me has red spots and
gills.</span>

<p>It may seem straightforward how the AI system can prepare an advice on the basis
of the knowledge captured in 
<span class="excalifont ">S</span>
 and the information in the user
prompt 
<span class="excalifont ">T</span>
.</p>
<p>We may think that all the AI system needs to do is recognise that it can apply
the deductive inference pattern known as <strong>modus ponens (MP)</strong>, which licenses
the inference from an if-then statement together with the if-part to the
then-part: from &ldquo;if the door is open, you can come in&rdquo; and &ldquo;the door is open&rdquo;,
you can infer &ldquo;you can come in.&rdquo; Schematically, modus ponens licenses all the
inferences of the following form, where 
<span class="excalifont ">A</span>

and 
<span class="excalifont ">A</span>
  are <em>any</em> two statements:

<img src="https://logicalmethods.ai/textbook/formal-languages/img/modus_ponens.png" class="rounded mx-auto d-block inert-img img-fluid"  width="150px"  alt="" >

Applying this principle, then, you would expect that from the two statements
above the AI system should infer that the mushroom in question is not poisonous.</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/mushroom.png" class="rounded float-start inert-img img-fluid"  width="300px"  alt="" >

<p>The problem, however, is that &ldquo;the mushroom in front of me has red spots and
gills&rdquo; is ambiguous. It could either mean that the mushroom has red spots and
red gills, or it could state that it has red spots and that it has gills (of
whatever colour). Because of this we cannot be sure what either of these
statements are saying exactly. It is not clear what the rule is that

<span class="excalifont ">S</span>
 is intended to capture, nor is it clear what observation the user
is describing with 
<span class="excalifont ">T</span>
. And because of all that uncertainty, we
cannot be sure whether modus ponens applies. For instance, perhaps

<span class="excalifont ">S</span>
 is intended to mean that mushrooms that have red spots and red
gills are not poisonous, while 
<span class="excalifont ">T</span>
 is intended to mean that the
mushroom in question has gills (gray ones, in fact) and red spots. In that case,
modus ponens would not apply. In other words, if our AI system accidentally
interprets these sentences not as they were intended, it could end up applying
modus ponens and cause the users to poison themselves.</p>
<p>A similar problem concerns the words &ldquo;if&rdquo; and &ldquo;then&rdquo; in languages like English.
Say, I remove the ambiguity in 
<span class="excalifont ">S</span>
 above and instead state that:</p>
<p class="text-center">
<span class="excalifont ">S' = If a mushroom has red spots and red gills,
then it's not poisonous.</span>

<p>It is now clear what this means. It tells us what is the case when a mushroom
has the features that are mentioned. Does this tell us anything about mushrooms
that do not have red spots and red gills? For most people, the intuition is that
it does not: on the basis of just 
<span class="excalifont ">S'</span>
 I cannot conclude
anything about a mushroom with black gills and no spots.</p>
<p>The problem, however, is that &ldquo;if&rdquo; and &ldquo;then&rdquo; are not always understood in this
way. Imagine yourself saying this to a child:</p>
<p class="text-center">
<span class="excalifont ">
U = If you behave well, I will buy you an
ice-cream.
</span>

<p>This clearly tells the child, via modus ponens, what happens when they are
well-behaved. However, in this case the statement also seems to be saying what
happens when they do not behave well. 
<span class="excalifont ">U</span>
 seems to clearly suggest
that if the child does <em>not</em> behave well, then there won&rsquo;t be any ice-cream.</p>
<p>So, &ldquo;if&rdquo; and &ldquo;then&rdquo; are interpreted differently in different examples. This
simple observation has profound consequences for AI. If we feed the AI system
our knowledge in the form of a long list of English sentences of the form</p>
<p class="text-center">
<span class="excalifont ">If A, then B</span>

<p>how does the AI system decide which of these to interpret the way we interpreted

<span class="excalifont ">S'</span>
 and which to interpret parallel to our understanding of 
<span class="excalifont ">U</span>
? The
use of a natural language complicates the storing of knowledge, since a single
natural language sentence often come with more than one interpretation.</p>
<p>Ambiguity is extremely common. Whenever we want represent knowledge and rules
precisely, we should avoid the inherent ambiguity of natural language. Formal
languages allow us to do just that. Let us now turn to a second reason why we
choose formal over natural languages.</p>
<h3 id="over-expressiveness">Over-expressiveness<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h3>
<hr>

<p>To illustrate the problem of over-expressiveness, let us look at another case of modus ponens:

<img src="https://logicalmethods.ai/textbook/formal-languages/img/box_example.png" class="rounded mx-auto my-2 d-block inert-img img-fluid"  width="800px"  alt="" >
</p>
<p>
<img src="https://logicalmethods.ai/textbook/formal-languages/img/ai_magic.png" class="rounded float-end inert-img img-fluid mx-2 my-1"  width="450px"  alt="" >

Say a magician places a rabbit in a cardboard box and they close the box. After
a short while they open it again and show the audience that the box is empty.
The audience gasps. Why? Because on the basis of a common assumption like

<span class="excalifont ">M</span>

and modus ponens, the audience expects the box to contain the rabbit. An object
was placed in what looks like a normal box, we didn&rsquo;t see anything happening to
the box, so we infer via modus ponens that the object is still in the box.</p>
<p>Members of the audience now need to somehow reconcile the empty box with what
they saw. They have a number of options. It looked like the box was a normal
box, but perhaps it wasn&rsquo;t. Perhaps there is some trick that lets the rabbit
escape from the box unseen by the audience. In that case, this is not a normal
box and modus ponens would not allow us to conclude that the rabbit is still in
the box. Similarly, the audience didn&rsquo;t see anything happen to the box, but
perhaps the magician managed to distract his audience and perhaps he removed the
rabbit in a way we couldn&rsquo;t see?</p>
<p>Once more, modus ponens does not apply and we do not end up inferring that the
rabbit is in the box. Another possibility is that the rabbit is still in the
box. That is, we were right to apply modus ponens, but we are wrong in our
observation that the rabbit is gone. (Perhaps the magician isn&rsquo;t showing us all
of the box?) Finally, and most interestingly, perhaps some people in the
audience take this failure of modus ponens as evidence that

<span class="excalifont ">M</span>

must be false. In other words, these people believe in magic.</p>
<p>Now, compare this story to the following statement:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/odd_numbers.png" class="rounded mx-auto my-2 d-block inert-img img-fluid"  width="800px"  alt="" >

<p>Say now I calculate:</p>
<p class="text-center">
<span class="excalifont ">a x b = c</span>

<p>and both

<span class="excalifont ">a</span>

and

<span class="excalifont ">b</span>
 are odd. I observe that

<span class="excalifont ">c</span>
 is an even number, then there&rsquo;s a few
options again. Perhaps I was wrong to believe that

<span class="excalifont ">a x b = c</span>
, or perhaps I was
wrong to believe that

<span class="excalifont ">a</span>
 and 
<span class="excalifont ">b</span>

are both odd. Or perhaps my observation that

<span class="excalifont ">c</span>
 is even was wrong. An arrogant person may
even believe that their maths book is wrong in stating 
<span class="excalifont ">N</span>
.</p>
<p>
<img src="https://logicalmethods.ai/textbook/formal-languages/img/ai_math.png" class="rounded float-start inert-img img-fluid mx-2 my-1"  width="450px"  alt="" >

In any case, both the case of magic and the case of odd number multiplication
show that modus ponens is a very strong inference. As soon as we have all the
ingredients for modus ponens, we cannot help but draw the conclusion. And if
that conclusion is not in line with what we observe, we start questioning our
assumptions and our observation.</p>
<p>The two stories also show that modus ponens is a very <em>general</em> inference. It
exists completely independent of subject matter. Structurally, the story above
about 
<span class="excalifont ">M</span>
 is completely parallel to that of

<span class="excalifont ">N</span>
.</p>
<p>This is where the <strong>over-expressiveness</strong> of natural language comes in. We can
use natural language to express individual cases where modus ponens applies, as
we just did above. But because natural language is so good at talking about the
specific details of situations, it can make us lose sight of the more general,
abstract patterns that underlie our reasoning—it is very bad at <em>abstracting
away</em> form logically irrelevant details. 
<span class="excalifont ">M</span>

and 
<span class="excalifont ">N</span>
 are highly specific examples of
premises that with the right further premise bring us in a situation where we
can apply modus ponens. To be able to talk about modus ponens as a <em>general</em>
principle of valid inference, we would need to let go of the specifics in these
examples and state the principle using an abstract formal language. This can be
very hard to do in natural language.</p>
<p>From a logical perspective, however, both stories have the same underlying
structure. In both cases, we have a <em>conditional</em> statement—an
&ldquo;if-then&rdquo;-statement—of the form</p>
<p class="text-center">
<span class="excalifont ">If A, then B.</span>

<p>In the first example, 
<span class="excalifont ">M</span>
, we have:</p>
<p class="text-center">
<span class="excalifont ">
A = We put an object in a cardboard box and nothing happens to that box
</span>

<p class="text-center">
<span class="excalifont ">
B = The object will remain in the box
</span>

<p>In the second example, 
<span class="excalifont ">N</span>
, we have:</p>
<p class="text-center">
<span class="excalifont ">
A = We multiply two odd numbers
</span>

<p class="text-center">
<span class="excalifont ">
B = The result is odd
</span>

<p>In both cases above, we thought

<span class="excalifont ">If A, then B</span>

was the case, as was

<span class="excalifont ">A</span>
. But in both cases, we also thought

<span class="excalifont ">B</span>

was not the case. Given that this clashes with modus ponens we start questioning our
assumptions. Either something is wrong with our assumptions

<span class="excalifont ">A</span>
 or 
<span class="excalifont ">If A, then B</span>
, or something&rsquo;s wrong with our belief that

<span class="excalifont ">B</span>
.—Logic allows us to
do make such reasoning very explicit and very general. By using a formal
language we can focus on the pattern underlying our mechanisms of valid
inference.</p>
<p>In other words, when we study valid inference, we often do not care about the
specific content of the statements our inferences are built on. It would be
extremely hard to define a notion like modus ponens using just a natural
language. The abstraction offered by a <em>formal</em> language makes it possible to
make explicit what all inferences that are to be classified as such have in
common.</p>
<p>More generally, when we study systems of valid inference, we are often looking
to find out what the consequences are of our assumptions about logical laws.  If
we only had natural language to study this, which sentences should we use then?
Should these be about mushrooms, rabbits, numbers, or ice creams? Similar
considerations apply to mathematics. Highly abstract formal languages allow us
to focus on the important things. We all learn that we can simplify a quadratic
equations like</p>
<p class="text-center">
<span class="excalifont ">x² + 5x + 6 = 0</span>

<p>to</p>
<p class="text-center">
<span class="excalifont ">(x+3)(x+2)=0</span>

<p>by factorization, which means that 
<span class="excalifont ">x</span>
 is
either 
<span class="excalifont ">-3</span>
 or 
<span class="excalifont ">-2</span>
. Just imagine doing this without the use of abstract symbols
like 
<span class="excalifont ">x</span>
!</p>
<h2 id="formal-languages-1">Formal languages<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>Formal languages are neither ambiguous nor over-expressive. They were
specifically designed as mathematical models of language, which abstract away
from irrelevant details in a formally precise fashion. This is precisely what
makes them so great for &ldquo;talking&rdquo; with computers: they solve the issue of
precision that we mentioned at the outset. In fact, it turns out that they are
also able to represent knowledge about the world, but we&rsquo;ll return to this point
later.</p>
<p>So far, you&rsquo;ve only had a glimpse of what a formal language looks like. We have
not specified one formally yet. Before we can go ahead and give the mathematical
definition of what a formal language is, we need to talk a bit more about
<em>sets</em>. Formal languages <em>are</em> sets. So, we need to know what a set is before we
can talk about formal languages.</p>
<h2 id="sets">Sets<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>A <strong>set</strong> is the simplest kind of collection of objects. All that matters to a set
is which things are in it and which things are not. If some object

<span class="excalifont ">x</span>
 is in a
set, we say that

<span class="excalifont ">x</span>

is one of its <strong>elements</strong> or <strong>members</strong>. Elements of a
set are also said to <em>belong to</em> the set or to <em>be contained in</em> the set. Beyond
membership, nothing matters to a set. For instance, there is no order to the
elements in a set and an object is either in the set or not - it cannot be in a
set multiple times.</p>
<p>It can sometimes be helpful (but also sometimes hurtful!) to think of a set as
&ldquo;bag&rdquo; of objects from an ambient &ldquo;space&rdquo;. Consider the following illustration:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/set.png" class="rounded mx-auto my-2 d-block inert-img img-fluid"  width="900px"  alt="" >

<p>The yellow rectangle is out ambient space of objects, everything in its confines
is a potential member of our set. It contains a bunch of things: animals,
people, drinks, playing cards, numbers, …. The green area is a set in this
space: the set that contains little Jimmy, my beer, and the number 1. It&rsquo;s
important to keep in mind, though, that this is just a visualization aid. Sets
really are mathematical objects, not areas in space. There are sets that are
impossible to draw or locate.</p>
<p>A set may contain any kind of object: numbers, symbols, people, or even other
sets. For 
<span class="excalifont ">S</span>
 a set and 
<span class="excalifont ">s</span>
 an object, we write

<span class="excalifont ">a ϵ S</span>

to say that 
<span class="excalifont ">a</span>
 is an
element of 
<span class="excalifont ">S</span>
, and we write

<span class="excalifont ">a&nbsp;ϵ<span style="display:inline-block;width:0;position:relative;left:-0.5em;">/</span>&nbsp;S</span>
 to say that 
<span class="excalifont ">a</span>
 is <em>not</em> an element of

<span class="excalifont ">S</span>
. If we have many objects 
<span class="excalifont ">a₁, ..., aₙ</span>
, then we also write 
<span class="excalifont ">a₁, ..., aₙ ϵ S</span>
 to say that

<span class="excalifont ">a₁ ϵ S</span>

and

<span class="excalifont ">a₂ ϵ S</span>

and
…, and

<span class="excalifont ">aₙ ϵ S</span>
.</p>
<p>If the elements of a set are precisely 
<span class="excalifont ">a₁, ..., aₙ</span>
, then we can
denote the set by</p>
<p class="text-center">
<span class="excalifont ">{a₁, ..., aₙ}</span>

<p>This is called an <strong>extensional definition</strong> of the set. So, for example, the
set

<img src="https://logicalmethods.ai/textbook/formal-languages/img/set_example.png" class="rounded mx-auto my-2 d-block inert-img img-fluid"  width="300px"  alt="" >

contains precisely little Jimmy and the set that contains the number 1 and my
beer as elements. That is, the set has <em>two</em> elements, not three. This also
shows why we can&rsquo;t &ldquo;draw&rdquo; all sets: how do you manage to draw a set that
contains a set in a space?<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>For most interesting sets, however, we cannot give an extensional definition.
One reason for this could be that we may not know exactly what the elements are.
For instance, if the elements of a set are precisely the objects satisfying
condition 
<span class="excalifont ">Φ</span>
, then we can denote the set by:</p>
<p class="text-center">
<span class="excalifont ">{x : Φ(x)}</span>

<p>This is called a definition by <strong>set abstraction</strong>. For example, if I have the
quadratic equation</p>
<p class="text-center">
<span class="excalifont ">x²+5x+6 = 0,</span>

<p>then we can express the set of solutions to this equation as:</p>
<p class="text-center">
<span class="excalifont ">{x : x²+5x+6 = 0}.</span>

<p>In other words, we have a way of expressing the solutions, even if we do not yet
know what they are. By the way, it turns out that this abstracted set is equal to the
extensional set
<p class="text-center">
<span class="excalifont ">{-3,-2}.</span>
</p>
<p>Another reason why non-extensional definitions are handy is because many of the
kinds of sets we want to study are typically infinite. For example,</p>
<p class="text-center">
<span class="excalifont ">{x : x is a prime number}</span>

<p>is the set that contains all and only the prime numbers. So we have, for
example:</p>
<p class="text-center">
<span class="excalifont ">3 ϵ {x : x is a prime number}</span>

<p>but</p>
<p class="text-center">
<span class="excalifont ">4 ϵ<span style="display:inline-block;width:0;position:relative;left:-0.5em;">/</span> {x : x is a prime number}</span>

<p>But by <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Euclid%27s_theorem"
  target="_blank">Euclids theorem</a>,
there are infinitely many prime numbers. So, for reasons of time and space, we
could never write down a list of all the prime numbers for an extensional
definition of the set.<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>Most formal languages that we will encounter will be infinite sets. So what
exactly <em>is</em> a formal language? Put simply, a formal language is <strong>a set of
sequences of symbols</strong>. Symbols are the building blocks of a formal language. A
formal language starts with the specification of what these building blocks are.
We call this an <strong>alphabet</strong>, which is just a set of symbols. Using the
alphabet, we then use a <strong>grammar</strong> to construct the set of sequences, i.e. the
formal language.</p>
<h3 id="alphabets">Alphabets<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h3>
<hr>

<p>Sequences of symbols are recruited from an alphabet. We usually write 
<span class="excalifont ">Σ</span>
 to denote the alphabet of a
language.</p>
<p>It&rsquo;s important to note that the alphabet can be <em>any</em> set. So, e.g.,</p>
<p class="text-center">
<span class="excalifont ">Σ={0,1,2,3,4,5,6,7,8,9}</span>

<p>is a perfectly fine alphabet. You can use it to define the language of all the <em>numerals</em> (terms for natural numbers).</p>
<p>One way to do that is to use an operation called the Kleene
star, named after the American mathematician <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene"
  target="_blank">Stephen
Kleene</a> and written as an
asterix. The set

<span class="excalifont ">Σ*</span>
 is the set of all sequences that you can build
with the elements of 
<span class="excalifont ">Σ</span>
. This set is a formal language and it includes
sequences such as

<span class="excalifont ">15935304888</span>
,

<span class="excalifont ">249583</span>
, and simply

<span class="excalifont ">2</span>
. This is not the set of
what we normally consider to be numerals, though, since 
<span class="excalifont ">Σ*</span>
 will
also include sequences like

<span class="excalifont ">000000001</span>
 and

<span class="excalifont ">000881</span>
, which are not numerals (in the Western Arabic decimal system, at least).</p>
<p>So, while the Kleene star gives us a way to construct the set of all sequences
made from an alphabet, most formal languages we are interested in will be a
specific smaller subset of 
<span class="excalifont ">Σ*</span>
. This is why
we need a <em>grammar</em>.</p>
<h3 id="grammar">Grammar<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h3>
<hr>

<p>The grammar of a language determines which sequences of symbols from 
<span class="excalifont ">Σ</span>
 are valid expressions of the language.</p>
<p>In the case of most formal languages in logic, grammars use a technique known as
<strong>inductive definition</strong>. Here is an example of such a definition for the set of
all numerals  built from 
<span class="excalifont ">Σ</span>
.</p>
<ol>
<li>The following are all numerals: 
<span class="excalifont ">1,2,3,4,5,6,7,8,9</span>
</li>
<li>If 
<span class="excalifont ">N</span>
 is a numeral, then so are

<span class="excalifont ">N0</span>
,

<span class="excalifont ">N1</span>
,

<span class="excalifont ">N2</span>
,

<span class="excalifont ">N3</span>
,

<span class="excalifont ">N4</span>
,

<span class="excalifont ">N5</span>
,

<span class="excalifont ">N6</span>
,

<span class="excalifont ">N7</span>
,

<span class="excalifont ">N8</span>
,

<span class="excalifont ">N9</span>
.</li>
<li>Nothing else is a numeral.</li>
</ol>
<p>Here&rsquo;s how this definition works: In the first step we get all the numerals that can be written as a single digit. This is the whole alphabet with the exception of 
<span class="excalifont ">0</span>
.
, which isn&rsquo;t a numeral. Then in the second step we can represent numbers
that correspond to sequences of any length 
<span class="excalifont ">>1</span>
. For instance, this definition
shows that 
<span class="excalifont ">120</span>
 is a numeral:</p>
<ul>
<li>
<span class="excalifont ">1</span>
 is a numeral (step 1);</li>
<li>
<span class="excalifont ">12</span>
 is a numeral (step 2);</li>
<li>
<span class="excalifont ">120</span>
 is a numeral (step 2).</li>
</ul>
<p>Using this inductive definition, there is no way to show that

<span class="excalifont ">01</span>
 is a natural
number. Given the final line of the definition, we must conclude that it is
therefore not a numeral.<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
<h3 id="the-language-of-logic">The language of logic<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h3>
<hr>

<p>
<img src="https://logicalmethods.ai/textbook/formal-languages/img/logic_abc.png" class="rounded  float-end inert-img img-fluid m-2"  width="450px"  alt="" >

Just like the language of numeral notation we saw above, logics are also sets of
sequences of symbols. We often refer to these sequences as <strong>formulas</strong>, so a
logic is a formal language consisting of formulas. In order to specify such a
language, we will want to specify an alphabet and a grammar so that the formulas
that make up the formal language are well-formed sequences that are useful for
the study of valid inference. Here, we will define the language used for
<strong>propositional logic</strong>.</p>
<p>Starting with the alphabet, we should first note that, in logic, not all
elements of the alphabet play the same role. (Similarly, in the case of the
language of numbers we saw that 0 played a different role than the other
digits). For propositional logic, the alphabet consists of three kinds of
things:</p>
<ul>
<li>propositional variables: symbols that stand for propositions</li>
<li>operators: symbols that operate on or connect propositions</li>
<li>auxiliaries: symbols that indicate how parts of a formula combine</li>
</ul>
<p>An example of an alphabet for the language of propositional logic is:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/logic_alphabet.png" class="rounded mx-auto my-2 d-block inert-img img-fluid"  width="400px"  alt="" >

<p>Here, 
<span class="excalifont ">p₁, …, pₙ</span>
 are the <em>(propositional)
variables</em>, 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/operators.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
 are are the <em>operators</em>, and

<span class="excalifont ">(</span>
  and 
<span class="excalifont ">)</span>
 are the
auxiliaries.</p>
<p>The operators have the following conventional names and readings:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/operators_reading.png" class="rounded mx-auto my-2 d-block inert-img img-fluid"  width="400px"  alt="" >

<p>The Kleene star of this set, 
<span class="excalifont ">Σ*</span>
,
provides us with all the sequences that we can build using these symbols. 
<span class="excalifont ">Σ*</span>
, contains meaningful expressions like:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/formula_example.png" class="rounded mx-auto my-2 d-block inert-img img-fluid"  width="200px"  alt="" >

<p>but also lots of expressions that are not well-formed for propositional logic, like:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/formula_counterexample.png" class="rounded mx-auto my-2 d-block inert-img img-fluid"  width="200px"  alt="" >

<p>So, we should give an inductive definition for the language of propositional logic, which we will call 
<span class="excalifont ">L</span>
:</p>
<ul>
<li>
<p>
<span class="excalifont ">p₁, ..., pₙ ϵ L</span>
 and</p>
</li>
<li>
<p>if 
<span class="excalifont ">A ϵ L</span>
, then 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/negation_A.png" class="inert-img" height="18px"  style="ZgotmplZ" alt="" >
, as well as</p>
</li>
<li>
<p>if 
<span class="excalifont ">A, B ϵ L</span>
, then 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/operator_AB.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
.</p>
</li>
</ul>
<p>As before, crucially, we assume in addition that nothing else is in 
<span class="excalifont ">L</span>
, but from now on, we will leave this &ldquo;closure
condition&rdquo; implicit. In other words, we assume that if something complies with
the above statements, then it is indeed in

<span class="excalifont ">L</span>
, but if it does not, then it is not.</p>
<p>We can now easily see that 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/formula_example.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
 is a
member of 
<span class="excalifont ">L</span>
. To see this, we simply perform the construction:</p>
<ol>
<li>We know that 
<span class="excalifont ">p₁</span>
 and 
<span class="excalifont ">p₃</span>
 are formulas (by the first clause of the inductive definition).</li>
<li>So, we know that 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/formula_example_1.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
 is a formula (by the third clause and 1.).</li>
<li>We know that 
<span class="excalifont ">p₂</span>
 is a formula (by the
first clause).</li>
<li>So, we know that 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/formula_example_2.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
 (by the second clause and 3.)</li>
<li>So, we know that 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/formula_example.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
 (by the third clause and 4. and 5.)</li>
</ol>
<p>But we can also see that 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/formula_counterexample_2.png" class="inert-img" height="18px"  style="ZgotmplZ" alt="" >
 is <em>not</em> a formula, since no rule every
allows for 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/negation.png" class="inert-img" height="18px"  style="ZgotmplZ" alt="" >
 to occur in a formula without being followed by formula.</p>
<p>In computer science and AI, there is a wide-spread notation that significantly
simplifies the above rules: the so-called <strong>Backus-Naur Form (BNF)</strong>. In BNF,
instead of all of the above, we can simply write the following to define the same language 
<span class="excalifont ">L</span>
:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/bnf.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="400px"  alt="" >

<p>Here, we read the 
<span class="excalifont ">|</span>
 as an &ldquo;or&rdquo;. And so this reads: a formula is either a
propositional variable, or the negation of a formula, or the conjunction of two
formulas, or &hellip;.</p>
<p>You should know that BNFs sometimes take different forms. Here is an equivalent
way of giving the BNF for the same language:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/bnf_alt.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="400px"  alt="" >

<p>but these are just notational differences.</p>
<p><i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Backus%60E2%6080%93Naur_form"
  target="_blank">BNFs</a> are a <strong>powerful
method for defining formal languages</strong>. They are frequently used in logic,
computer science, and AI. At this point, you know enough about how logical
grammars and BNFs work that you can check out your own examples. Here are some
suggestions for grammars to check out:</p>
<ul>
<li>
<p>Pick your favorite programming language (if you have one):
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://docs.Python.org/3/reference/grammar.html"
  target="_blank">Python</a> we mentioned above,
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://cs.wmich.edu/~gupta/teaching/cs4850/sumII06/The%6020syntax%6020of%6020C%6020in%6020Backus-Naur%6020form.htm"
  target="_blank">C</a>
is a popular low-level language,
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="http://tau-prolog.org/files/doc/grammar-specification.pdf"
  target="_blank">Prolog</a> is a
logic-based language.</p>
</li>
<li>
<p>A more complex AI example is <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Description_logic"
  target="_blank">description
logic</a>, which is a powerful KR
language for designing knowledge bases.</p>
</li>
<li>
<p>The <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://datatracker.ietf.org/doc/html/rfc5322"
  target="_blank">RFC</a> for emails contains
the BNF for valid email addresses. Check it out 🤓</p>
</li>
</ul>
<h2 id="parsing">Parsing<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>
<img src="https://logicalmethods.ai/textbook/formal-languages/img/ai_confused.png" class="rounded  float-start inert-img img-fluid m-2"  width="400px"  alt="" >
 Now that we&rsquo;ve formally defined what formal
languages and their formulas <em>are</em>, let&rsquo;s look at how computers (and also
<em>perhaps</em> humans, subconsciously) read these formulas.</p>
<p>This happens by means of a process known as <strong>parsing</strong>, which is the step-wise
reconstruction of formulas into their constitutive parts. Essentially,
&ldquo;unwinding&rdquo; the formula, by figuring out how it was constructed.</p>
<p>This is the first step of how computers <strong>understand</strong> formulas (computer
programs etc.) as it gives them a clear order in which to process its
components. Later, when we&rsquo;ll look into how the semantic processing of formulas
works—how we assign <em>meaning</em> to them—this will become very important.</p>
<p>To illustrate the idea of parsing, let&rsquo;s assume that our propositional language
has just the three propositional variables 
<span class="excalifont ">p, q, r</span>
. We can then understand the grammar of this language as the
collection of the following eight rules:</p>
<p>Essentially, this is a collection of eight rules:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/rewriting_rules.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="300px"  alt="" >

<p>Rules like this are sometimes called <em>rewrite rules</em>. The intuition is that starting from the abstract &lsquo;start&rsquo; symbol 
<span class="excalifont ">A</span>
, the rules allow you to rewrite 
<span class="excalifont ">A</span>
  to any formula in the language. So, any formula in the language can be <em>derived</em> by applying a finite number of choices from these rules.
For instance, to show that 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/neg_p_and_q.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
 is a formula in this language, we start with 
<span class="excalifont ">A</span>
 and, using the rules above, we rewrite this 
<span class="excalifont ">A</span>
 until we arrive at this formula. We can do this in four steps:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/rewriting_example.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="500px"  alt="" >

<p>To make this more insightful, we can turn this derivation into a so-called
<strong>parse tree</strong>, which is a very useful representation of the syntax of a
formula. A parse tree is a structure that is rooted in the abstract label 
<span class="excalifont ">A</span>
 that forms the base of our BNF definition of
the language. You can construct a tree by just following the derivation above,
step by step. Each application of a rule introduces a new branching, until there
is nothing left to do anymore. Here is how to construct the parse tree for the
derivation we gave for 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/neg_p_and_q.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
. We start with a node

<span class="excalifont ">A</span>
 and then look at the derivation to see which rule to
apply first. This is rule 4, which maps 
<span class="excalifont ">A</span>

to a new formula 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/neg_A.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
. For each new symbol we create a new branch:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/negation_tree.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="150px"  alt="" >

<p>Then, we apply rule 5 to the right-most branch. This rule rewrites this 
<span class="excalifont ">A</span>
 into <span class="excalifont">(A\land A)</span>, which creates five more branches:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/tree_negation_conjunction.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="250px"  alt="" >

<p>Then, we apply rule 1 to 
<span class="excalifont ">A</span>
 that is to the left of &ldquo;<span class="excalifont">\land</span>&rdquo;:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/tree_step_3.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="250px"  alt="" >

<p>Finally, we apply rule 2:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/tree_step_4.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="250px"  alt="" >

<p>This now is the parse tree corresponding to our derivation of 
<img src="https://logicalmethods.ai/textbook/formal-languages/img/neg_p_and_q.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
. The leaves of the tree spell out the formula, each branching is an
application of a rule from the BNF grammar.</p>
<p>For a computer it is essential to be capable of parsing a complex formula in
this way. This is because the parse of a formula gives us access to the logical
form. Say, that the propositions in this logical language are meant to give a
medical system crucial information about a patient. For instance, 
<span class="excalifont ">p, q</span>
, and 
<span class="excalifont ">r</span>
 each correspond to the proposition that states that the patient has a
certain symptom, call these symptoms

<span class="excalifont ">P</span>
,

<span class="excalifont ">Q</span>
, and

<span class="excalifont ">R</span>

, respectively. If we feed
the system the formula

<img src="https://logicalmethods.ai/textbook/formal-languages/img/neg_p_or_q_and_r.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
,
then we want the system to know
that the patient is showing symptom <span class="excalifont">R</span>, but not showing

<span class="excalifont ">P</span>
 or

<span class="excalifont ">Q</span>
.
It needs to
figure out that the sub-proposition

<img src="https://logicalmethods.ai/textbook/formal-languages/img/p_or_q.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
,
are negated, while
sub-proposition <span class="excalifont">r</span> is not. To do this, it needs to parse the formula correctly.
From the parse, it is clear that the disjunction

<img src="https://logicalmethods.ai/textbook/formal-languages/img/p_or_q.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
 is negated, but
that

<span class="excalifont ">r</span>
,
escapes the effect of that negation.</p>
<p>Parsing allows us to distinguish seemingly similar, but crucially different logical forms like:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/negation_scope.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="500px"  alt="" >

<p>A fundamental insight of logical theory is that when a grammar is properly
defined, we get what&rsquo;s known as <strong>unique readability</strong>. A formula has this
property when the grammar only provides a single parse tree for it. This is the
case for the examples we gave above. For instance, for

<img src="https://logicalmethods.ai/textbook/formal-languages/img/p_and_p_to_q.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
,
we don&rsquo;t have a choice in what rule to apply first when
we start our derivation. We cannot for instance apply rule 4 before we apply
rule 7. If we did, we would end up with a different formula. We do have some
choices later in the derivation. For instance, after applying rule 4, we could
have chosen to apply rule 5 to the 
<span class="excalifont ">A</span>
 to the
left of the

<img src="https://logicalmethods.ai/textbook/formal-languages/img/to.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
. But that is not a choice that affects the structure.
The parse tree would remain the same. In other words, all derivations of this
formula lead to the same tree.</p>
<p>Unique readability is of the utmost importance since if it fails, this means
that formulas are <strong>ambiguous</strong>. Since we said that avoiding ambiguity is one of
the motivations for the use of formal languages, this means that we need to take
special care in designing our grammar. Take the following grammar, for example
(note the absence of parentheses in the conjunction case):

<img src="https://logicalmethods.ai/textbook/formal-languages/img/bad_bnf.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="250px"  alt="" >

In this language, we can derive the following formula:

<img src="https://logicalmethods.ai/textbook/formal-languages/img/neg_p_and_q.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
.
Crucially, though, we can derive this in two distinct ways, corresponding
to the following two parse trees.</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/two_derivations.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="500px"  alt="" >

<p>Imagine we are building an AI system to regulate a train crossing. There is a
light stopping traffic from crossing the railway when it turns red and similarly
there is a light indicating the train should stop and wait with crossing the
road until that light turns green. Let&rsquo;s say we have trained a neural network to
regulate things as efficiently as possible, minimizing train delays and traffic
jams. Unfortunately, the neural network is not flawless. We need a rule-based
system to make sure the decisions made by the network are safe. To do this, we
translate the network&rsquo;s decisions to statements in a propositional logic and
compare these to rules that we want the system to obey. Let&rsquo;s say that

<span class="excalifont ">p</span>

means that the cars have a green light and

<span class="excalifont ">q</span>

means that the train has a green light.
We now want a rule that says that

<span class="excalifont ">p</span>
 and

<span class="excalifont ">q</span>

cannot be true at the same time.</p>
<p>As the two parse trees above show us, we have no way of doing this. If we state the rule as

<img src="https://logicalmethods.ai/textbook/formal-languages/img/neg_p_and_q.png" class="inert-img" height="24px"  style="ZgotmplZ" alt="" >
,
we end up with something that could be misunderstood. The two trees correspond
to two distinct derivations, which correspond to two different structures for
the same formula. In turn this means that the formula will have two
interpretations. On the right is the interpretation that would be handy for this
AI system: cars and trains do not have a green light at the same time. But if
the system instead adopts the structure on the left, we could end up with a
system that demands that trains have a green light while cars do not. Ambiguity
might just have created a huge traffic jam! This shows that the BNF above is
unsuitable as a formal language, since it fails the property of unique
readability. All this is why we need to be careful about the auxiliaries,
like

<img src="https://logicalmethods.ai/textbook/formal-languages/img/parentheses.png" class="inert-img" height="20px"  style="ZgotmplZ" alt="" >
,
which ultimately guarantee unique readability.</p>
<p>Parsing is an incredibly important subject in the foundations and practice of
programming, natural language processing (NLP), and elsewhere. We don&rsquo;t have
time to go into the details, but think of programming for a second. A
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Programming_language"
  target="_blank">programming language</a> is
essentially a tool to write down instructions for a computer in a human-readable
way. What happens &ldquo;under the hood&rdquo; is that the computer translates the program
you write into machine instructions (the proverbial 1&rsquo;s and 0&rsquo;s).</p>
<p>To ensure that the machine instructions really correspond to what you had in
mind when you wrote the program, the computer needs to understand <em>what you
meant</em>. Since a computer is deterministic and not <em>particularly</em> intelligent,
the only way it can do this is according to unambiguous instructions about what means what.</p>
<p>But clearly, we can&rsquo;t just write for each program what it means in machine
instructions-otherwise, what&rsquo;s the point of having the language in the first
place? Instead, we specify what the individual expressions of the language mean
and how combining them according to the grammar affects that meaning. In this
way, we guarantee that for each program we could possibly write, we can
translate it into machine instructions.</p>
<p>But to do so, we need to know which expressions occur in which order in the
program. To determine this is the role of the
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Parsing#Parser"
  target="_blank">parser</a>. This shows the
fundamental importance of parsing in programming and human-computer interaction.</p>
<h2 id="knowledge-representation">Knowledge representation<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>The development of large language models for generative AI has made a
significant impact on applications of AI. Because the interaction with such
models involves the medium of natural language, generative AI has a serious
ambiguity problem. For that reason, it is crucial for applications that require
precision that there are rule-based components that avoid the problems inherent
to natural language.</p>
<p>So, let&rsquo;s talk for a moment about the role of formal languages in AI
applications. We&rsquo;ve already talked about the fact that programming languages are
essentially just formal languages. So we can use the theory of formal languages
to understand this crucial aspect of human-machine interaction. Formal
languages, however, solve the problem of how to communicate with computers in a
much more general way. Their potential to avoid ambiguity means that formal
languages are essential to applications that require precision.</p>
<p>In 


<a href="https://logicalmethods.ai/textbook/logic-and-ai/"
   
   
   
   
   
   > Chapter 1. Logic and AI</a>

, we introduced so-called <em>expert systems</em>. These are systems
where vast bodies of &rsquo;expertise&rsquo; in a certain domain have been translated
into databases of formalised statements and (if-then) rules, in order to solve
complex problems concerning the domain in question. In such systems, there are
so many rules and facts that it is impossible for the human expert to keep track
of everything.</p>
<p>Designing expert systems involves translating existing expert knowledge into a
formal language that the AI expert system can work with. The process of
translating a natural language expression into a formal language is known as
<strong>formalization</strong>, which is a large part of the broader field known as
<strong>knowledge representation</strong>.</p>
<p>The idea is that we can represent basic facts about the world using logical
formulas of a suitable language and rules as if-then statements between such
statements. To illustrate, let&rsquo;s consider a toy example. Suppose that our friend
<span class="code" style="margin-right:-4px;vertical-align: text-top;transform-origin: 50%  50%;transform:rotate(180deg);display:inline-block">IA</span>
 is looking for an important letter, which should be somewhere
around this desk with two drawers:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/ai_drawers.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="700px"  alt="" >

<p>Suppose we have some information that we want to pass on to <span class="code" style="margin-right:-4px;vertical-align: text-top;transform-origin: 50%  50%;transform:rotate(180deg);display:inline-block">IA</span>
, who
understands the language of propositional logic. Here are a few claims in
natural language that we might want to convey, both in natural language and in
the formal language of propositional logic, where we stipulate that 
<span class="excalifont ">LEFT</span>
 is a propositional variable, which states
that the letter is in the left drawer, and 
<span class="excalifont ">RIGHT</span>
 is a propositional variable, which states that the letter is in
the right drawer:</p>

<img src="https://logicalmethods.ai/textbook/formal-languages/img/guidelines.png" class="rounded mx-auto my-4 d-block inert-img img-fluid"  width="100%"  alt="" >

<p>These examples can be a helpful guideline, but it&rsquo;s important to keep in mind
that formalization and knowledge representation is more of an <strong>engineering
problem</strong> than a mathematical problem: there is not always an absolutely right or
wrong answer (even though some cases are clearly right/wrong), it depends on the
purpose of the formalization, on the reasoning context, and other factors what
is a good or bad formalization.</p>
<p>Already the choice of language can be a difficult decision. We need to evaluate
a language&rsquo;s expressive power against the additional complexity that comes with
that. Sometimes, simple languages, like the language of propositional logic, are
the right choice, sometimes we need more complex languages.</p>
<p>Once we&rsquo;ve formalized our claims in a suitable formal language, we collect our
formalized knowledge in what&rsquo;s known as a <strong>knowledge bas (KB)</strong>. Generally
speaking, a KB is a way of storing formalized knowledge in such a way that any
agent—artificial or otherwise—can both <strong>ask</strong> the KB what is already known or
<strong>tell</strong> the KB new facts. From a logical perspective, it turns out, that we can
then think of a KB  as simply as set of formulas of a suitable language.</p>
<p>An expert system can generate unknown novel facts on the basis of a great many
applications of modus ponens and other patterns of valid inference. Conversely,
expert systems could be used to answer queries. This means that a user prompts
the system with a certain proposition (standing for some statement in the domain
of expertise) and the expert system would then search for a chain of inferences
either leading to that proposition or to its negation. Ultimately then, the
expert system can help the user understand whether something relevant to the
domain of expertise is true or not, and also why that conclusion can be drawn.</p>
<p>The concept of a KB is one of the fundamental concepts of the AI discipline
known as <strong>Knowledge Representation and Reasoning</strong>, and will accompany us
throughout the course</p>
<p>Currently, the term &rsquo;expert system&rsquo; is not used a lot anymore. However,
rule-based systems are still very popular applications of formal languages in
businesses and research in systems such as
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/WolframAlpha"
  target="_blank">WolframAlpha</a>. They are
(relatively) cheap to build and, importantly, they are fast and reliable. As we
hinted at above, they are also fully <em>transparent</em>, meaning that an expert
system doesn&rsquo;t just solve a complex problem, it can also provide a detailed
explanation of how it came to the solution, since it can show you the rules and
facts it used in order to reach it.</p>
<p>This is in stark contrast to generative AI, which relies on untraceable
statistical regularities in vast amounts of data. This lack of traceable
reasoning makes the reliability of generative AI questionable, thereby raising
question about its safe use. Even worse, it makes it less clear that AI can be
held accountable for the decisions it makes.</p>
<h2 id="further-readings">Further readings<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>An incredibly rich and extensive discussion of formal languages and their role
in logic is:</p>
<ul>
<li><i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://doi.org/10.1017/CBO9781139108010"
  target="_blank">Duthil Novaes, Catarina. 2012. Formal languages in logic. Cambridge
University Press</a></li>
</ul>
<p>From a linguistic perspective, a highly influential idea is Montague&rsquo;s idea to
understand &ldquo;English as a formal language&rdquo;:</p>
<ul>
<li><i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://doi.org/10.1515/9783111546216-007"
  target="_blank">Montague, Richard. 1968.English as a formal
language.</a></li>
</ul>
<p><strong>Notes:</strong></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>We can, of course, ad hoc add any individual set to our space as a
new object, but this strategy won&rsquo;t work forever. This is a result of
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Cantor%27s_theorem"
  target="_blank">Cantor&rsquo;s theorem</a>, which we unfortunately don&rsquo;t have time to explore.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>We couldn&rsquo;t even use a … notation. While we might understand that

<span class="excalifont ">{0,1,2,…}</span>
 is supposed to be
the set of all numerals because we recognize the pattern, there is no
known pattern for the primes that we could use.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>The driving force behind this definition is actually an application of
modus ponens. One instance of step 2 in the definition is: If 
<span class="excalifont ">1</span>
 is a numeral, then so is 
<span class="excalifont ">12</span>
. Now, since step 1 tells us
that 
<span class="excalifont ">1</span>
 is indeed a numeral it follows by modus ponens that 
<span class="excalifont ">12</span>
 is also a numeral.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


  </div>
   <p><em>Last edited: </em>03/09/2025</p>
</div>


<ul class="navbar-nav flex-row justify-content-between mt-auto">
  
  <li class="nav-item">
    <a href="/textbook/logic-and-ai/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-left"></i>
    </a>
    
  </li>
  <li class="nav-item">
    <button class="btn btn-back-to-top">
    <i class="bi bi-chevron-double-up"></i>
  </button>
  </li>
  <li class="nav-item">
    
    <a href="/textbook/valid-inference/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-right"></i>
    </a>
    
  </li>
</ul>

    </main>
    <footer class="align-self-center d-flex flex-column mt-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="footer-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="/about" aria-label="copyright-link">&copy; 2025 jkorbmacher et al. </a>
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link fs-6" href="https://github.com/jkorb/logicalmethods.ai" target="_blank"><i class="bi bi-github"></i></a>
      </li>
    </ul>
  </div>
</nav>
 
      <script src="https://logicalmethods.ai/js/helpers.js"></script>
      <script src="https://logicalmethods.ai/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
      
      
    </footer>
  </body>
</html>
