<!doctype html>
<html lang="en" data-bs-theme="light">
  <head>
    <meta charset="utf-8"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <title>logicalmethods.ai &ndash; FOL Inference </title>
    <link rel="icon" type="image/x-icon" href="https://logicalmethods.ai/favicon.ico"></link>
    <link href="https://logicalmethods.ai/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/icons/font/bootstrap-icons.min.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/layout.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/syntax_hl.css"></link>
    <link href="https://logicalmethods.ai/css/textbook.css" rel="stylesheet"></link>
    <style>
      
    :root {
      --chapter: "9";
    }

    </style>
    
      <link rel="stylesheet" href="https://logicalmethods.ai/katex/katex.min.css">
<script defer src="https://logicalmethods.ai/katex/katex.min.js"></script>
<script defer src="https://logicalmethods.ai/katex/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},     
        {left: '\\[', right: '\\]', display: true},   
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>


    
  </head>
  <body class="bg-black d-flex flex-column m-0 p-0">
    <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvas-nav" aria-labelledby="offcanvas-navLabel" data-bs-theme="dark" data-bs-backdrop="false">
  <div class="offcanvas-header">
    <div class="h5 offcanvas-title" id="offcanvas-navLabel">
      Browse course
    </div>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  
  <div class="offcanvas-body">
    <ul class="navbar-nav">
      
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/about/"><i class="bi-file-person-fill"></i> &nbsp;&nbsp; About</a>
          </div>
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link fw-bold active" href="/textbook/"><i class="bi bi-book"></i> &nbsp;&nbsp; Textbook</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/textbook/"
            id="navbarSectiontxt-home" data-bs-toggle="collapse"
            data-bs-target="#collapsetxt-home"  
            aria-expanded="true"
            aria-controls="collapsetxt-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse show" id="collapsetxt-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/conditionals/"
              >6. 
                <i class="bi bi-unlock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/proofs/"
              >7. 
                <i class="bi bi-unlock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/fol/"
              >8. 
                <i class="bi bi-unlock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                fw-bold active
                
                "
                href="/textbook/fol-inference/"
              >9. 
                <i class="bi bi-unlock-fill"></i>
                 FOL Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/many-valued/"
              >10. 
                <i class="bi bi-unlock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logic-based learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/slides/"><i class="bi bi-rocket-takeoff-fill"></i> &nbsp;&nbsp; Slides</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/slides/"
            id="navbarSectionsli-home" data-bs-toggle="collapse"
            data-bs-target="#collapsesli-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapsesli-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapsesli-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/teaser/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/conditionals/"
              >6. 
                <i class="bi bi-unlock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/proof/"
              >7. 
                <i class="bi bi-unlock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/fol/"
              >8. 
                <i class="bi bi-unlock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/fol-inference/"
              >9. 
                <i class="bi bi-unlock-fill"></i>
                 FOL Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/many-valued/"
              >10. 
                <i class="bi bi-unlock-fill"></i>
                 Many-valued Logic
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/exercises/"><i class="bi-gear-fill"></i> &nbsp;&nbsp; Exercises</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/exercises/"
            id="navbarSectionexe-home" data-bs-toggle="collapse"
            data-bs-target="#collapseexe-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseexe-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseexe-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/preamble/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/conditionals/"
              >6. 
                <i class="bi bi-unlock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/proof/"
              >7. 
                <i class="bi bi-unlock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/fol/"
              >8. 
                <i class="bi bi-unlock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/fol-inference/"
              >9. 
                <i class="bi bi-unlock-fill"></i>
                 FOL inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/assignments/"><i class="bi bi-house-gear-fill"></i> &nbsp;&nbsp; Assignments</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/assignments/"
            id="navbarSectionass-home" data-bs-toggle="collapse"
            data-bs-target="#collapseass-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseass-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseass-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/assignments/assignment_1/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Assignment 1 (due 09/19/2025)
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/assignments/assignment_2/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Assignment 2 (due 03/10/2025)
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      
      
      
    </ul>
  </div>
</div>



    <header class="align-self-center d-flex flex-column m-0 mb-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="header-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="https://logicalmethods.ai/">
    <img src="https://logicalmethods.ai/img/nav_id.png" class="inert-img img-fluid m-2" draggable="false" width="400px">
    </a>
    <button class="navbar-toggler border-0" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas-nav" aria-controls="offcanvas-nav">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
</nav>

      
      
    </header>
    
    <main class="align-self-center d-flex flex-column flex-fill bg-white m-md-1 p-0" data-bs-theme="light">
      <ul class="navbar-nav flex-row justify-content-center mt-2">

  <li class="nav-item">
    <a href="/textbook/" class="btn" style="font-size: 20pt;" tabindex="-1" role="button" aria-disabled="false">
      <i class="bi bi-house-up"></i>
    </a>
  </li>
</ul>
<div class="container chapter">
  <p>By: <em>Johannes Korbmacher</em></p>
  <div class="m-4"><h1 id="fol-inference">FOL Inference<button class="btn btn-back-to-top">
    
  </button>
</h1>
<hr>

<p>It turns out that automating inference in FOL is a <em>hard</em> problem.</p>
<p>Take our standard inference, for example:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/socrates_inference.png" class="mx-auto rounded d-block inert-img img-fluid"  width="400px"  alt="" >

<p>It&rsquo;s actually rather straight-forward to see that this inference is deductively
valid in FOL. Suppose, we&rsquo;ve got a model, <span class="excalifont">M</span>, where both premises are true,
that is:</p>
<ul>
<li><span class="excalifont">M 
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Mortal x)</span></li>
<li><span class="excalifont">M 
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
 Human Socrates</span></li>
</ul>
<p>If we unfold the former using the truth-conditions in models, we get:</p>
<ul>
<li>For all <span class="excalifont">d 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
D</span>, <span class="excalifont">M 
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
Human <code class="customCode">d</code> 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Mortal <code class="customCode">d</code></span>.</li>
</ul>
<p>But <span class="excalifont">
<img src="/img/llbracket.png" alt="Left semantic bracket" class="inline-icon" style="height:1.1em;width:auto;margin-right:-0.4em"/>
Socrates
<img src="/img/rrbracket.png" alt="Right semantic bracket" class="inline-icon" style="height:1.1em;width:auto;margin-left:-0.4em"/>

<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
D</span>. Since <span class="excalifont">Socrates</span> is
a name for <span class="excalifont">
<img src="/img/llbracket.png" alt="Left semantic bracket" class="inline-icon" style="height:1.1em;width:auto;margin-right:-0.4em"/>
Socrates
<img src="/img/rrbracket.png" alt="Right semantic bracket" class="inline-icon" style="height:1.1em;width:auto;margin-left:-0.4em"/>
</span>—by definition—we know
that:</p>
<ul>
<li><span class="excalifont">M
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
Human Socrates 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal Socrates</span></li>
</ul>
<p>But the second premise was that <span class="excalifont">M 
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
Human Socrates</span>. So by simple
Boolean reasoning—essentially just MP—we know that:</p>
<ul>
<li><span class="excalifont">M 
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
Mortal Socrates</span>.</li>
</ul>
<p>For this line of reasoning, we didn&rsquo;t need to think about what our domain looks
like, what the extensions of <span class="excalifont">Socrates</span>, <span class="excalifont">Human</span>, and <span class="excalifont">Mortal</span> are. What we&rsquo;ve
seen is that regardless of all these things: the truth of the premises in any
FOL model is sufficient for the truth of the conclusion. In other words, the
inference is deductively valid:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Mortal x), Human Socrates 
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
Mortal Socrates</div>
<p>The relative ease with which we showed the inference&rsquo;s validity might spark the
hope for a relatively straight-forward theory of mechanized FOL inference. We&rsquo;ve
developed a series of inference techniques for Boolean and propositional
reasoning, such as truth-tables, <code class="customCode">SAT</code>-solving, and natural deduction. We might
hope, at this point, that they just carry over to FOL <em>modulo</em> some adjustments
for the more complicated syntax and semantics.</p>
<p>But appearances are deceiving. First, note that we needed to think in a very
<em>human</em> way through the truth-conditions to see that the inference is valid. For
example, we realized that the denotation of <span class="excalifont">Socrates</span> lives in our domain, and
therefore satisfies the open formula <span class="excalifont">Human x
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal x</span>. But how could
a machine do that? Or, put differently, how can we <em>algorithmically</em> check for
the validity of an FOL inference?</p>
<p>
<img src="https://logicalmethods.ai/textbook/fol-inference/img/model_tower.png" class="rounded  float-start inert-img img-fluid m-2"  width="200px"  alt="" >

This is where the trouble begins. In propositional logic, we could just <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Brute-force_search"
  target="_blank">brute
force search</a> through all the
models of the premises using the truth-tables. But this doesn&rsquo;t work in FOL.
While in propositional logic, all that mattered for the truth of a formula is
which of its propositional variables are true, in FOL, we need to know more:
which objects there are, what the terms denote, and what the properties express.
But that means that not only do we need to search through all distributions of
truth-values over the atoms, we need to search through all through possible
<em>domains</em> and interpretations of vocabularies across them.</p>
<p>But there are <em>many</em> possible domains. <em>Every</em> set of objects could be the
domain of a model. And the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Von_Neumann_universe"
  target="_blank">universe of
sets</a> is &hellip; enormous to put
it mildly. At the very least, it&rsquo;s infinite, so we simply can&rsquo;t search through
it in finite time complexity.</p>
<p>That rules out brute force, but perhaps there could be <em>some</em> smart algorithm,
some <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Effective_method"
  target="_blank">effective method</a> that
solves the problem for us, that can figure out for any given FOL inference, in a
finite amount of time whether the inference is valid.—It turns out that the
answer is: there can&rsquo;t be!</p>
<p>
<img src="https://logicalmethods.ai/textbook/fol-inference/img/halting_problem.png" class="rounded  float-end inert-img img-fluid m-2"  width="300px"  alt="" >

This is a consequence of Church and <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Turing%27s_proof"
  target="_blank">Turing&rsquo;s
answer</a> to the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Halting_problem"
  target="_blank">halting
problem</a>. Without going into too
much detail, Curry and Turing independently showed that there can&rsquo;t be a single
algorithm that determines in a finite amount of time whether any given computer
program &ldquo;halts&rdquo;—meaning it doesn&rsquo;t get stuck in an &ldquo;<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Infinite_loop"
  target="_blank">infinite
loop</a>&rdquo;. The model of computation
that they used in this proof—the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Lambda_calculus"
  target="_blank">lambda
calculus</a> in Church&rsquo;s case and
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Turing_machine"
  target="_blank">Turing machines</a> in Turing&rsquo;s
case—is so general in nature that it encompasses any reasonable form of AI
algorithm we can think of. The details of the proof are out of scope for us, but
roughly the idea is that we can reduce the halting problem to a validity problem
in FOL. This proof is one of the great intellectual achievements of the
twentieth century and one of the ways in which research in pure logical theory
is highly relevant to current AI-research: we know that we shouldn&rsquo;t even try to
fully automate FOL inference.</p>
<p>What we <em>can</em> do is to deal with the consequences: we can tackle the question
what, given that we can&rsquo;t fully automate FOL inference, we can still achieve.
And it turns out that there&rsquo;s quite something. AI research has yielded a
toolbox of techniques for FOL reasoning, partially and fully automated, theorem
proving and checking. These tools are the basis for many recent advances in
domain-specific reasoning.</p>
<p>At the end of this chapter, you will be able to:</p>
<ul>
<li>
<p>use the method of
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Unification_%28computer_science%29"
  target="_blank">unification</a> to
find applications of FOL inference rules to quantified FOL formulas</p>
</li>
<li>
<p>transform FOL formulas into CNF and apply the resolution method to search for
countermodels</p>
</li>
<li>
<p>use natural deduction rules for the quantifiers to find logical proofs in FOL</p>
</li>
<li>
<p>verify such proofs in Lean</p>
</li>
</ul>
<h2 id="unification">Unification<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>Let&rsquo;s begin by looking at our example inference again:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Mortal x), Human Socrates 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
Mortal Socrates</div>
<p>We&rsquo;ve seen that the inference is valid using semantic reasoning, but now we&rsquo;ll
investigate how to show this using inference rules.</p>
<p>The aim is to apply <em>something like</em> MP to obtain the desired result. The idea
is to focus on the reasoning that if <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Mortal
x)</span> is true, then <span class="excalifont">Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal x</span> is true for all values of <span class="excalifont">x</span>. So
if we set the value of <span class="excalifont">x</span> to the denotation of <span class="excalifont">Socrates</span>, we can use this to
infer that <span class="excalifont">Human Socrates 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal Socrates</span> is true. Then, since <span class="excalifont">Human
Socrates</span> is true, we can use MP to infer that <span class="excalifont">Mortal Socrates</span> is true as well.</p>
<p>To cash this out, we need to think about how to reason with universally
quantified variables, like the <span class="excalifont">x</span> in this case. The powerful idea we&rsquo;ll be
developing throughout this chapter is that we can drop the quantifier

<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

  and reason with the open formula</p>
<div class="text-center my-4 excalifont">Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal x</div> instead. That is, our inference becomes:
<div class="text-center my-4 excalifont">(Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Mortal x), Human Socrates 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
Mortal Socrates</div>
<p>What remains to be done is to find a mechanizable way of determining that we
should set the value of <span class="excalifont">x</span> to Socrates. The way this works, formally, is using
the method of <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Unification_%28computer_science%29"
  target="_blank">unification</a>.</p>
<p>What we need to do in order to be able to apply <span class="excalifont">MP</span>, what we need to do is to
set the value of <span class="excalifont">x</span> in such a way that the <span class="excalifont">Human x</span> in
<span class="excalifont">Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal x</span> becomes <span class="excalifont">Human Socrates</span>. The obvious way of doing
this is to replace the <span class="excalifont">x</span> with the constant <span class="excalifont">Socrates</span> to obtain <span class="excalifont">Human
Socrates 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal Socrates</span>. Formally, this happens with the operation
of <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Substitution_%28logic%29"
  target="_blank">term substitution</a>,
which we looked at in the syntax of FOL. That is the substitution <span class="excalifont">[x /
Socrates]</span> gives us:</p>
<div class="text-center my-4 excalifont">(Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Mortal x)[x / Socrates] = Human Socrates 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal
Socrates</div>
<p>where our premise <span class="excalifont">Human Socrates</span> is <em>syntactically identical</em> to—not only
equivalent, but <em>literally identical</em> to—the antecedent of the conditional. A
substitution that has this property is called a <strong>unifier</strong> of the two
formulas with the <strong>unification partners</strong> <span class="excalifont">[Human Socrates, Human x]</span>.</p>
<p>That is, we can understand our inference as an instance of a special MP
variant for FOL:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/unified_mp.png" class="mx-auto rounded d-block inert-img img-fluid"  width="400px"  alt="" >

<p>That is, FOL allows us to infer the consequent of an open conditional with free
variable <span class="excalifont">x</span> from a
<abbr title="closed formula without free variables"><a  class="link-underline-opacity-0 link-body-emphasis"> sentence</a></abbr>
if there is a unifier which makes the antecedent of the conditional and the
sentence syntactically identical.</p>
<p>It&rsquo;s rather straight-forward to generalize this rule to antecedents with
multiple variables in the premise and antecedent. Take the following deductively
valid inference, for example:

<img src="https://logicalmethods.ai/textbook/fol-inference/img/ai_brothers.png" class="mx-auto rounded d-block inert-img img-fluid"  width="600px"  alt="" >
</p>
<p>To apply the method we&rsquo;ve just described, we&rsquo;d simply drop both universals and
use the unifier</p>
<div class="text-center my-4 excalifont">[x / 
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

I, y / <code class="customCode">KnowIt<span style="margin-left:-0.5em"></span>
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

&ThinSpace;</code>]</div>
which is a "double substitution", where both <span class="excalifont">x</span> and <span class="excalifont">y</span> are simultaneously
replaced, to apply the rule as follows:

<img src="https://logicalmethods.ai/textbook/fol-inference/img/ai_brothers_inf.png" class="mx-auto rounded d-block inert-img img-fluid"  width="400px"  alt="" >

<p>This gives us a first shot at FOL inference: we can generalize MP to inferences
with universally quantified conditionals using unification. It turns out that
unification is an extremely powerful method for automated inference. It is, for
example, also the method that underpins how
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://leanprover-community.github.io/"
  target="_blank">Lean</a> figures out &ldquo;under the hood&rdquo;
which disjunction you wanted to use in an application of <code class="customCode">Or<span
class="dark-green">.</span></span>inl</code>, for example.</p>
<p>Remember that the natural deduction inference from <span class="excalifont">A</span> to <span class="excalifont">A 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
B</span> using
<span class="excalifont">
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Intro</span> corresponds to the lean <code class="customCode">apply Or<span
class="dark-green">.</span></span>inl h</code>, where <code class="customCode">h : A</code> is a proof of <span class="excalifont">A</span>. Note
that you don&rsquo;t need to tell Lean here that you&rsquo;re other disjunct is supposed to
be <span class="excalifont">B</span>. If you later want to <code class="customCode">apply</code> MP-style reasoning with some premise <code class="customCode">g : (A <span
class="dark-green">∨</span> B) <span class="dark-green">→</span> C</code> to obtain a
proof of <span class="excalifont">C</span>, you do this with code like this:</p>

<img src="/img/lean_logo.png" alt="Lean_Logo" class="float-start" style="height:1em;width:auto;"/>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lean" data-lang="lean"><span class="line"><span class="cl"><span class="n">apply</span><span class="w"> </span><span class="n">g</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">apply</span><span class="w"> </span><span class="n">Or</span><span class="bp">.</span><span class="n">inl</span><span class="w"> </span><span class="n">h</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Lean figures out that the other disjunct in your application of <code class="customCode">Or<span
class="dark-green">.</span></span>inl</code> must have been <span class="excalifont">B</span> using unification.
Under the hood, when you apply the rule, it infers a proof of <code class="customCode">A 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 X</code>
for a meta-variable <code class="customCode">X</code>. Then, when you tell it to apply the proof of the
conditional <code class="customCode">(A <span class="dark-green">∨</span> B) <span
class="dark-green">→</span> C</code>, lean uses a unification algorithm to infer that
if <code class="customCode">X</code> is <code class="customCode">B</code>, the application is valid, and so it applies the unification and
continues. This is just one of the ways, in which unification-based algorithms
make our lives a little bit easier in artificial inference. It also allows us to
use the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Backward_chaining"
  target="_blank">backward chaining</a> and
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Forward_chaining"
  target="_blank">forward chaining</a> algorithms
when our KB contains suitable conditionals.</p>
<p>In practice, there are different algorithms for efficiently search for unifiers
for two first-order terms. The most basic one, due to
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/John_Alan_Robinson"
  target="_blank">Robinson</a>, you will explore
in the exercises. Importantly, the unifiability of two terms is a <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Decidability_%28logic%29"
  target="_blank">decidable
problem</a>: we can correctly
tell with a single algorithm in finitely many steps whether any two terms can be
unified or not.</p>
<p>But just like with propositional chaining, there are limitations to this method.
In propositional logic, we looked at conditionals with disjunctive antecedents
as an example, like in the inference:</p>
<div class="text-center my-4 excalifont">((RAIN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 WIND) 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 COLD)&emsp; (COLD 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
HEATING)&emsp; RAIN</div>
<p>In FOL, we also have 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
, so we have these kinds of inferences, but
there are also problems with quantifiers in conditionals. Consider the following
inference, for example:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/giant_inference.png" class="mx-auto rounded d-block inert-img img-fluid"  width="400px"  alt="" >

<p>This inference is straight-forwardly seen to be valid: If it&rsquo;s true that anyone
bigger than everyone is a giant, and <span class="excalifont">PolyphemOS</span> is bigger than everybody, then
<span class="excalifont">PolyphemOS</span> is a giant. In fact, applying our strategy of dropping all the
universals 
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

, we might think we could do the following:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/giant_unification.png" class="mx-auto rounded d-block inert-img img-fluid"  width="400px"  alt="" >

<p>This <em>looks</em> like a logical proof of the validity of the inference, but actually
something went wrong. To see this, consider the following inference:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/there_is_inference.png" class="mx-auto rounded d-block inert-img img-fluid"  width="400px"  alt="" >

<p>This inference is clearly deductively invalid: Even if it&rsquo;s true that anyone
bigger than everyone is a giant, the fact that <span style="margin-right:-4px;vertical-align: middle;transform-origin: 50%  49%;transform:rotate(180deg);display:inline-block">IE</span>
  is
bigger than <span class="excalifont">tinymouse</span> doesn&rsquo;t mean that <span style="margin-right:-4px;vertical-align: middle;transform-origin: 50%  49%;transform:rotate(180deg);display:inline-block">IE</span>
 is a giant.
It&rsquo;s rather simple to find a formal FOL countermodel to the inference.</p>
<p>But if we could just drop all universals like we just did for the inference
involving <span class="excalifont">PolyphemOS</span>, the following would seem to show that the inference is
valid:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/there_is_unification.png" class="mx-auto rounded d-block inert-img img-fluid"  width="400px"  alt="" >

<p>What went wrong here is that the <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y</span> was nested in the conditional
antecedent and doesn&rsquo;t really work like a &ldquo;real&rdquo; universal. To see this, we
transform the premise using the equivalence of <span class="excalifont">A
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
B</span> and <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A

<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
B</span>, which also holds in FOL:</p>
<ul>
<li><span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y BiggerThan x y 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x)</span> is
equivalent to <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 x Bigger Than x y 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x)</span>.</li>
</ul>
<p>That is, the premise says that everything is either <em>not</em> bigger than everything
or a giant. In fact, we can use the following FOL equivalence to transform this
even further:</p>
<ul>
<li><span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y BiggerThan x y</span> is equivalent to <span class="excalifont">
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 BiggerThan xy</span></li>
</ul>
<p>To say that <span class="excalifont">x</span> is not bigger than everything is to say that there&rsquo;s something
that <span class="excalifont">x</span> is not bigger than. Using this equivalence:</p>
<ul>
<li><span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 x Bigger Than x y 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x)</span>, and thus <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y BiggerThan x y 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x)</span>, is
equivalent to <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x(
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 Bigger Than x y 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x)</span>.</li>
</ul>
<p>Either there exists something that <span class="excalifont">x</span> is not bigger than, or <span class="excalifont">x</span> is a giant.</p>
<p>Writing the premise in this form explains why the simple unification-based
FOL-MP cannot be applied here, since there&rsquo;s an existential is involved. To
handle such more general inferences, we need to move to a more powerful system.</p>
<h2 id="fol-resolution">FOL Resolution<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>While there is no brute force, truth-table-style method for FOL, we <em>can</em> use
resolution to check for satisfiability and thus consequence—although there are
some caveats.</p>
<p>Note that once we&rsquo;ve defined the notion of a model and truth in a model for FOL,
we get the same relation between deductively valid inference and satisfiability
that we had in propositional logic:</p>
<div class="text-center my-4 excalifont">P₁, P₂, … 
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
C &emsp; if and only if &emsp; not <code class="customCode">SAT</code>{P₁, P₂, …, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
C }</div>
<p>Here, <span class="excalifont">P₁, P₂, …, C</span> can be any FOL formulas and the notion of a set being
satisfiable (or <code class="customCode">SAT</code>) is simply that there&rsquo;s a model, in which all the formulas
are true.—FOL resolution is a method for checking for <code class="customCode">SAT</code> in this sense.</p>
<p>
<img src="https://logicalmethods.ai/textbook/fol-inference/img/derivation_search.png" class="rounded  float-start inert-img img-fluid m-2"  width="200px"  alt="" >

So, just like in propositional logic, we can check for satisfiability to check
whether an inference is valid. And that&rsquo;s what FOL resolution does. The only
caveat here is that while in propositional logic, resolution is a decision
procedure—that is, it correctly tells us in finitely many steps <em>whether</em> a set
is satisfiable/an inference is valid—in FOL, the method is &ldquo;only&rdquo; sound and
complete: <em>if</em> we can derive an empty sequent or contradiction from a set using
resolution, we know its unsatisfiable, and for each unsatisfiable set <em>there is</em>
such a derivation. But crucially, as a consequence of Church and Turing&rsquo;s
theorem, there is no algorithm that in general is guaranteed to find the this
derivation—even if it exists. We still need to be &ldquo;smart&rdquo; about it. This puts a
damper on the ambition of fully automating FOL reasoning, but it also presents
an opportunity to develop smart algorithms that perform imitate human-level
skills—or even achieve <em>super</em>human abilities—at finding FOL derivations.</p>
<p>So, here&rsquo;s how FOL resolution works. In the simplest cases, we&rsquo;ve actually
already seen resolution at work in the FOL-MP with modus ponens: just like in
propositional logic, the simplest applications of resolution are just cases of
MP. The first step for implementing this involves re-writing. If we take our
inferences involving Socrates, after dropping the universal, we can transform
the conditional into a disjunction using the well-established equivalence
between <span class="excalifont">A
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
B</span> and <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
B</span>. We get:</p>
<div class="text-center my-4 excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
Human x
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
Mortal x</div>
<p>The other premise and negation are already of the right form:</p>
<div class="text-center my-4 excalifont">Human Socrates &emsp; 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
Mortal Socrates</div>
<p>With these transformations in place, we can move to sets like in the
propositional case and apply resolution rules to derive the empty set <span class="excalifont">{ }</span>:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/socrates_resolution.png" class="mx-auto rounded d-block inert-img img-fluid"  width="500px"  alt="" >

<p>The idea here is that we can resolve <em>on</em> two formulas just in case the can
be unified using a substitution such that the one becomes the negation of the
other. Here, we resolve on <span class="excalifont">Human Socrates</span> and <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
Human x</span> using the
substitution <span class="excalifont">[x/Socrates]</span>. This substitution needs to be applied to all the
remaining formulas in the two sets that we&rsquo;re resolving, which is why we retain
<span class="excalifont">Mortal Socrates</span> from <span class="excalifont">(Mortal x)[x/Socrates]</span>. Sometimes, there is no
substantial unification necessary, since the formulas are already resolved, as
in the last inference. The formulas we&rsquo;re eliminating in the resolution is also
called the <strong>pivot</strong> of the application.</p>
<p>For the general form of resolution, we need to talk about CNFs for FOL. Remember
that the resolution system assumes that all formulas are in <abbr title="conjunctive normal form"><a  class="link-underline-opacity-0 link-body-emphasis"> CNF</a></abbr>, which means that they are
conjunctions of disjunctions of literals. To carry this notion over to FOL, we
just need to adjust the notion of a
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Literal_%28mathematical_logic%29"
  target="_blank">literal</a>. In
propositional logic, a literal is a propositional vairable or its negation. In
FOL, it&rsquo;s simply an atomic formula or its negation. That is <div class="text-center my-4 excalifont">Human x, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
x = Socrates, BiggerThan Socrates fatherOf(y), &hellip; </div> are all
literals in the sense of FOL. That&rsquo;s it, this gives us the notion of a CNF for
FOL.</p>
<p>There is also a corresponding notion of a
<abbr title="disjunctive normal form"><a  class="link-underline-opacity-0 link-body-emphasis"> DNF</a></abbr>,
which in AI and automated inference is not as important as the CNF. This is
mainly because there is no truth-table style method for <code class="customCode">SAT</code>-solving in FOL,
which is one of the main things that DNF&rsquo;s are good for in propositional logic.
So, we&rsquo;ll focus on CNFs.</p>
<p>Just like in propositional logic, there&rsquo;s an re-write algorithm for transforming
any formula into CNF. Crucially, this transformation doesn&rsquo;t give us an
<em>equivalent</em> formula, but an
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Equisatisfiability"
  target="_blank"><strong>equi-satisfiable</strong></a>
formula, meaning that the CNF is satisfiable if and only if the original formula
is. The reason why we don&rsquo;t get full equivalence has to do with quantifiers.</p>
<p>
<img src="https://logicalmethods.ai/textbook/fol-inference/img/ai_quantifier_elimination.png" class="rounded  float-start inert-img img-fluid m-2"  width="200px"  alt="" >

Note that CNFs are, by definition, free of quantifiers. This means, we need when
we transform a formula into CNF, we need to <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Quantifier_elimination"
  target="_blank">eliminate the
quantifiers</a>—and this
cannot, in general, be done in such a way as to preserve strict equivalence. But
we <em>can</em> preserve satisfiability, which is all we need for our <code class="customCode">SAT</code>-based
approach.</p>
<p>Enough theory, let&rsquo;s look at how this works in practice. The algorithm is a
recursive re-writing with rules, just like before. In fact, all the re-write
rules from the propositional algorithm are also rules in FOL, we just add to
them. To remind ourselves, here&rsquo;s how the rewriting works in propositional
logic:</p>
<ol>
<li>
<p>We recursively rewrite all conditionals into disjunctions using:</p>
 <div class="text-center my-4 excalifont">r₀: A 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
B 
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 A 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
B</div>
</li>
<li>
<p>We recursively push all negations inward using:</p>
 <div class="text-center my-4 excalifont">r₁: 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
 A</div>
 <div class="text-center my-4 excalifont">r₂: 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
(A
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
B)
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
B</div>
 <div class="text-center my-4 excalifont">r₃: 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
(A
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
B)
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
B</div>
</li>
<li>
<p>We recursively transform disjunctions of conjunctions into conjunctions of disjunctions
using:</p>
 <div class="text-center my-4 excalifont">r₄: A 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
(B 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
C)
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
(A
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
B)
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
(A
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
C)</div>
 <div class="text-center my-4 excalifont">r₄': (A 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
B)
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
C
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
(A
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
C)
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
(B
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
C)</div>
</li>
</ol>
<p>To handle the quantifiers, we need to add new re-write rules. We discuss them in
turn. The conditional re-writing step, 1., stays the same. For the second step,
we add two quantifier rules:</p>
<ol start="2">
<li>
<p>We recursively push negations inward using <span class="excalifont">r₁—r₃</span> plus:</p>
<div class="text-center my-4 excalifont">r₆: 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x A
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>
 
x 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A</div>
<div class="text-center my-4 excalifont">r₇: 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x A
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>
 
x 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A</div>
</li>
</ol>
<p>Now, before we can go on, we need to make sure that there cannot be any
confusion about quantifier binding. Remember that formulas like the following
are valid FOL expressions:</p>
<div class="text-center my-4 excalifont">
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (Human x 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>
 
x(Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal x))</div>
<p>That is, different quantifiers can use the same variable. This can lead to
confusion when we drop quantifiers and needs to be avoided. The solution is to
re-formulate all formulas (equivalently) in such a way that each quantifier
occurrence in the formula uses a unique variable. So, for example, instead of
the previous formula, we write:</p>
<div class="text-center my-4 excalifont">
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (Human x 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>
 
y(Human y 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal y))</div>
<p>This sort of variable renaming is called <strong>α-renaming</strong> and happens in its own
step. In order to implement this, we first create two
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29"
  target="_blank">stack</a> of pairwise
distinct variables</p>
<div class="customBlock text-center my-4"><code class="customCode">
varx = [x₁, x₂, x₃, …]
<p>vary = [y₁, y₂, y₃, …]
</code></div></p>
<p>In practice, we just need for every quantifier occurrence in the formula a
separate variable, but for simplicity, we just assume that there&rsquo;s an infinite
stack. We use the operation called <code class="customCode">pop</code> to remove the first element from the
stack and return it. That is, <code class="customCode">pop [x₁, x₂, x₃, …]</code> returns <code class="customCode">x₁</code> and leaves the
stack as <code class="customCode">[x₂, x₃, …]</code>. Using this machinery, we implement the following re-write step:</p>
<ol start="3">
<li>
<p>We recursively re-name the variables using:</p>
 <div class="text-center my-4 excalifont">r₈: 
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x A
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

α A[x / α]<span class="excalifont">, where <code class="customCode">α = pop varx</code></div>
 <div class="text-center my-4 excalifont">r₉: 
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x A
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

α A[x / α]</span>, where <code class="customCode">α = pop vary</code></div>
</li>
</ol>
<p>That is, if at some point we come across a quantifier expression, we replace the
variable quantified over with the first variable from our stack and replace all
free occurrences of the variable originally quantified over with that variable
as well.</p>
<p>This re-write step gives us, for example:</p>
<div class="text-center my-4 excalifont">
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (Human x 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>
 
x(Human x 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal x))
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₁ (Human y₁ 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>
 
x₁(Human x₁ 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal y₁))</div> 
<p>If there are more variables involved, the variable naming get&rsquo;s more complex,
but every quantifier get&rsquo;s its own variable:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x( Human x
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y (
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

z(ParentOf x
z 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 ParentOf y z))) …</div>
<div class="text-center my-4 excalifont">…
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
…</div>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁( Human x₁
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₁ (
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₂(ParentOf x₁
x₂ 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 ParentOf y₁ x₂)))</div>
<p>There is a small complication, when we apply this step in resolution
<code class="customCode">SAT</code>-solving. We need the variables to be unique not only <em>within</em> a formula,
as in our example, but also <em>across</em> formulas. That is, when we have in our set
<span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x Human x</span> and <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x Mortal x</span> as separate formulas,
we need to transform them into something like <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁ Human x₁</span> and
<span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₂ Mortal x₂</span> (results may vary depending on how many other
variables occur in other formulas &ldquo;in between&rdquo;).</p>
<p>We solve this by applying the entire algorithm to all formulas in our
simultaneously, moving through the steps in unison and then sharing the variable
stack across the different formulas. The use of <code class="customCode">pop</code> prevents us from ever
using the same variable twice in the transformation.</p>
<p>So far, all our transformations where equivalent transformations in the sense
that the formula that comes out the other end is deductively equivalent to the
original formula—it always has the same truth-value in all models. This changes
in the next step, where we <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Quantifier_elimination"
  target="_blank">eliminate the
quantifiers</a>.</p>
<p>The process for eliminating universals <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

xᵢ</span> will be simple: we&rsquo;ll
just drop them. But first, we have to deal with the existentials using a
procedure known as
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Skolem_normal_form"
  target="_blank">Skolemization</a>, after the
logician <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Thoralf_Skolem"
  target="_blank">Thoralf Skolem</a>. This
procedure is rather complex and in practice, you&rsquo;ll typically &ldquo;play it by ear&rdquo;
and not apply the recursive algorithm we&rsquo;ll describe now. At the same time, it&rsquo;s
important to understand how the algorithm works to understand what happens in
resolution-based <code class="customCode">SAT</code>-solvers for FOL.</p>
<p>To illustrate the idea, let&rsquo;s take our formula from earlier:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y BiggerThan x y 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x)</div>
<p>After running through the transformation steps up to α-renaming, we arrive at
the formula:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁(
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₂
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 Bigger Than x₁ x₂ 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x₁)</div>
<p>What this formula says is that for each <span class="excalifont">x₁</span> either there exists an <span class="excalifont">x₂</span> which
<span class="excalifont">x₁</span> is not bigger than or, otherwise, <span class="excalifont">x₁</span> is a giant. We want to re-write this
fact—if not equivalently, at least
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Equisatisfiability"
  target="_blank">equi-satisfiably</a>—without
without using existential quantifiers. The crucial insight of Skolem&rsquo;s that
makes this possible is that all we need to do is to pick <em>some</em> object for each
<span class="excalifont">x₁</span>. That is, dependent on any value for <span class="excalifont">x₁</span>, we need to get an object that
behaves according to the formula. In mathematical terms, this means that there&rsquo;s
a <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Function_%28mathematics%29"
  target="_blank">function</a>, which picks
for every value of <span class="excalifont">x₁</span> such an object. This function, we can represent using a
so-called <strong>Skolem-function</strong>, which we shall write (in this case) as <code class="customCode">skolem¹</code>.
That is, we can write the formula as:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 Bigger Than x₁ <code class="customCode">skolem</code>(x₁) 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x₁)</div>
<p>While this formula is not equivalent to our original formula, it is
equi-satisfiable—there exists a model where the one is true iff there is one
where the other is. And if we now drop the universal quantifier, we&rsquo;re left with
a completely quantifier free formula:</p>
<div class="text-center my-4 excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 Bigger Than x₁ <code class="customCode">skolem</code>(x₁) 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x₁</div>
<p>This is the formula we can use for FOL resolution.</p>
<p>But in the more general case, a few things can happen that we need to discuss.
First, when there&rsquo;s more than one existential quantifier in a formula, then we
need have different <code class="customCode">skolem</code>-functions for each of them to guarantee
equi-satisfiability. Take the following, for example:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁(
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₁ BrotherOf x₁ y₁ 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₂ SisterOf x₁ y₂)</div>
<p>This formula says that everybody either has a brother or a sister.
After Skolemization, the formula becomes:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁(SiblingOf x₁ <code class="customCode">skolem₁</code> x₁ 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₂ SisterOf x₁ <code class="customCode">skolem₂</code> x₁)</div>
<p>The use of different <code class="customCode">skolem</code>-functions is necessary since if we&rsquo;d use the same
function, we&rsquo;d get:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁(SiblingOf x₁ <code class="customCode">skolem</code> x₁ 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₂ SisterOf x₁ <code class="customCode">skolem</code> x₁)</div>
<p>This would make the brother and sister the same person, since—obviously—<span class="excalifont"><code class="customCode">skolem</code> x₁ = <code class="customCode">skolem</code> x₁</span>.</p>
<p>And then, there&rsquo;s dependence on more than one universally quantified variable:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₂
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₁ CommonAncestor x₁ x₂ y₁</div>
<p>Every two people have a common ancestor. The Skolemization of this formula is:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₂ CommonAncestor x₁ x₂ (<code class="customCode">skolem</code> x₁ x₂)</div>
<p>Note: The parentheses are added for readability only.</p>
<p>We can now describe the general re-write rule of Skolemization. Watch out, this
will be rather complex. As I said, in practice, you mostly won&rsquo;t work through
the complex algorithm but transform directly. We assume that
for each arity <span class="excalifont">n</span>, we have a list of Skolem functions:</p>
<div class="customBlock text-center my-4"><code class="customCode">
skolemⁿ = [skolemⁿ₁, skolemⁿ₂, ...]
</code></div>
<p>In the case where <span class="excalifont">n = 0</span>, we call them Skolem <em>constants</em> and treat them as such.</p>
<p>Further, for the purpose of the recursion, we need to keep track of the
universally quantified variables that an existential depends on. We denote the
list of these variables (in order) by <code class="customCode">deps</code>. That is, in</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₁(
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x₂
FriendOf x₁ x₂ 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>
 
x₃
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₁ CommonEnemyOf x₁₃
x₃ y₁)</div>
once we get to the existential <span class="excalifont">
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₁</span>, we have <code class="customCode">deps = [ x₁, x₃ ]</code>.
<p>Note that if <code class="customCode">deps = [ ]</code>, then we use Skolem constants. For example,</p>
<div class="text-center my-4 excalifont">
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₁ Human y₁ 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y₂ Human y₂
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
 Human <code class="customCode">skolem⁰₁</code> 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Human <code class="customCode">skolem⁰₂</code></div>
<ol start="4">
<li>We recursively Skolemize the existential quantifiers using:</li>
</ol>
  <div class="text-center my-4 excalifont">r₁₀: 
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

yᵢ A
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
 A[ yᵢ / <code class="customCode">skolemᵢdeps</code>]</div>
<p>As we said, this re-write rule is rather complex, in practice relatively
straight-forward to work out.</p>
<p>Now that we&rsquo;ve eliminated the existentials, we can drop all the universal:</p>
<ol start="5">
<li>We recursively drop the universal quantifiers using:</li>
</ol>
  <div class="text-center my-4 excalifont">r₁₁: 
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

xᵢ A
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
 A</div>
<p>In the very last step, we distribute if necessary:</p>
<ol start="6">
<li>
<p>We recursively transform disjunctions of conjunctions into conjunctions of disjunctions
using:</p>
 <div class="text-center my-4 excalifont">r₄: A 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
(B 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
C)
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
(A
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
B)
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
(A
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
C)</div>
 <div class="text-center my-4 excalifont">r₄': (A 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
B)
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
C
<img src="/img/longrightarrow.png" alt="Long Rightarrow" class="inline-icon" style="height:1em;width:auto;"/>
(A
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
C)
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
(B
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
C)</div>
</li>
</ol>
<p>Applying rules 1—6 of this algorithm simultaneously for all formulas in a set,
yields a set of CNF formulas. These we can transform into sets of clauses and
like before and start apply resolution.</p>
<p>Take, for example, in our inference about <span class="excalifont">PolyphemOS</span>:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x(
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y BiggerThan x y 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x), 
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x BiggerThan PolyphemOS x
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
Giant PolyphemOS</div>
<p>In order to check this inference for validity, we check the following set for
satisfiability using FOL-resolution:</p>
<div class="text-center my-4 excalifont">{ 
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x(
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y BiggerThan x y 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x), 
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x BiggerThan PolyphemOS x, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
Giant PolyphemOS }</div>
<p>We get the following CNF formulas:</p>
<div class="text-center my-4 excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
BiggerThan x₁ <code class="customCode">skolem</code> x₁ 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x₁</div>
<div class="text-center my-4 excalifont">BiggerThan PolyphemOS x₂</div>
<div class="text-center my-4 excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
Giant PolyphemOS</div>
<p>Using FOL-resolution, we derive the empty sequent in two steps:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/polyphemOS_resolution.png" class="mx-auto rounded d-block inert-img img-fluid"  width="600px"  alt="" >

<p>If, instead, the second premise would have been <span class="excalifont">BiggerThan <code class="customCode"><span style="margin-right:-4px;vertical-align: middle;transform-origin: 50%  49%;transform:rotate(180deg);display:inline-block">IE</span>
</code>
tinymouse</span>, we&rsquo;d have ended up with:</p>
<div class="text-center my-4 excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
BiggerThan x₁ <code class="customCode">skolem</code> x₁ 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 Giant x₁</div>
<div class="text-center my-4 excalifont">BiggerThan <code class="customCode"><span style="margin-right:-4px;vertical-align: middle;transform-origin: 50%  49%;transform:rotate(180deg);display:inline-block">IE</span>
</code> tinymouse</div>
<div class="text-center my-4 excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
Giant <code class="customCode"><span style="margin-right:-4px;vertical-align: middle;transform-origin: 50%  49%;transform:rotate(180deg);display:inline-block">IE</span>
</code></div>
<p>And the resolution algorithm would have stopped after one application:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/failure_resolution.png" class="mx-auto rounded d-block inert-img img-fluid"  width="600px"  alt="" >

<p>Thus, we can prove that the inference is invalid, as desired.</p>
<p>To conclude the discussion, here&rsquo;s how FOL resolution can be formalized as a
general FOL inference rule:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/resolution.png" class="mx-auto rounded d-block inert-img img-fluid"  width="600px"  alt="" >

<p>Here <span class="excalifont">σ = [ x₁ / t₁ , x₂ / t₂ , &hellip;]</span> is a substitution, which unifies <span class="excalifont">B</span> and
<span class="excalifont">C</span>, that is: <div class="text-center my-4 excalifont">B σ = C σ</div></p>
<p>These are the basics of FOL resolution. Before we conclude our discussion, it&rsquo;s
worth remarking that FOL resolution is a sound and complete proof system for
FOL. That is, there is a derivation of the empty sequent from the CNFs of the
premises and the CNF of the negation of the conclusion if and only the inference
is valid. But in contrast to propositional logic, the system is <em>not</em> a decision
procedure: we cannot fully automate it as an algorithm and trust that it will
return the correct answer—valid or invalid—for any given inference. Let&rsquo;s try to
understand what can go wrong.</p>
<p>The problem is with inferences where the countermodel is necessarily infinite.
Take the following FOL formulas written in infix notation using the binary
predicate ≤, for example:</p>
<ol>
<li><span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y x ≤ y</span></li>
<li><span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 (x ≤ x)</span></li>
<li><span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

y
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

z((x ≤ y 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 y ≤ z) 
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
x ≤ z)</span></li>
</ol>
<p>If you think about what a model of these formulas looks like, you  notice that
it must contain an infinite sequence of objects, which successively get bigger
and bigger. The following is a graph-representation of such a model, where the
domain consists of the natural numbers <span class="excalifont">{0, 1, 2, &hellip;}</span> and <span class="excalifont">
<img src="/img/llbracket.png" alt="Left semantic bracket" class="inline-icon" style="height:1.1em;width:auto;margin-right:-0.4em"/>
≤
<img src="/img/rrbracket.png" alt="Right semantic bracket" class="inline-icon" style="height:1.1em;width:auto;margin-left:-0.4em"/>
</span> is simply the &ldquo;real&rdquo; smaller than relation on the</p>
<blockquote>
<p>numbers:</p></blockquote>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/inf_model.png" class="mx-auto rounded d-block inert-img img-fluid"  width="300px"  alt="" >

<p>Now, add any statement to 1.—3. that <em>doesn&rsquo;t</em> follow from them. For example,
<span class="excalifont">1 ≤ 0</span>. It really doesn&rsquo;t matter what this statement is, since if we apply
the resolution algorithm to the set containing 1., 2., 3., and <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
Prime
3</span>, it will never terminate. To see this, let&rsquo;s first transform the statements
into CNF set form. We get:</p>
<div class="text-center my-4 excalifont">{
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 (1 ≤ 0) }</div>
<div class="text-center my-4 excalifont">{ x₁ ≤ (<code class="customCode">skolem</code> x₁) } &emsp; { 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
( x₂ ≤ x₂) }</div>
<div class="text-center my-4 excalifont">{ 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 (x₃ ≤ x₄), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 ( x₄ ≤ x₅), x₃ ≤ x₅ }</div>
<p>Now suppose we implement our algorithm such that it always first tries to resolve on  <span class="excalifont">{ x₁ ≤ (<code class="customCode">skolem</code> x₁) } </span> and it begins with <span class="excalifont">{ 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 (x₃ ≤ x₄), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 ( x₄ ≤ x₅), x₃ ≤ x₅ }</span>. The following happens:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/infinite_loop.png" class="mx-auto rounded d-block inert-img img-fluid"  width="600px"  alt="" >

<p>We got stuck in an <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Infinite_loop"
  target="_blank">infinite loop</a>, which
means the algorithm never terminates and we never get the answer that the
conclusion doesn&rsquo;t follow. This doesn&rsquo;t mean that it <em>does</em> follow, we can easily
construct a countermodel, such as the one we&rsquo;ve just described above. But the
algorithm doesn&rsquo;t find it. Of course, with our superior human-intelligence™️, we
can see that this loop will occur and try to avoid it, but the bottom line of
the Church-Turing theorem is that we can&rsquo;t find a systematic, algorithmic way of
excluding such loops.</p>
<p>As you can see, the resolution algorithm gets quite involved and complex, even
at the general, example-driven level of description we&rsquo;ve used here. This is why
it&rsquo;s best left to computers. There are various industry-level implementations,
with various optimizations, which perform well at the tasks involved—much better
than humans could. For example, the method of validity checking we&rsquo;ve just
described is the basis for <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Prover9"
  target="_blank">Prover9</a>,
which is oftern used as a
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Benchmark_%28computing%29"
  target="_blank">benchmark</a> for FOL
automated theorem provers.</p>
<h2 id="natural-deduction-and-lean">Natural deduction and Lean<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>While FOL resolution is useful for computer implementations, it&rsquo;s not the most
straight-forward to work with when trying to write logical proofs for in a
human-readable way. For this, we need to look to natural deduction. There are
also sound and complete Hilbert calculi, sequent calculi, and tableaux systems
for FOL, but natural deduction is the system that most closely resembles
human-style inference. As such, it is the system that is most frequently used in
AI applications, such as <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Formal_verification"
  target="_blank">proof verification in
mathematics</a> or the more
recent advances in artificial mathematical reasoning using hybrid LLM-proof
assistant systems.</p>
<p>The natural deduction system for FOL extends the system for propositional logic
with four new rules:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/natural_deduction_rules.png" class="mx-auto rounded d-block inert-img img-fluid"  width="300px"  alt="" >

<p>Each of these rules has some special side-conditions, which require some
explanation. Let&rsquo;s discuss them in turn.</p>
<p>The first rule, <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 Intro</span>, has the side-condition that
the variable <span class="excalifont">x</span> may not occur free in any undischarged assumption the we&rsquo;ve
used to derive <span class="excalifont">A(x)</span>. The idea is that if we can derive <span class="excalifont">A(x)</span> without making any
assumptions about <span class="excalifont">x</span>, this means that the argument holds for <em>any</em> <span class="excalifont">x</span>. Here&rsquo;s
an example of the rule at work:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/forall_intro.png" class="mx-auto rounded d-block inert-img img-fluid"  width="300px"  alt="" >

<p>This is a rather trivial inference, but it illustrates the idea well. We can
show that if <span class="excalifont">x</span> is human, then <span class="excalifont">x</span> is human without any open assumptions left
using <span class="excalifont">
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Intro</span>. Since this proof doesn&rsquo;t assume anything about <span class="excalifont">x</span>, we
conclude that it holds for <em>all</em> <span class="excalifont">x</span>. Every human is human is a logical truth,
we can proof without any undischarged assumptions.</p>
<p>For a slightly more interesting application, we first need to talk about <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 Elim</span>. This rule is perhaps the most straight-forward one: it allows
us to infer from a universal statement that holds for all <span class="excalifont">x</span>, that it holds for
any specific object, designated by any term <span class="excalifont">t</span>. For example, it gives us the
inference:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/forall_elim.png" class="mx-auto rounded d-block inert-img img-fluid"  width="400px"  alt="" >

<p>There is a side-condition with this rule as well: we can use any term <span class="excalifont">t</span> <em>as
long as</em> it is not bound after the substitution. This blocks, for example, the
following invalid inference from being an instance of <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 Elim</span>:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/variable_capture.png" class="mx-auto rounded d-block inert-img img-fluid"  width="300px"  alt="" >

<p>From everyone being the child of someone, it doesn&rsquo;t follow that someone is their own child. The side-condition blocks this invalid rule application.</p>
<p>In combination, <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 Intro</span> and <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 Elim</span> can be used to
prove some more interesting logical laws of FOL, such as the following:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x(Black x 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 White x)
<img src="/img/v_dash.png" alt="nvdash" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x Black x 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>
 
x White x</div>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/and_distribution.png" class="mx-auto rounded d-block inert-img img-fluid"  width="800px"  alt="" >

<p>The rule <span class="excalifont">
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 Intro</span> is also relatively straight-forward:
it allows us to infer that there exists an object satisfying a property from
any concrete object instantiating that property. For example, we have:</p>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/existential_intro.png" class="mx-auto rounded d-block inert-img img-fluid"  width="500px"  alt="" >

<p>There are no side-conditions for this rule. There <em>are</em> conditions for the <span class="excalifont">
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

Elim</span> rule. This rule captures the idea that what we can infer from an
existential claim is what we can infer from some arbitrary instance of the
existential. All we know is that <em>some</em> object satisfies the property. If from
this assumption, without assuming anything else about that object, we can derive
a conclusion, we can infer that conclusion from the existential. This idea is
captured in the side-condition that the constant <span class="excalifont">c</span> in the assumption, may not
be used anywhere else in the derivation.</p>
<p>Here&rsquo;s a valid inference using the rule:</p>
<div class="text-center my-4 excalifont">
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x Black x
<img src="/img/v_dash.png" alt="nvdash" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x (Black x 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>

White x)</div>

<img src="https://logicalmethods.ai/textbook/fol-inference/img/existential_elim.png" class="mx-auto rounded d-block inert-img img-fluid"  width="400px"  alt="" >

<p>If there&rsquo;s a black object, then there&rsquo;s an object that is black or white—namely
that unspecified object that is black.</p>
<p>The introduction and elimination rules for 
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 and 
<img src="/img/exists.png" alt="exists" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

 are
together sound and complete for FOL: <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/G%60C3%60B6del%27s_completeness_theorem"
  target="_blank">Gödel&rsquo;s completeness
theorem</a>
entails that for every deductively valid inference there exists a corresponding
natural deduction derivation and <em>vice versa</em>. Of course, there cannot be a
sure-fire way of finding such a derivation as this would contradict the
Church-Turing theorem.</p>
<p>To conclude our discussion of FOL—and classical deductive logic in general—let&rsquo;s
look at how we can verify FOL inference in Lean. The <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Curry%60E2%6080%93Howard_correspondence"
  target="_blank">Curry-Howard
Correspondence</a>,
which we&rsquo;ve taken as the starting point for our ventures into proof verification
in propositional logic, extends in a natural way to FOL.</p>
<p>Remember that in propositional logic, we used the type <code class="customCode"><span
class="dark-red">Prop</span></code> to model propositions that are true or false in
Lean. In FOL, we need to extend this setting with terms and predicates that we
apply to them. For this purpose, we introduce a new kind of type, the
<code class="customCode">Term</code>-type, which contains all the objects that we talk about. A <em>(unary)
predicate</em>, then, can be understood as a function from terms to propositions,
formally an object of the type <code class="customCode">Term <span
class="dark-green">→</span> <span class="dark-red">Prop</span></code>. The idea
is if we apply a predicate, like <span class="excalifont">Human</span>, to a term, like <span class="excalifont">Socrates</span>, then we
obtain a proposition, namely <span class="excalifont">Human Socrates</span>. Here is how we&rsquo;d declare <span class="excalifont">Black</span>
and <span class="excalifont">White</span> as unary predicates in Lean.</p>

<img src="/img/lean_logo.png" alt="Lean_Logo" class="float-start" style="height:1em;width:auto;"/>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lean" data-lang="lean"><span class="line"><span class="cl"><span class="w"> </span><span class="kn">variable</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">Black</span><span class="w"> </span><span class="n">White</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Just like for each intro and elim rule of natural deduction there was a
corresponding pair of Lean rules, we have Lean rules for the introduction and
elimination rules for the quantifiers.</p>
<p>Let&rsquo;s begin with <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

Intro</span>. Essentially, Lean treats the universal
quantifier just like the existential: what we need to show is that from the
assumption of an arbitrary <span class="excalifont">x</span>, we can derive a proof the proposition in
question—then we can conclude that the property holds for all <span class="excalifont">x</span>. Here&rsquo;s the
Lean proof that corresponds to our simple inference which shows that all humans
are human:</p>

<img src="/img/lean_logo.png" alt="Lean_Logo" class="float-start" style="height:1em;width:auto;"/>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lean" data-lang="lean"><span class="line"><span class="cl"><span class="kn">variable</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">Human</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∀</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="bp">=</span><span class="w"> </span><span class="k">by</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">intro</span><span class="w"> </span><span class="n">x</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">intro</span><span class="w"> </span><span class="n">human_x</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">exact</span><span class="w"> </span><span class="n">human_x</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Click this
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://live.lean-lang.org/#codez=G4QwTgliBGA2CmACAFIgKvMBbRAudAngA5ICUKAEgK5YgB2e6mOgSYSIAKYA9kaQFB94ADxBYiCRoAAiREIA0iarQZDEbRfRl4AvImgE&#43;iRBDoAXbjINHT5gBY16AfSGXhIAMYnEdpU6A"
  target="_blank">link</a>
to run this code in your browser.</p>
<p>That is, Lean treats a proof of a universally quantified statement as a kind of
conditional: if <span class="excalifont">x</span> is an arbitrary object, then <span class="excalifont">x</span> is human if it is human.</p>
<p>Correspondingly, the rule of <span class="excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

Elim</span> corresponds application: to
infer an instance from a universal quantifier, we take</p>
<p>Here, for example, is the Lean verification of our inference:</p>
<div class="text-center my-4 excalifont">
<img src="/img/forall.png" alt="forall" class="inline-icon" style="height:1em;width:auto;margin-right:-0.4em"/>

x(Human x
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
Mortal x)
<img src="/img/v_dash.png" alt="nvdash" class="inline-icon" style="height:1em;width:auto;"/>
Human Socrates
<img src="/img/to.png" alt="Implication" class="inline-icon" style="height:1em;width:auto;"/>
 Mortal Socrates</div>

<img src="/img/lean_logo.png" alt="Lean_Logo" class="float-start" style="height:1em;width:auto;"/>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lean" data-lang="lean"><span class="line"><span class="cl"><span class="kn">variable</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">Human</span><span class="w"> </span><span class="n">Mortal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">example</span><span class="w"> </span><span class="o">(</span><span class="n">Socrates</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Term</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∀</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">Mortal</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="n">Socrates</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="n">Mortal</span><span class="w"> </span><span class="n">Socrates</span><span class="o">:</span><span class="bp">=</span><span class="w"> </span><span class="k">by</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">apply</span><span class="w"> </span><span class="n">h</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Click this
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://live.lean-lang.org/#codez=G4QwTgliBGA2CmACAFIgKvMBbRAudAngA5ICUKAEgK5YgB2iAsgPZgAuIse6mOgSYSIACmGZFSAKHHwAHiCxEEKAMrMAxmBBt4AZ24Zs5ZAAtugACJE0gDSJqtBtMQCW7ThfL5b9RCvWadjplYOLh8NLW1cAF5EaAJxREQQIgUCRCMgA"
  target="_blank">link</a>
to run this code in your browser.</p>
<p>Our more complex proof of everything&rsquo;s black and everything&rsquo;s white from
everything&rsquo;s black and white is verified like this:</p>

<img src="/img/lean_logo.png" alt="Lean_Logo" class="float-start" style="height:1em;width:auto;"/>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lean" data-lang="lean"><span class="line"><span class="cl"><span class="kn">variable</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">Black</span><span class="w"> </span><span class="n">White</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∀</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">Black</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">∧</span><span class="w"> </span><span class="n">White</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="bp">∀</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">Black</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="bp">∧</span><span class="w"> </span><span class="o">(</span><span class="bp">∀</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">White</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="bp">=</span><span class="w"> </span><span class="k">by</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">apply</span><span class="w"> </span><span class="n">And</span><span class="bp">.</span><span class="n">intro</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="bp">·</span><span class="w"> </span><span class="n">intro</span><span class="w"> </span><span class="n">x</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">apply</span><span class="w"> </span><span class="n">And</span><span class="bp">.</span><span class="n">left</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">exact</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">x</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="bp">·</span><span class="w"> </span><span class="n">intro</span><span class="w"> </span><span class="n">x</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">apply</span><span class="w"> </span><span class="n">And</span><span class="bp">.</span><span class="n">right</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">exact</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">x</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Click this
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://live.lean-lang.org/#codez=G4QwTgliBGA2CmACAFIgKvMBbRAudAngA5ICUKAQrCAMYDWiA6gBYQAuS&#43;G2igSYSIAFMAHsipAFDj4ADxBYiCFMzyJAAESJpAGkRVaDaYkDkRE1YcNicvmTqtO6vQ3lj1jdpbsk0ywF5E0AuKIiCBECgSIAIIAdgAmAHQQUWwigYgA7YiJycIaqUEhYZGxcQgAZmyIeYgytBXK0qkZWSK5QfmhsOHR8ZAA5swVVTU0dRpAA"
  target="_blank">link</a>
to run this code in your browser.</p>
<p>Finally, for the existential quantifier, we have the tactics <code class="customCode">Exists<span
class="dark-green">.</span>intro</code> and <code class="customCode">Exists<span
class="dark-green">.</span>elim</code>. The tactic <code class="customCode">Exists<span
class="dark-green">.</span>elim</code> takes as arguments a proof of a disjunction and
a proof of a conclusion from the assumption that an arbitrary object (which
needs to be <code class="customCode">intro</code>&lsquo;ed) has the property in question. <code class="customCode">Exists<span
class="dark-green">.</span>elim</code> just requires a proof of an instance.</p>
<p>Here&rsquo;s how they work in action in our combined inference to show that if there&rsquo;s
a black thing, there&rsquo;s a black or white thing:</p>

<img src="/img/lean_logo.png" alt="Lean_Logo" class="float-start" style="height:1em;width:auto;"/>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lean" data-lang="lean"><span class="line"><span class="cl"><span class="kn">variable</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">Black</span><span class="w"> </span><span class="n">White</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="bp">→</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∃</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">Black</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∃</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">Black</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">∨</span><span class="w"> </span><span class="n">White</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="bp">=</span><span class="w"> </span><span class="k">by</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">apply</span><span class="w"> </span><span class="n">Exists</span><span class="bp">.</span><span class="n">elim</span><span class="w"> </span><span class="n">h</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="bp">·</span><span class="w"> </span><span class="n">intro</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">black_c</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">apply</span><span class="w"> </span><span class="n">Exists</span><span class="bp">.</span><span class="n">intro</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">apply</span><span class="w"> </span><span class="n">Or</span><span class="bp">.</span><span class="n">inl</span><span class="w"> </span><span class="n">black_c</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Click this
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://live.lean-lang.org/#codez=G4QwTgliBGA2CmACAFIgKvMBbRAudAngA5ICUKAQrCAMYDWiA6gBYQAuS&#43;G2igSYSIAFMAHsipAFDj4ADxBYiCFMzyJAwESJpAGkRVaDaeXyqtO6vQ2JAFERNWHC7gC8iaAXGJEIIgoKIAotIgAZzZAgDp4WAgcZjdEAHbECAA7NhFEGmczOgB9Glj3T28/AOCw5NThfI8vWB8AeTBQ5NhMvVygA"
  target="_blank">link</a>
to run this code in your browser.</p>
<p>There is, of course, much more to know about the use of classical deductive
logic in AI and its verification, but we&rsquo;ll leave it at that. Next, we turn to
different realms—namely <em>non-classical</em> logic.</p>


  </div>
   <p><em>Last edited: </em>10/13/2025</p>
</div>


<ul class="navbar-nav flex-row justify-content-between mt-auto">
  
  <li class="nav-item">
    <a href="/textbook/fol/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-left"></i>
    </a>
    
  </li>
  <li class="nav-item">
    <button class="btn btn-back-to-top">
    <i class="bi bi-chevron-double-up"></i>
  </button>
  </li>
  <li class="nav-item">
    
    <a href="/textbook/many-valued/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-right"></i>
    </a>
    
  </li>
</ul>

    </main>
    <footer class="align-self-center d-flex flex-column mt-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="footer-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="/about" aria-label="copyright-link">&copy; 2025 jkorbmacher et al. </a>
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link fs-6" href="https://github.com/jkorb/logicalmethods.ai" target="_blank"><i class="bi bi-github"></i></a>
      </li>
    </ul>
  </div>
</nav>
 
      <script src="https://logicalmethods.ai/js/helpers.js"></script>
      <script src="https://logicalmethods.ai/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
      
      
    </footer>
  </body>
</html>
