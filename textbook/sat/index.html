<!doctype html>
<html lang="en" data-bs-theme="light">
  <head>
    <meta charset="utf-8"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <title>logicalmethods.ai &ndash; Boolean satisfiability </title>
    <link rel="icon" type="image/x-icon" href="https://logicalmethods.ai/favicon.ico"></link>
    <link href="https://logicalmethods.ai/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/icons/font/bootstrap-icons.min.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/layout.css"></link>
    <link href="https://logicalmethods.ai/css/textbook.css" rel="stylesheet"></link>
    <style>
      
    :root {
      --chapter: "5";
    }

    </style>
    
      <link rel="stylesheet" href="https://logicalmethods.ai/katex/katex.min.css">
<script defer src="https://logicalmethods.ai/katex/katex.min.js"></script>
<script defer src="https://logicalmethods.ai/katex/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},     
        {left: '\\[', right: '\\]', display: true},   
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>


    
  </head>
  <body class="bg-black d-flex flex-column m-0 p-0">
    <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvas-nav" aria-labelledby="offcanvas-navLabel" data-bs-theme="dark">
  <div class="offcanvas-header">
    <div class="h5 offcanvas-title" id="offcanvas-navLabel">
      Browse course
    </div>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  
  <div class="offcanvas-body">
    <ul class="navbar-nav"><li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link fw-bold active" href="/textbook/"><i class="bi bi-book"></i> &nbsp;&nbsp; Textbook</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/textbook/"
            id="navbarSectiontxt-home" data-bs-toggle="collapse"
            data-bs-target="#collapsetxt-home"  
            aria-expanded="true"
            aria-controls="collapsetxt-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse show" id="collapsetxt-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item " href="/textbook/logic-and-ai/">1. Logic and AI</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/valid-inference/">2. Valid Inference</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/formal-languages/">3. Formal languages</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/boolean/">4. Boolean algebra</a>
            </li>
            
            <li>
              <a class="dropdown-item fw-bold active" href="/textbook/sat/">5. Boolean satisfiability</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/conditionals/">6. Logical conditionals</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/proofs/">7. Logical proofs</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/fol/">8. FOL</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/fol-inference/">9. FOL Inference</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/many-valued/">10. Many-valued logics</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/probability/">11. Logic and probability</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/textbook/learning/">12. Logic-based learning</a>
            </li>
            </ul>
        </div>
        
      </li>
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/slides/"><i class="bi bi-rocket-takeoff-fill"></i> &nbsp;&nbsp; Slides</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/slides/"
            id="navbarSectionsli-home" data-bs-toggle="collapse"
            data-bs-target="#collapsesli-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapsesli-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapsesli-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item " href="/slides/logic-and-ai/">1. Logic and AI</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/valid-inference/">2. Valid inference</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/formal-languages/">3. Formal languages</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/boolean/">4. Boolean algebra</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/sat/">5. Boolean satisfiability</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/conditionals/">6. Logical conditionals</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/proof/">7. Logical proofs</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/fol/">8. FOL</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/fol-inference/">9. FOL inference</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/many-valued/">10. Many-valued logics</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/probability/">11. Logic and probability</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/slides/learning/">12. Logical learning</a>
            </li>
            </ul>
        </div>
        
      </li>
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/exercises/"><i class="bi-gear-fill"></i> &nbsp;&nbsp; Exercises</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/exercises/"
            id="navbarSectionexe-home" data-bs-toggle="collapse"
            data-bs-target="#collapseexe-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseexe-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseexe-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item " href="/exercises/logic-and-ai/">1. Logic and AI</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/valid-inference/">2. Valid inference</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/formal-languages/">3. Formal languages</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/boolean/">4. Boolean algebra</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/sat/">5. Boolean satisfiability</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/conditionals/">6. Logical conditionals</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/proof/">7. Logical proofs</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/fol/">8. FOL</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/fol-inference/">9. FOL inference</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/many-valued/">10. Many-valued logics</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/probability/">11. Logic and probability</a>
            </li>
            
            <li>
              <a class="dropdown-item " href="/exercises/learning/">12. Logical learning</a>
            </li>
            </ul>
        </div>
        
      </li>
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/about/"><i class="bi-file-person-fill"></i> &nbsp;&nbsp; About</a>
          </div>
      </li>
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/tutoraat/"> &nbsp;&nbsp; </a>
          </div>
      </li>
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/verdiepingspakketten/"> &nbsp;&nbsp; </a>
          </div>
      </li>
      <hr>
      
    </ul>
  </div>
</div>

    <header class="align-self-center d-flex flex-column m-0 mb-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="header-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="https://logicalmethods.ai/"><span style="margin-right:-4px;vertical-align: middle;transform-origin: 50%  49%;transform:rotate(180deg);display:inline-block">IA</span>
<i class="bi bi-caret-right-fill"></i>logicalmethods.ai</a>
    <button class="navbar-toggler border-0" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas-nav" aria-controls="offcanvas-nav">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
</nav>

      
      
    </header>
    
    <main class="align-self-center d-flex flex-column flex-fill bg-light m-md-1 p-0" data-bs-theme="light">
      <ul class="navbar-nav flex-row justify-content-between mt-2">
  
  <li class="nav-item">
    <a href="/textbook/boolean/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-left"></i>
    </a>
    
  </li>
  <li class="nav-item">
    <a href="/textbook/" class="btn " tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-house-up"></i>
    </a>
  </li>
  <li class="nav-item">
    
    <a href="/textbook/conditionals/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-right"></i>
    </a>
    
  </li>
</ul>
<div class="container chapter">
  <p>By: <em>Johannes Korbmacher</em></p><h1 id="boolean-satisfiability">Boolean satisfiability<button class="btn btn-back-to-top">
    
  </button>
</h1>
<hr>

<p>In the last chapter, you learned about 


<a href="https://logicalmethods.ai/textbook/boolean/"
   
   
   
   
   
   >
Boolean algebra</a>

 and its role as fundamental laws of
reasoning and computation. In this chapter, we&rsquo;ll further explore the
applications of Boolean algebra in AI.</p>
<p>In particular, you&rsquo;ll learn about how to efficiently test for valid inference in
Boolean algebra. First, we&rsquo;ll discuss the &ldquo;naive&rdquo; <a href="#truth-tables">truth-table
method</a>, which suffers from the problem of <a href="https://en.wikipedia.org/wiki/Combinatorial_explosion"
  target="_blank">combinatorial
explosion</a>. Then you&rsquo;ll
learn about a more efficient method for validity checking, which is known as the
<a href="#dpll">Davis–Putnam–Logemann–Loveland (DPLL)</a> algorithm. This methods requires
you to know about <a href="#normal-forms">normal forms</a>, so we&rsquo;ll cover those, too.</p>
<p>The <a href="https://en.wikipedia.org/wiki/DPLL_algorithm"
  target="_blank">DPLL algorithm</a> is the basis
for many modern AI applications, especially in planning and diagnosis. You&rsquo;ll
explore some of these applications in the exercises.</p>
<h2 id="validity-and-satisfiability">Validity and Satisfiability<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>The problem that we&rsquo;re tackling is how to <strong>computationally and efficiently</strong>
test for valid inference. Why is this a problem?</p>
<p>Remember from 


<a href="https://logicalmethods.ai/textbook/valid-inference//#semantic-methods-for-deduction"
   
   
   
   
   
   > Chapter 2. Valid inference </a>

 that valid inference is truth-preservation from premises to
conclusion:</p>
<p>$$P_1,P_2,\dots\vDash C\Leftrightarrow [P_1]\cap [P_2]\cap \dots\subseteq [C]$$</p>
<p>In 


<a href="https://logicalmethods.ai/textbook/boolean//#validity"
   
   
   
   
   
   >
Chapter 4.5 </a>

, we implemented this definition in the context of
Boolean algebras. In this setting, the above condition is equivalent to saying
that:
$$P_1,P_2,\dots\vDash C\Leftrightarrow \text{ for all }\nu,\text{ if
}\nu(P_1)=1, \nu(P_2)=1\dots\text{, then }\nu(C)=1.$$</p>
<p>In words, this means that the inference is valid iff for all Boolean valuations,
where the premises are all true (have value 1), the conclusion is also true
(has value 1). Using this definition, we could formally calculate the validity
of an inference.</p>
<p>In 


<a href="https://logicalmethods.ai/textbook/boolean//#validity"
   
   
   
   
   
   > Chapter 4.5 </a>

, we went through an example calculation to show that:</p>
<p>$$\mathsf{RAIN}\lor \mathsf{BIKE},\neg\mathsf{RAIN}\vDash\mathsf{BIKE}$$</p>
<p>The problem is that this was a &ldquo;human-style&rdquo; calculation. How can we teach a
(non-intelligent) computer system the necessary skills to test for valid
inference itself?</p>
<p>It turns out that for this purpose, it&rsquo;s useful to reformulate the question in
yet another, equivalent way using the concept of <strong>Boolean satisfiability</strong>.
Consider a set of (propositional) formulas $\Gamma\subseteq \mathcal{L}$. We say
that $\Gamma$ is <em>satisfiable</em> just in case there exists a Boolean valuation
$\nu$ that makes all members of $\Gamma$ true, i.e. $\nu(A)=1$ for all $A\in
\Gamma$.</p>
<p>Take the set $\Gamma=\Set{\mathsf{RAIN}\lor \mathsf{SUN},\neg \mathsf{BIKE}}$, for example. If we set $\nu$ such that:</p>
<ul>
<li>$\nu(\mathsf{RAIN})=1$</li>
<li>$\nu(\mathsf{SUN})=0$</li>
<li>$\nu(\mathsf{BIKE})=0$</li>
</ul>
<p>We have:</p>
<ul>
<li>$\nu(\mathsf{RAIN}\lor \mathsf{SUN})=\nu(\mathsf{RAIN})+\nu(\mathsf{SUN})=1+0=1$</li>
<li>$\nu(\neg \mathsf{BIKE})=-\nu(\mathsf{BIKE})=-0=1$</li>
</ul>
<p>This valuation shows that the set $\Set{\mathsf{RAIN}\lor \mathsf{SUN},\neg BIKE}$ is
satisfiable.</p>
<p>A set that&rsquo;s <em>not</em> satisfiable is called <strong>unsatisfiable</strong>. What does an
unsatisfiable set look like? Consider $\Gamma=\Set{\mathsf{RAIN},\neg \mathsf{RAIN},
\mathsf{SUN}\land\neg \mathsf{BIKE}}$. Any valuation that makes all members of $\Gamma$ true
will be such that:</p>
<ul>
<li>$\nu(\mathsf{RAIN})=1$</li>
<li>$\nu(\neg \mathsf{RAIN})=1$</li>
</ul>
<p>This is because both $\mathsf{RAIN},\neg \mathsf{RAIN}\in \Gamma$.</p>
<p>But if $\nu(\neg \mathsf{RAIN})=-\nu(\mathsf{RAIN})=1$, this means that $\nu(\mathsf{RAIN})=0$. So our
conditions give us that $\nu(\mathsf{RAIN})=1$ and <em>at the same time</em> $\nu(\mathsf{RAIN})=0$. But
that&rsquo;s impossible, meaning that the set is unsatisfiable.</p>
<p>The reason why we&rsquo;re talking about satisfiability is that there&rsquo;s a test for
valid inference in terms of satisfiability, which looks as follows:</p>
<p>$$P_1,P_2,\dots\vDash C\Leftrightarrow \Set{P_1,P_2,\dots, \neg C}\text{ is
\emph{un}satisfiable}$$</p>
<p>The idea is simply that $\Set{P_1,P_2,\dots, \neg C}$ is
satisfiable just in case its possible to make all the premises $P_1,P_2,\dots$
true and <em>at the same time</em> the conclusion $C$ false (since $\nu(\neg
C)=-\nu(C)=1$ just in case $\nu(C)=0$). To say that this is <em>not</em> possible is to
say that we can&rsquo;t make the premises true and the conclusion false, which is just
another way of saying that whenever the premises are true, the conclusion is
false.</p>
<p>Take our example from 


<a href="https://logicalmethods.ai/textbook/boolean//#validity"
   
   
   
   
   
   > Chapter
4.5 </a>

 again:</p>
<p>$$\mathsf{RAIN}\lor \mathsf{BIKE},\neg\mathsf{RAIN}\vDash\mathsf{BIKE}$$</p>
<p>We can show this using the previous test by checking whether the following set
is satisfiable:</p>
<p>$$\Set{\mathsf{RAIN}\lor \mathsf{BIKE},\neg\mathsf{RAIN},\neg \mathsf{BIKE}}$$</p>
<p><em>We</em> can quickly see that this set is unsatisfiable:</p>
<ul>
<li>
<p>To make all formulas true, we need $\nu(\neg
\mathsf{RAIN})=-\nu(\mathsf{RAIN})=1$ and $\nu(\neg
\mathsf{BIKE})=-\nu(\mathsf{BIKE})=1$.</p>
</li>
<li>
<p>That just means that $\nu(\mathsf{RAIN})=0$ and $\nu(\mathsf{BIKE})=0$.</p>
</li>
<li>
<p>But we also need $\nu(\mathsf{RAIN}\lor \mathsf{BIKE})=$. Which means:</p>
<p>$$\nu(\mathsf{RAIN}\lor \mathsf{BIKE})=\nu(\mathsf{RAIN})+\nu(\mathsf{BIKE})=1$$</p>
<p>Since we know that $\nu(\mathsf{RAIN})=0$ and $\nu(\mathsf{BIKE})=0$, this is
impossible ($0+0=1$) and so the set is unsatisfiable.</p>
</li>
</ul>
<p>But that was again &ldquo;human-style&rdquo; thinking. How can we <em>computationally</em>
implement this in a step-by-step procedure that a computer could follow? That&rsquo;s
what the rest of the chapter is about.</p>
<h2 id="truth-tables">Truth-tables<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>The first method, we&rsquo;ll discuss is the &ldquo;naive&rdquo; way of simply going through all
relevant valuations by <a href="https://en.wikipedia.org/wiki/Brute-force_search"
  target="_blank">brute
force</a>.</p>
<p>Take our example from before:</p>
<p>$\Set{\mathsf{RAIN}\lor \mathsf{BIKE},\neg\mathsf{RAIN},\neg \mathsf{BIKE}}$</p>
<p>Since there are 2 propositional variables, there are $2^2=4$ relevant
valuations.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> They are:</p>
<ul>
<li>$\nu_1(\mathsf{RAIN})=1$ and $\nu_1(\mathsf{BIKE})=1$</li>
<li>$\nu_2(\mathsf{RAIN})=1$ and $\nu_2(\mathsf{BIKE})=0$</li>
<li>$\nu_3(\mathsf{RAIN})=0$ and $\nu_3(\mathsf{BIKE})=1$</li>
<li>$\nu_4(\mathsf{RAIN})=0$ and $\nu_4(\mathsf{BIKE})=0$</li>
</ul>
<p>Now, using the recursion rules from 


<a href="https://logicalmethods.ai/textbook/boolean//#truth-functions"
   
   
   
   
   
   > Chapter 4.4 </a>

, we can simply
calculate the truth-values of all formulas in our set. We get:</p>
<ul>
<li>$\nu_1(\neg\mathsf{RAIN})=0,\nu_1(\neg\mathsf{BIKE})=0,$ and $\nu_1(\mathsf{RAIN}\lor\mathsf{BIKE})=1$</li>
<li>$\nu_2(\neg\mathsf{RAIN})=0,\nu_2(\neg\mathsf{BIKE})=1,$ and $\nu_2(\mathsf{RAIN}\lor\mathsf{BIKE})=1$</li>
<li>$\nu_3(\neg\mathsf{RAIN})=1,\nu_3(\neg\mathsf{BIKE})=0,$ and $\nu_3(\mathsf{RAIN}\lor\mathsf{BIKE})=1$</li>
<li>$\nu_4(\neg\mathsf{RAIN})=1,\nu_4(\neg\mathsf{BIKE})=1,$ and $\nu_4(\mathsf{RAIN}\lor\mathsf{BIKE})=0$</li>
</ul>
<p>A simple inspection shows that in none of these cases, we have all formulas of
our set true. Since we&rsquo;ve inspected <em>all</em> valuations, we can conclude that the
set is unsatisfiable.</p>
<p>A <strong>truth-table</strong> is a way to write down all the truth-values that a formula can
take. Here&rsquo;s how this works:</p>
<ul>
<li>
<p>We determine all the propositional variables.</p>
</li>
<li>
<p>We determine all the possible valuations.</p>
</li>
<li>
<p>We parse the formula.</p>
</li>
<li>
<p>We recursively calculate the value of the full-formula, keeping track of all
steps in a table.</p>
</li>
</ul>
<p>Here&rsquo;s how this looks for the formula $(\mathsf{RAIN}\lor(\neg\mathsf{RAIN}\land
\mathsf{BIKE}))$:</p>
<ul>
<li>
<p>The propositional variables are $\mathsf{RAIN}$ and $\mathsf{BIKE}$.</p>
</li>
<li>
<p>The possible valuations are:</p>
<ul>
<li>$\nu_1(\mathsf{RAIN})=1$ and $\nu_1(\mathsf{BIKE})=1$</li>
<li>$\nu_2(\mathsf{RAIN})=1$ and $\nu_2(\mathsf{BIKE})=0$</li>
<li>$\nu_3(\mathsf{RAIN})=0$ and $\nu_3(\mathsf{BIKE})=1$</li>
<li>$\nu_4(\mathsf{RAIN})=0$ and $\nu_4(\mathsf{BIKE})=0$</li>
</ul>
</li>
<li>
<p>The parsing tree for the formula is:</p>
</li>
</ul>


<img src="https://logicalmethods.ai/textbook/sat/img/parsing-tree-1.png" class="img-thumbnail"  alt="" >


<ul>
<li>The calculation leads to the following truth-table:</li>
</ul>


<img src="https://logicalmethods.ai/textbook/sat/img/tt-1.png" class="img-thumbnail"  alt="" >


<p>The <strong>truth-table method</strong> for validity checking is to use the truth-table for
the formula: $$(((P_1\land P_2)\land \dots )\land \neg C)$$</p>
<ul>
<li>If there is a row  with value $1$, the inference is invalid.</li>
<li>If all rows have value $0$, the inference is valid.</li>
</ul>
<p>For our example inference, we get:</p>
<ul>
<li>
<p>The propositional variables are $\mathsf{RAIN}$ and $\mathsf{BIKE}$.</p>
</li>
<li>
<p>The possible valuations are:</p>
<ul>
<li>$\nu_1(\mathsf{RAIN})=1$ and $\nu_1(\mathsf{BIKE})=1$</li>
<li>$\nu_2(\mathsf{RAIN})=1$ and $\nu_2(\mathsf{BIKE})=0$</li>
<li>$\nu_3(\mathsf{RAIN})=0$ and $\nu_3(\mathsf{BIKE})=1$</li>
<li>$\nu_4(\mathsf{RAIN})=0$ and $\nu_4(\mathsf{BIKE})=0$</li>
</ul>
</li>
<li>
<p>The parsing tree for the relevant formula is:</p>
</li>
</ul>


<img src="https://logicalmethods.ai/textbook/sat/img/parsing-tree-2.png" class="img-thumbnail"  alt="" >


<ul>
<li>The calculation leads to the following truth-table:</li>
</ul>


<img src="https://logicalmethods.ai/textbook/sat/img/tt-2.png" class="img-thumbnail"  alt="" >


<p>This shows that the formula in question is unsatisfiable and thus the
<em>inference</em> is valid.</p>
<p>The truth-table method is a working method for computationally determining the
validity of inferences. So why doesn&rsquo;t the chapter end here?</p>
<p>The <strong>problem</strong> is that truth-tables suffer from what&rsquo;s known as <a href="https://en.wikipedia.org/wiki/Combinatorial_explosion"
  target="_blank">combinatorial
explosion</a>. The problem
is that the size of the necessary truth-table grows
<a href="https://en.wikipedia.org/wiki/Exponential_growth"
  target="_blank">exponentially</a> with the
number of propositional variables in the formula, as in the following table:</p>
<table>
  <thead>
      <tr>
          <th>Propositional variables</th>
          <th>Rows</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>2</td>
      </tr>
      <tr>
          <td>2</td>
          <td>4</td>
      </tr>
      <tr>
          <td>3</td>
          <td>8</td>
      </tr>
      <tr>
          <td>4</td>
          <td>16</td>
      </tr>
      <tr>
          <td>5</td>
          <td>32</td>
      </tr>
      <tr>
          <td>6</td>
          <td>64</td>
      </tr>
  </tbody>
</table>
<p>Then, for each formula in the parsing tree, we need to calculate the truth-value
in a given row. This quickly becomes painfully slow, even with modern hardware
and for <em>relatively</em> simple, but real world applications.</p>
<p>We need a more efficient method.</p>
<h2 id="normal-forms">Normal forms<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>The method we&rsquo;ll be working with uses <a href="https://en.wikipedia.org/wiki/Canonical_normal_form"
  target="_blank">normal
forms</a>. Generally speaking,
a <strong>normal form</strong> is a special way of writing formulas such that every formula
can be re-written in this way. This is much better illustrated concretely, so
let&rsquo;s talk about <strong>Conjunctive Normal Forms (CNF)</strong>, which are what we&rsquo;re
ultimately interested in.</p>
<p>A formula $A$ is in CNF just in case it is a conjunction ($\land$) of
disjunctions ($\lor$) of propositional variables ($p,q,r,\dots$) or their
negations ($\neg p,\neg q, \neg r,\dots$). This is
still quite abstract, but we can work with that using some examples.</p>
<p>The following formulas <em>are</em> in CNF:</p>
<ul>
<li>$\mathsf{RAIN}$</li>
<li>$\mathsf{RAIN}\land\neg\mathsf{BIKE}$</li>
<li>$\mathsf{RAIN}\lor\neg\mathsf{BIKE}$</li>
<li>$(\mathsf{RAIN}\lor\neg\mathsf{BIKE})\land
(\mathsf{SUN}\lor\mathsf{BIKE})$</li>
</ul>
<p>The following formulas are <em>not</em> in CNF:</p>
<ul>
<li>$\neg\neg\mathsf{RAIN}$</li>
<li>$\mathsf{RAIN}\lor \neg(\mathsf{SUN}\land \neg \mathsf{BIKE})$</li>
<li>$\neg(\mathsf{RAIN}\land\neg\mathsf{BIKE})$</li>
<li>$\neg(\mathsf{RAIN}\lor\neg\mathsf{BIKE})$</li>
<li>$(\mathsf{RAIN}\land\neg\mathsf{BIKE})\lor
\mathsf{SUN}$</li>
</ul>
<p>So, some formulas are and some formulas aren&rsquo;t in CNF. The crucial thing about
CNFs, though, which is what make them a normal form, is that <em>every</em> formula can
equivalently be re-written in CNF. What we mean by that is that for each formula
$A$, there exists a formula $A_{CNF}$ such that for each valuation:
$$\nu(A)=\nu(A_{CNF}).$$ A formula that&rsquo;s equivalent in this way is equivalent
for all (logical and AI) intents and purposes.</p>
<p>Here are the equivalent formulas for the non-CNF formulas:</p>
<ul>
<li>$\neg\neg\mathsf{RAIN}\leadsto\mathsf{RAIN}$</li>
<li>$\mathsf{RAIN}\lor \neg(\mathsf{SUN}\land \neg \mathsf{BIKE})\leadsto
\mathsf{RAIN}\lor (\neg \mathsf{SUN}\lor \mathsf{BIKE})$</li>
<li>$\neg(\mathsf{RAIN}\land\neg\mathsf{BIKE})\leadsto \neg \mathsf{RAIN}\lor
\mathsf{BIKE}$</li>
<li>$\neg(\mathsf{RAIN}\lor\neg\mathsf{BIKE})\leadsto
\neg\mathsf{RAIN}\land\mathsf{BIKE}$</li>
<li>$(\mathsf{RAIN}\land\neg\mathsf{BIKE})\lor \mathsf{SUN}\leadsto
(\mathsf{SUN}\lor\mathsf{RAIN})\land (\mathsf{SUN}\lor\neg\mathsf{BIKE})$</li>
</ul>
<p>These are easily verified using a truth-table for the two formulas and checking
that they always have the same values.</p>
<p>Here&rsquo;s one case:</p>
<ul>
<li>$(\mathsf{RAIN}\land\neg\mathsf{BIKE})\lor \mathsf{SUN}$</li>
</ul>


<img src="https://logicalmethods.ai/textbook/sat/img/tt-3.png" class="img-thumbnail"  alt="" >


<ul>
<li>$(\mathsf{SUN}\lor\mathsf{RAIN})\land (\mathsf{SUN}\lor\neg\mathsf{BIKE})$</li>
</ul>


<img src="https://logicalmethods.ai/textbook/sat/img/tt-4.png" class="img-thumbnail"  alt="" >


<p>As you can see in these two truth-tables: under each possible valuation, the two
formulas have exactly the same truth-table.</p>
<p>The fact that each formula can be re-written in CNF is known as the <strong>CNF
theorem</strong>. You&rsquo;ll not learn the details of the proof, but you&rsquo;ll learn <em>how</em> to
transform formulas into CNFs.</p>
<p>Basically, all you need to do is to apply the following rules as many times as
needed until your formula is in CNF:</p>
<ul>
<li>$\neg\neg A\leadsto A$</li>
<li>$\neg (A\lor B)\leadsto \neg A\land \neg B$</li>
<li>$\neg (A\land B)\leadsto \neg A\lor \neg B$</li>
<li>$A\lor(B\land C)\leadsto (A\lor B)\land (A\lor C)$</li>
<li>$(A\land B)\lor C\leadsto (A\lor C)\land (B\lor C)$</li>
</ul>
<p>The way to read these rules is that if you come across any of the left formulas
within a non-CNF formula, replace the occurrence with the right formula.</p>
<p>Here&rsquo;s how the procedure looks like in practice:</p>
<p>$$\mathsf{RAIN}\lor \neg(\mathsf{SUN}\lor \neg \mathsf{BIKE})$$
$$\leadsto\mathsf{RAIN}\lor (\neg\mathsf{SUN}\land \neg\neg \mathsf{BIKE})$$
$$\leadsto(\mathsf{RAIN}\lor \neg\mathsf{SUN})\land (\mathsf{RAIN}\lor \neg\neg \mathsf{BIKE})$$
$$\leadsto(\mathsf{RAIN}\lor \neg\mathsf{SUN})\land (\mathsf{RAIN}\lor \mathsf{BIKE})$$</p>
<p>Before we move to the DPLL algorithm, we need to talk about what CNF formulas
look like <em>in general</em>. Above, we defined a CNF as a conjunction of disjunctions
of propositional variables or their negations. First, some terminology:</p>
<ul>
<li>A <em>literal</em> is a propositional variable or its negation. In BNF:</li>
</ul>
<p>$$\langle lit\rangle ::= \langle prop\rangle\mid \neg\langle prop\rangle$$</p>
<ul>
<li>A <em>clause</em> is a set of literals. That is, a clause is: $$\Set{l_1,\dots,
l_n},$$ where $l_1, \dots, l_n$ are literals.</li>
</ul>
<p>A convenient way of talking about CNFs is simply as sets of sets of literals. So
we write: $$\Set{\Set{l_1^1,\dots,l_{n_1}^1},\dots \Set{l_1^k,\dots,l_{n_k}^k}}$$
instead of $$(l_1^1\lor\dots\lor l_{n_1}^1)\land\dots\land(l_1^k\lor\dots\lor
l_{n_k}^k).$$</p>
<p>That is, there are $1,\dots,k$ clauses:</p>
<p>$$\Set{l_1^1,\dots,l_{n_1}^1}$$
$$\vdots$$
$$\Set{l_1^k,\dots,l_{n_k}^k}.$$</p>
<p>The first clause has length $n_1$, the second one length $n_2$&hellip;, and the last,
the $k$-th one has length $n_k$.</p>
<p>This is obviously criminally abstract (though unfortunately necessary), but
looking at a concrete example hopefully helps understand this quicker. The idea
is simply that instead of instead of  $$(\mathsf{RAIN}\lor
\neg\mathsf{SUN})\land (\mathsf{RAIN}\lor \mathsf{BIKE}),$$ we just write:
$$\Set{\Set{\mathsf{RAIN},\neg\mathsf{SUN}},\Set{\mathsf{RAIN},\mathsf{BIKE}}}$$</p>
<h2 id="dpll">DPLL<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>The DPLL algorithm determines whether a given formula in CNF is satisfiable,
i.e. whether there&rsquo;s a Boolean valuation that makes the entire formula true.</p>
<p>Using the notation from before, we assume that our formula looks as follows:
$$\Set{\Set{l_1^1,\dots,l_{n_1}^1},\dots \Set{l_1^k,\dots,l_{n_k}^k}}$$</p>
<p>The crucial thing to understand is that in order to make the corresponding
formula true, it&rsquo;s sufficient to make one literal from each clause true.</p>
<p>Let&rsquo;s start with the &ldquo;criminally abstract&rdquo; way of saying what that means: we
simply need to find a sequence:
$$l_{i_1}^1\in \Set{l_1^1m\dots, l_{n_1}^1}$$
$$\vdots$$
$$l_{i_k}^1\in \Set{l_k^1m\dots, l_{n_k}^k}$$
of literals with a valuation $\nu$ such that
$$\nu(l_{i_1})=1$$
$$\vdots$$
$$\nu(l_{i_k})=1$$</p>
<p>The DPLL algorithm is, essentially, a smart way of making this search easier
than just going &ldquo;brute force&rdquo; through all the possibilities. In some cases, we
still need to search through some possibilities, but by thinking about the
problem, we can often cut down the search space significantly.</p>
<p>We do so, with the following <strong>rules</strong>, which we&rsquo;ll introduce using less
abstract examples:</p>
<ul>
<li>
<p><strong>Pure literal elimination</strong>. Take the following CNF</p>
<p>$$\Set{\Set{\mathsf{RAIN},\neg\mathsf{SUN}},\Set{\mathsf{RAIN},\mathsf{BIKE}},
\Set{\neg \mathsf{SUN},\mathsf{BIKE}},\Set{\neg\mathsf{SUN},\neg\mathsf{BIKE}}}$$</p>
<p>Note that $\mathsf{RAIN}$ only occurs &ldquo;positively&rdquo; in the formula, we never
have $\neg\mathsf{RAIN}$ anywhere. This means that if we set
$\nu(\mathsf{RAIN})=1$, we automagically make any clause that contains
$\mathsf{RAIN}$ true and we can focus on the others (remember that clauses are
just disjunctions).</p>
<p>So, realizing this, we can just focus on satisfying
$$\Set{\Set{\neg \mathsf{SUN},\mathsf{BIKE}},\Set{\neg\mathsf{SUN},\neg\mathsf{BIKE}}}$$</p>
<p>But here both $\neg\mathsf{SUN}$ has a similar property as $\mathsf{RAIN}$
before: it only &ldquo;negatively&rdquo; (there&rsquo;s never $\mathsf{SUN}$).</p>
<p>So, we can just set $\nu(\mathsf{SUN})=0$ to get $\nu(\neg \mathsf{SUN})=1$ as
desired, and we satisfy both  $\Set{\neg \mathsf{SUN},\mathsf{BIKE}}$ and
$\Set{\neg\mathsf{SUN},\neg\mathsf{BIKE}}$ at the same time.</p>
<p>At this stage, what remains after eliminating all the clauses we&rsquo;ve satisfied
is the empty set $$\Set{},$$ as we&rsquo;ve found a &ldquo;truthmaker&rdquo; for each clause.</p>
<p>Now, it&rsquo;s easy to check that our valuation $\nu$ with</p>
<p>$$\nu(\mathsf{RAIN})=1$$
$$\nu(\mathsf{SUN})=0$$</p>
<p>indeed makes the formula
$$(\mathsf{RAIN}\lor\neg\mathsf{SUN})\land(\mathsf{RAIN}\lor\mathsf{BIKE})\land
(\neg \mathsf{SUN}\lor\mathsf{BIKE})\land(\neg\mathsf{SUN}\lor\neg\mathsf{BIKE})$$</p>
<p>true, no matter what the value of
$\nu(\mathsf{BIKE})$ is.</p>
<p>The rule of <strong>pure literal elimination</strong> says that whenever a literal occurs only
positively or negatively, we can set its truth-value as desired and eliminate
every clause that contains the literal from the search altogether.</p>
<p>Note that instead of $2^3=8$ rows of a truth-table with several formulas
involved, it only took us 2 applications of pure literal elimination to find a
satisfying valuation.</p>
</li>
<li>
<p><strong>Unit propagation</strong>. Another insight concerns so-called <em>unit clauses</em>, which
are clauses that contain only a single literal, such as the clause
$\Set{\mathsf{BIKE}}$ in
$$\Set{\Set{\mathsf{RAIN},\neg\mathsf{SUN}},\Set{\mathsf{RAIN},\neg\mathsf{BIKE}},
\Set{\neg \mathsf{SUN}},\Set{\mathsf{BIKE}}}$$ The point is that the <em>only</em> way
to make a member of $\Set{\mathsf{BIKE}}$ true is to make $\mathsf{BIKE}$ true.
We thus need to set $\nu(\mathsf{BIKE})=1$ and can eliminate
$\Set{\mathsf{BIKE}}$ from the search.</p>
<p>This also means that we <em>can&rsquo;t</em> make $$\Set{\mathsf{RAIN},\neg
\mathsf{BIKE}}$$ true by making $\neg\mathsf{BIKE}$ true. That would require
$\mathsf{BIKE}$ to be false. As a result, we need to satisfy the following
modified formula:
$$\Set{\Set{\mathsf{RAIN},\neg\mathsf{SUN}},\Set{\mathsf{RAIN}},
\Set{\neg \mathsf{SUN}}}$$</p>
<p>At this point, we can continue with the same reasoning and unit clause
$\Set{\mathsf{RAIN}}$. We infer that $\nu(\mathsf{RAIN})=1$ and get:<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>$$\Set{\Set{\neg \mathsf{SUN}}}$$</p>
<p>A last application of the same principle gives us $\nu(\mathsf{SUN})=0$ and we
have a solution with the valuation:</p>
<p>$$\nu(\mathsf{BIKE})=1$$
$$\nu(\mathsf{RAIN})=1$$
$$\nu(\mathsf{SUN})=0$$</p>
<p>In general, the rule of <strong>unit propagation</strong> says that when there&rsquo;s a unit clause
$\Set{l}$ in the CNF, we need to set the truth-value accordingly and can
ignore that clause in further search, <em>and</em> we need to eliminate any
&ldquo;complement&rdquo; clause of $l$ (i.e. $\neg p$ if $l$ is $p$, and $p$ if $l$ is
$p$) from any other clause.</p>
<p>An important thing to note here is that applying unit propagation, we can end
up with an <strong>empty clause</strong>. For example, applying unit propagation to:
$$\Set{\Set{\mathsf{RAIN}},\Set{\neg\mathsf{RAIN}}}$$
gives us $$\Set{\Set{}}.$$ If this happens, it tells us that the CNF is
<strong>unsatisfiable</strong>. This is because we still need to find a way of making the
remaining clause true and there are no options.</p>
<p>In this case, this makes a lot of sense, since the CNF
$\Set{\Set{\mathsf{RAIN}},\Set{\neg\mathsf{RAIN}}}$ corresponds to the formula
$$\mathsf{RAIN}\land \neg\mathsf{RAIN},$$ which is obviously unsatisfiable.</p>
</li>
<li>
<p><strong>Splitting rule</strong>. The two previous rules, <strong>unit propagation</strong> and <strong>pure
literal elimination</strong> don&rsquo;t cover all the possibilities. There are situations,
where we can&rsquo;t apply either, such as the following CNF:
$$\Set{\Set{\mathsf{RAIN},\mathsf{BIKE}},\Set{\neg\mathsf{RAIN},\neg\mathsf{BIKE}}}.$$</p>
<p>At this point, we have to <strong>guess</strong>. Simply pick a literal and test if you can
make it true. We pick $\mathsf{RAIN}$ and assume $\nu(\mathsf{RAIN})=1$. This
will make the first clause true and what remains to be checked is
$$\Set{\Set{\neg\mathsf{BIKE}}}.$$ Note that $\neg\mathsf{RAIN}$ has
disappeared from the clause since we can no longer make that true.</p>
<p>Now, we can apply unit propagation to give us $\nu(\mathsf{BIKE})=0$ and we
have the satisfying valuation: $$\nu(\mathsf{RAIN})=1$$
$$\nu(\mathsf{BIKE})=0$$</p>
<p>Sometimes the first guess doesn&rsquo;t work. Consider:</p>
<p>$$\Set{\Set{\mathsf{RAIN},\neg\mathsf{BIKE}},\Set{\neg\mathsf{RAIN},\neg\mathsf{BIKE}},\Set{\neg\mathsf{RAIN},\mathsf{BIKE}}}.$$</p>
<p>If we guess $\nu(\mathsf{RAIN})=1$ in order to make the first clause true,
what we end up with is:</p>
<p>$$\Set{\Set{\neg\mathsf{BIKE}},\Set{\mathsf{BIKE}}}.$$</p>
<p>By unit propagation, this results in $$\Set{\Set{}}$$ meaning the procedure
fails.</p>
<p>But fear not! We haven&rsquo;t tried $\nu(\mathsf{RAIN})=0$. What we do now, is we
<strong>backtrack</strong> to the last choice and try the opposite choice. That is we go
back to the CNF
$$\Set{\Set{\mathsf{RAIN},\neg\mathsf{BIKE}},\Set{\neg\mathsf{RAIN},\neg\mathsf{BIKE}},\Set{\neg\mathsf{RAIN},\mathsf{BIKE}}}$$
and see if we can proceed with the assumption that $\nu(\mathsf{RAIN})=0$.</p>
<p>What we end up with then, is
$$\Set{\Set{\neg\mathsf{BIKE}}}.$$ But now we get our satisfying valuation via
unit propagation and $\nu(\mathsf{BIKE})=0$.</p>
<p>So, the final outcome is
$$\nu(\mathsf{RAIN})=0$$
$$\nu(\mathsf{BIKE})=0$$
which clearly satisfies the corresponding formula
$$(\mathsf{RAIN}\lor\neg\mathsf{BIKE})\land(\neg\mathsf{RAIN}\lor\neg\mathsf{BIKE})\land(\neg\mathsf{RAIN}\lor\mathsf{BIKE})$$</p>
<p>The <strong>splitting rule</strong>, in general, says that we should pick the first
unassigned literal and try all unit propagation and pure literal elimination
for  both possible truth-values of our picked literal. This means that we try
the rules on two, simpler CNFs:</p>
<ul>
<li>
<p>one where we eliminate all clauses containing our picked literal and
removing all its complements,</p>
</li>
<li>
<p>one where eliminate all clauses containing the negation of our picked
literal and removing the literal from all remaining clauses.</p>
</li>
</ul>
<p>Applying unit propagation and pure literal elimination in both cases could
lead to a solution: if one gives us a valuation, we&rsquo;re done and the formula is
satisfiable; if both fail, we know the formula is unsatisfiable.</p>
<p>There&rsquo;s just one remaining possibility: at some stage, we might have to pick
<em>again</em> because neither unit propagation nor pure literal elimination work.
The crucial point here is that the splitting rule is a <strong>recursive rule</strong>. It
basically breaks down the problem into simpler problems <em>which we try to solve
with the same procedure</em>. But this can be repeated until we&rsquo;ve got such a
simple problem that we easily get a solution. So, we simply guess again, apply
our rules, backtrack if necessary, until we&rsquo;ve tried all the possibilities.</p>
</li>
</ul>
<p>Now we have all the ingredients to describe the DPLL algorithm in general:</p>
<ul>
<li>
<p>The <strong>input</strong> is a CNF and we&rsquo;re trying to determine whether its satisfiable.</p>
</li>
<li>
<p>First, we apply <strong>unit propagation</strong> and <strong>pure literal elimination</strong> as many times
as possible.</p>
</li>
<li>
<p>We check the <strong>termination conditions</strong>:</p>
<ul>
<li>If we end up with an empty CNF $\Set{}$, we&rsquo;ve satisfied the formula</li>
<li>If we end up with an empty clause somewhere among our clauses $C_1,\dots, C_n$,
$$\Set{C_1,\dots,\Set{},\dots C_n},$$ the CNF is unsatisfiable.</li>
</ul>
</li>
<li>
<p><strong>Recursion</strong>: If we can apply neither unit propagation nor pure literal
elimination, we use the <strong>splitting rule</strong>, which applies the whole algorithm to
the two CNFs that result setting the value of the first literal as true and
false respectively.</p>
</li>
<li>
<p><strong>Output</strong>: The output is a yes/no answer about the satisfiability of the
formula, and if we keep track of the valuation along the way, we also get the
satisfying valuation in case of satisfiability.</p>
</li>
</ul>
<p>It&rsquo;s a mathematical fact that this algorithm always terminates and gives the
correct answer: a valuation that satisfies the formula (we find an empty CNF
along the way) or the answer that its unsatisfiable (all CNFs along the way end
up with an empty clause).</p>
<h2 id="applications">Applications<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>The <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem"
  target="_blank">Boolean satisfiability problem
(SAT)</a> is one of
the most important technical concepts in AI. It&rsquo;s lies at the core of <strong>automated
reasoning techniques</strong> (&ldquo;theorem proving&rdquo;), as well as things like <a href="https://en.wikipedia.org/wiki/Automated_planning_and_scheduling"
  target="_blank">automated planning
and
scheduling</a>.</p>
<p>You&rsquo;ve effectively already seen how automated reasoning can work:</p>
<ul>
<li>If you wonder whether $P_1,P_2,\dots\vDash C$, transform it into a SAT problem
for $\Set{P_1,P_2,\dots,\neg C}$.</li>
<li>Apply a SAT solving algorithm, like DPLL, to get the answer to the SAT problem.</li>
</ul>
<p>This is, at the very core, how many <a href="https://en.wikipedia.org/wiki/Automated_theorem_proving"
  target="_blank">automated reasoning
programs</a>, like
<a href="https://en.wikipedia.org/wiki/Prover9"
  target="_blank">Prover9</a>,
<a href="https://en.wikipedia.org/wiki/Z3_Theorem_Prover"
  target="_blank">Z3</a>, and
<a href="https://en.wikipedia.org/wiki/Vampire_theorem_prover"
  target="_blank">Vampire</a>, work.</p>
<p>In the exercises for this chapter, you&rsquo;ll learn a bit more about the &ldquo;planning&rdquo;
applications.</p>
<h2 id="further-readings">Further readings<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p><strong>To be added</strong></p>
<p><strong>Notes:</strong></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>In general, if there are $n$ propositional variables, there are
$2^n$ possible Boolean valuations.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Note that $\Set{\Set{\neg
\mathsf{SUN}},\Set{\neg\mathsf{SUN}}}=\Set{\Set{\neg \mathsf{SUN}}}$.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
 <p><em>Last edited: </em>24/09/2024</p>
</div>


<ul class="navbar-nav flex-row justify-content-between mt-auto">
  
  <li class="nav-item">
    <a href="/textbook/boolean/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-left"></i>
    </a>
    
  </li>
  <li class="nav-item">
    <button class="btn btn-back-to-top">
    <i class="bi bi-chevron-double-up"></i>
  </button>
  </li>
  <li class="nav-item">
    
    <a href="/textbook/conditionals/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-right"></i>
    </a>
    
  </li>
</ul>

    </main>
    <footer class="align-self-center d-flex flex-column mt-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="footer-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="/about" aria-label="copyright-link">&copy; 2025 jkorbmacher et al. </a>
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link fs-6" href="https://github.com/jkorb/logicalmethods.ai" target="_blank"><i class="bi bi-github"></i></a>
      </li>
    </ul>
  </div>
</nav>
 
      <script src="https://logicalmethods.ai/js/helpers.js"></script>
      <script src="https://logicalmethods.ai/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
      
      
    </footer>
  </body>
</html>
