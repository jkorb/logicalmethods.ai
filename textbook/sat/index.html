<!doctype html>
<html lang="en" data-bs-theme="light">
  <head>
    <meta charset="utf-8"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <title>logicalmethods.ai &ndash; Boolean satisfiability </title>
    <link rel="icon" type="image/x-icon" href="https://logicalmethods.ai/favicon.ico"></link>
    <link href="https://logicalmethods.ai/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/icons/font/bootstrap-icons.min.css"></link>
    <link rel="stylesheet" href="https://logicalmethods.ai/css/layout.css"></link>
    <link href="https://logicalmethods.ai/css/textbook.css" rel="stylesheet"></link>
    <style>
      
    :root {
      --chapter: "5";
    }

    </style>
    
      <link rel="stylesheet" href="https://logicalmethods.ai/katex/katex.min.css">
<script defer src="https://logicalmethods.ai/katex/katex.min.js"></script>
<script defer src="https://logicalmethods.ai/katex/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},     
        {left: '\\[', right: '\\]', display: true},   
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>


    
  </head>
  <body class="bg-black d-flex flex-column m-0 p-0">
    <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvas-nav" aria-labelledby="offcanvas-navLabel" data-bs-theme="dark" data-bs-backdrop="false">
  <div class="offcanvas-header">
    <div class="h5 offcanvas-title" id="offcanvas-navLabel">
      Browse course
    </div>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  
  <div class="offcanvas-body">
    <ul class="navbar-nav">
      
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/about/"><i class="bi-file-person-fill"></i> &nbsp;&nbsp; About</a>
          </div>
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link fw-bold active" href="/textbook/"><i class="bi bi-book"></i> &nbsp;&nbsp; Textbook</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/textbook/"
            id="navbarSectiontxt-home" data-bs-toggle="collapse"
            data-bs-target="#collapsetxt-home"  
            aria-expanded="true"
            aria-controls="collapsetxt-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse show" id="collapsetxt-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/textbook/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                fw-bold active
                
                "
                href="/textbook/sat/"
              >5. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >6. 
                <i class="bi bi-lock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >7. 
                <i class="bi bi-lock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >8. 
                <i class="bi bi-lock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >9. 
                <i class="bi bi-lock-fill"></i>
                 FOL Inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logic-based learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/slides/"><i class="bi bi-rocket-takeoff-fill"></i> &nbsp;&nbsp; Slides</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/slides/"
            id="navbarSectionsli-home" data-bs-toggle="collapse"
            data-bs-target="#collapsesli-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapsesli-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapsesli-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/teaser/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/slides/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >5. 
                <i class="bi bi-lock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >6. 
                <i class="bi bi-lock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >7. 
                <i class="bi bi-lock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >8. 
                <i class="bi bi-lock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >9. 
                <i class="bi bi-lock-fill"></i>
                 FOL inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/exercises/"><i class="bi-gear-fill"></i> &nbsp;&nbsp; Exercises</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/exercises/"
            id="navbarSectionexe-home" data-bs-toggle="collapse"
            data-bs-target="#collapseexe-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseexe-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseexe-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/preamble/"
              >0. 
                <i class="bi bi-unlock-fill"></i>
                 Preamble
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/logic-and-ai/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Logic and AI
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/formal-languages/"
              >2. 
                <i class="bi bi-unlock-fill"></i>
                 Formal languages
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/valid-inference/"
              >3. 
                <i class="bi bi-unlock-fill"></i>
                 Valid inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/exercises/boolean/"
              >4. 
                <i class="bi bi-unlock-fill"></i>
                 Boolean algebra
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >5. 
                <i class="bi bi-lock-fill"></i>
                 Boolean satisfiability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >6. 
                <i class="bi bi-lock-fill"></i>
                 Logical conditionals
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >7. 
                <i class="bi bi-lock-fill"></i>
                 Logical proofs
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >8. 
                <i class="bi bi-lock-fill"></i>
                 FOL
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >9. 
                <i class="bi bi-lock-fill"></i>
                 FOL inference
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >10. 
                <i class="bi bi-lock-fill"></i>
                 Many-valued logics
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >11. 
                <i class="bi bi-lock-fill"></i>
                 Logic and probability
              </a>
            </li>
            
            <li>
              <a class="dropdown-item 
                
                link-opacity-50
                "
                href="javascript:;"
              >12. 
                <i class="bi bi-lock-fill"></i>
                 Logical learning
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      <hr>
      <li class="nav-item">
        <div class="d-flex flex-row">
          <div class="container">
            <a class="nav-link " href="/assignments/"><i class="bi bi-house-gear-fill"></i> &nbsp;&nbsp; Assignments</a>
          </div>
          <button 
            class="btn btn-sm btn-dark" 
            href="/assignments/"
            id="navbarSectionass-home" data-bs-toggle="collapse"
            data-bs-target="#collapseass-home"  
            aria-expanded="aria-expanded=false"
            aria-controls="collapseass-home">
            <i class="bi bi-caret-left-fill toggle-icon"></i>
          </button>
        </div>
        <div class="collapse " id="collapseass-home">
          <ul class="list-unstyled ms-3">
            <li>
              <a class="dropdown-item 
                
                
                "
                href="/assignments/assignment_1/"
              >1. 
                <i class="bi bi-unlock-fill"></i>
                 Assignment 1 (due 09/19/2025)
              </a>
            </li>
            
          </ul>
        </div>
          
      </li>
      
      
      
      
      
    </ul>
  </div>
</div>



    <header class="align-self-center d-flex flex-column m-0 mb-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="header-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="https://logicalmethods.ai/">
    <img src="https://logicalmethods.ai/img/nav_id.png" class="inert-img img-fluid m-2" draggable="false" width="400px">
    </a>
    <button class="navbar-toggler border-0" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas-nav" aria-controls="offcanvas-nav">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
</nav>

      
      
    </header>
    
    <main class="align-self-center d-flex flex-column flex-fill bg-white m-md-1 p-0" data-bs-theme="light">
      <ul class="navbar-nav flex-row justify-content-center mt-2">

  <li class="nav-item">
    <a href="/textbook/" class="btn" style="font-size: 20pt;" tabindex="-1" role="button" aria-disabled="false">
      <i class="bi bi-house-up"></i>
    </a>
  </li>
</ul>
<div class="container chapter">
  <p>By: <em>Johannes Korbmacher</em></p>
  <div class="m-4"><h1 id="boolean-satisfiability">Boolean satisfiability<button class="btn btn-back-to-top">
    
  </button>
</h1>
<hr>

<p>We&rsquo;ve seen that Boolean logic is at the heart of computation and deductive
reasoning. But when it comes to automated reasoning, our approach has so-far
been limited to pre-programmed circuits, like the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Logic_gate"
  target="_blank">logic
gates</a> and
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Adder_%28electronics%29"
  target="_blank">adders</a> we&rsquo;ve discussed.
While these circuits are great at carrying out specific deductive reasoning
tasks, like adding two numbers or calculating truth-values, they are not very
flexible. Each circuit carries out one specific task.</p>
<p>

<img src="https://logicalmethods.ai/textbook/sat/img/ai_boolean.png" class="rounded  float-start inert-img img-fluid m-2"  width="200px"  alt="" >


But in AI, we don&rsquo;t only want to implement specific inference patters using
specific cirucits, like adding two bits using an adder circuit or inferring <span class="excalifont">(A

<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 B)</span> from <span class="excalifont">A</span> and <span class="excalifont">B</span> using <span class="Boolean">AND</span>. We want to implement deductive
reasoning <em>in general</em>.</p>
<p>We did already discuss an implementation of deductive inference in Boolean
logic, but the approach still required human intervention. To determine whether
a certain inference is valid, like whether <span class="excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN

<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
RAIN</span>, we manually needed to check all possible valuations to see
whether there is one that makes the premises true and the conclusion false.</p>
<p><strong>Satisfiability solving</strong> is a powerful approach to automated reasoning using
Boolean logic, which is popular in research and industry alike. The observation
that motivates the approach is that we can reduce the question whether a given
inference is valid to the question whether certain truth-value assignment is
possible. <code class="customCode">SAT</code>-solving algorithms are instructions for systematically—and
ideally efficiently—testing for the existence of specific truth-value
assignments.</p>
<p>The applications of this powerful logical method for AI reasoning range from
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Formal_verification"
  target="_blank">formal hardware
verification</a> to <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Automated_reasoning"
  target="_blank">automated
reasoning</a> in propositional
languages and beyond.</p>
<p>At the end of this chapter you&rsquo;ll be able to:</p>
<ul>
<li>
<p>define the <code class="customCode">SAT</code> problem for Boolean formulas and explain its relevance to
logic and artificial reasoning</p>
</li>
<li>
<p>apply the truth-table method for satisfiability checking</p>
</li>
<li>
<p>convert formulas into disjunctive and conjunctive normal form</p>
</li>
<li>
<p>apply the resolution algorithm and explain its advantages over the truth-table
method</p>
</li>
</ul>
<h2 id="sat"><code class="customCode">SAT</code><button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>There are both algebraic and logical ways of thinking about the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem"
  target="_blank">Boolean
satisfiability
problem</a> or <code class="customCode">SAT</code>.</p>
<p>We&rsquo;ll start thinking algebraically, where <code class="customCode">SAT</code> asks whether for a given Boolean
expression, like:</p>
<div class="customBlock text-center my-4"><code class="customCode">
X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> (0 <span class="Boolean">AND</span> Y)),
</code></div>
<p>whether there exists an assignment of values to <code class="customCode">X</code> and <code class="customCode">Y</code>, such that the
expression evaluates to <code class="customCode">1</code>. In this case, the answer is <span class="excalifont">yes</span>, since for <code class="customCode">X =
1</code> and <code class="customCode">Y = 1</code>, we get the calculation:</p>
<div class="customBlock text-center my-4"><code class="customCode">
1 <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> (0 <span class="Boolean">AND</span> 1)) = 1 <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> 0) = 1 <span class="Boolean">AND</span> 1 = 1
</code></div>
<p>We say that the expression is <em>satisfiable</em>.</p>
<p>If we take the following Boolean expression, instead:</p>
<div class="customBlock text-center my-4"><code class="customCode">
X <span class="Boolean">AND</span> <span class="Boolean">NOT</span> (X <span class="Boolean">OR</span> 1),
</code></div>
<p>we find that no matter the value for <code class="customCode">X</code>, the formula evaluates to <code class="customCode">0</code>:</p>
<ul>
<li>
<p>If <code class="customCode">X = 1</code>, then <code class="customCode">1 <span class="Boolean">AND</span> <span class="Boolean">NOT</span> (1 <span class="Boolean">OR</span> 1) = 1 <span class="Boolean">AND</span> <span class="Boolean">NOT</span> 1 = 1
<span class="Boolean">AND</span> 0 = 0</code></p>
</li>
<li>
<p>If <code class="customCode">X = 0</code>, then <code class="customCode">0 <span class="Boolean">AND</span> <span class="Boolean">NOT</span> (0 <span class="Boolean">OR</span> 1) = 0 <span class="Boolean">AND</span> <span class="Boolean">NOT</span> 1 = 0
<span class="Boolean">AND</span> 0 = 0</code></p>
</li>
</ul>
<p>This Boolean expression is <em>unsatisfiable</em>.</p>
<p>The idea of satisfiability can be extended to <em>sets</em> of Boolean expressions in a
natural way: we say that a set of Boolean expressions is satisfiable just in
case there is an assignment to its variables that makes <em>all</em> the members of the
set true.</p>
<p>Here&rsquo;s an example of a satisfiable set of Boolean expressions:</p>
<div class="customBlock text-center my-4"><code class="customCode">
{ (<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (Y <span class="Boolean">OR</span> Z), X <span class="Boolean">OR</span> (<span class="Boolean">NOT</span> Y), Z <span class="Boolean">OR</span> (<span class="Boolean">NOT</span> Z) }
</code></div>
<p>This is because for the values <code class="customCode">X = 0, Y = 0, Z = 1</code>, we get:</p>
<ul>
<li>
<p><code class="customCode">(<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (Y <span class="Boolean">OR</span> Z) = (<span class="Boolean">NOT</span> 0) <span class="Boolean">AND</span> (0 <span class="Boolean">OR</span> 1) = 1
<span class="Boolean">AND</span> 1 = 1</code></p>
</li>
<li>
<p><code class="customCode">X <span class="Boolean">OR</span> (<span class="Boolean">NOT</span> Y) = 0 <span class="Boolean">OR</span> (<span class="Boolean">NOT</span> 0) = 0 <span class="Boolean">OR</span> 1 = 1</code></p>
</li>
<li>
<p><code class="customCode">Z <span class="Boolean">OR</span> (<span class="Boolean">NOT</span> Z) = 1 <span class="Boolean">OR</span> (<span class="Boolean">NOT</span> 1) = 1 <span class="Boolean">OR</span> 0 = 1</code></p>
</li>
</ul>
<p>Here&rsquo;s an example of an unsatisfiable set:</p>
<div class="customBlock text-center my-4"><code class="customCode">
{ X <span class="Boolean">OR</span> 0, (<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> 1}
</code></div>
<p>No matter what the value of <code class="customCode">X</code>, at least one formula evaluates to <code class="customCode">0</code>:</p>
<ul>
<li>
<p>If <code class="customCode">X = 1</code>, then <code class="customCode">X <span class="Boolean">OR</span> 0 = 1 <span class="Boolean">OR</span> 0 = 1</code>, but <code class="customCode">(<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> 1 =
(<span class="Boolean">NOT</span> 1) <span class="Boolean">AND</span> 1 = 0 <span class="Boolean">AND</span> 1 = 0</code>.</p>
</li>
<li>
<p>If <code class="customCode">X = 0</code>, then <code class="customCode">(<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> 1 = (<span class="Boolean">NOT</span> 0) <span class="Boolean">AND</span> 1 = 1 <span class="Boolean">AND</span> 1
= 1</code>, but <code class="customCode">X <span class="Boolean">OR</span> 0 = 0 <span class="Boolean">OR</span> 0 = 0</code>.</p>
</li>
</ul>
<p>It turns out that many important problems can be reduced to questions of
satisfiability. One important example is <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Formal_verification"
  target="_blank">(formal) hardware verification</a>.


<img src="https://logicalmethods.ai/textbook/sat/img/ai_verification.png" class="rounded  float-start inert-img img-fluid m-2"  width="400px"  alt="" >


To discuss the idea in a simplified example, let&rsquo;s go back to relay
logic.</p>
<p>We implemented different truth-functions using relays. One example (from the
exercises) is the <span class="Boolean">NAND</span> function, which has the following function table:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/nand_table.png" class="rounded mx-auto d-block inert-img img-fluid"  width="150px"  alt="" >


<p>We can implement this with the following relay circuit (spoiler alert, if you
didn&rsquo;t do the exercises yet 😉):</p>


<img src="https://logicalmethods.ai/textbook/sat/img/nand_impl.png" class="rounded mx-auto d-block inert-img img-fluid"  width="450px"  alt="" >


<p>To check that this implementation is according to the specification given by the
function table, we need to go through all the possible inputs and check that the
circuit gives the same outputs for the same inputs as the table says.</p>
<p>This is a bit tedious, but doable for smaller circuits with few inputs and
outputs and rather simple specifications, like our <span class="Boolean">NAND</span> table. But in
practice, circuits get much, <em>much</em> larger. A modern CPU, for example, contains
in the order of hundreds of millions to billions of logic circuits, which
implement a specification like the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/X86"
  target="_blank">X86 instruction
set</a> or <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/ARM_architecture_family"
  target="_blank">ARM
instructions</a>. Here, we
simply cannot go through all the possible input configurations and check whether
the outputs are correct. We need a more efficient method.</p>
<p><code class="customCode">SAT</code>-solving provides one popular approach for this, which is, in effect,
industry standard. We cannot discuss the full details, but we can illustrate the
idea using our <span class="Boolean">NAND</span> circuit.</p>
<p>For the approach, we need to translate both our specification (the <span class="Boolean">NAND</span>
table) and our circuit into Boolean expressions. For the circuit, this is rather
straight-forward, once we realize that a <span class="excalifont">default &ldquo;off&rdquo;</span> relay is essentially
a Boolean <span class="Boolean">AND</span> and a <span class="excalifont">default &ldquo;on&rdquo;</span> relay is a Boolean <span class="Boolean">NOT</span>. Inspecting
our circuit, we see that we just chain the <span class="excalifont">default &ldquo;off&rdquo;</span> and <span class="excalifont">default &ldquo;on&rdquo;</span>
relays with the inputs. This means that the Boolean expression that corresponds
to our circuit is:</p>
<div class="customBlock text-center my-4"><code class="customCode">
<span class="Boolean">NOT</span> (X <span class="Boolean">AND</span> Y)
</code></div>
<p>This is the origin of the term &ldquo;<span class="Boolean">NAND</span>&rdquo;, by the way: <span class="Boolean">NOT</span> applied to
<span class="Boolean">AND</span> …  <span class="Boolean">NAND</span>.</p>
<p>Formalizing the specification is a bit more involved, but it turns out that
there&rsquo;s a powerful method for expressing truth-functional tables using the Boolean
operators <span class="Boolean">NOT</span>, <span class="Boolean">AND</span>, and <span class="Boolean">OR</span>.</p>
<p>If you have a binary truth-function, like <span class="Boolean">NAND</span>, the expression that we&rsquo;ll
generate by our method involves two variables <code class="customCode">X</code> and <code class="customCode">Y</code>. The first, <code class="customCode">X</code>, represents
the first input (the first column of the function table), and <code class="customCode">Y</code> represents the
second input. We write a Boolean expression in <code class="customCode">X</code> and <code class="customCode">Y</code>, which represents the
output. For this, we first identify all the input configurations, which give
output <code class="customCode">1</code>, which in this case are:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/nand_representation.png" class="rounded mx-auto d-block inert-img img-fluid"  width="450px"  alt="" >


<p>Now, each of these configurations will turn into a <em>clause</em> in our Boolean
representation, which joins these clauses using <span class="Boolean">OR</span>. To obtain these clauses,
we represent the input configuration <code class="customCode">X = 1</code> by writing simply <code class="customCode">X</code>, and the
input configuration <code class="customCode">X = 0</code> by writing <code class="customCode"><span class="Boolean">NOT</span> X</code>. Then we do likewise for <code class="customCode">Y</code>
and combine the corresponding representations for <code class="customCode">X</code> and <code class="customCode">Y</code> using <span class="Boolean">AND</span>.
This gives us:</p>
<ul>
<li>
<p>for the <span class="dark-green">first  configuration</span>, the clause: <code class="customCode">(<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y)</code></p>
</li>
<li>
<p>for the <span class="dark-blue">second configuration</span>, the clause: <code class="customCode">(<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> Y</code></p>
</li>
<li>
<p>for the <span class="dark-red">third configuration</span>, the clause: <code class="customCode">X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y)</code></p>
</li>
</ul>
<p>The final Boolean expression joins the clauses using <span class="Boolean">OR</span>, giving us:</p>
<div class="customBlock text-center my-4"><code class="customCode">
((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y)) <span class="Boolean">OR</span> ((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> Y) <span class="Boolean">OR</span> (X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y))
</code></div>
<p>This method is guaranteed to generate a Boolean expression that describes the
truth-table it was generated from. In fact, we can use this method to prove that
every truth-function can be represented using <span class="Boolean">NOT</span>, <span class="Boolean">AND</span>, and <span class="Boolean">OR</span>, but
that&rsquo;s for another time. The resulting formula is also called the <em>full</em> or
<em>maximal</em>  <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Disjunctive_normal_form"
  target="_blank">Disjunctive Normal Form
(DNF)</a> representation of
the truth-table—these kind of normal forms we&rsquo;ll return to later.</p>
<p>Now, we&rsquo;ve got two formulas:</p>
<ul>
<li>
<p>a specification: <code class="customCode">((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y)) <span class="Boolean">OR</span> ((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> Y) <span class="Boolean">OR</span> (X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y))</code></p>
</li>
<li>
<p>and a circuit representation: <code class="customCode"><span class="Boolean">NOT</span> (X <span class="Boolean">AND</span> Y)</code></p>
</li>
</ul>
<p>The question is whether the circuit implements the specification, that is
whether the two expressions always have evaluate to the same truth-values. That
is:</p>
<ul>
<li>
<p>If the specification evaluates to <code class="customCode">1</code>, does the representation evaluate to
<code class="customCode">1</code>?</p>
</li>
<li>
<p>If the representation evaluates to <code class="customCode">1</code>, does the specification evaluate to <code class="customCode">1</code>
as well.</p>
</li>
</ul>
<p>We can, of course, check this by going through the possible values for <code class="customCode">X</code> and
<code class="customCode">Y</code> again, but the point here is that we can reduce this problem to a <code class="customCode">SAT</code>
problem.</p>
<p>For this, the trick is to check whether it&rsquo;s possible that the two expression
evaluate to <em>different</em> values. That is, is it possible that:</p>
<ul>
<li>
<p>The specification evaluates to <code class="customCode">1</code> and the representation to <code class="customCode">0</code>.</p>
</li>
<li>
<p>The representation evaluates to <code class="customCode">1</code> and the specification to <code class="customCode">0</code>.</p>
</li>
</ul>
<p>The last ingredient is to note that an expression evaluates to <code class="customCode">0</code> just in case
<span class="Boolean">NOT</span> applied to the expression evaluates to <code class="customCode">1</code>—this is just the function
table for <span class="Boolean">NOT</span>. But then, we can reduce our question to the <code class="customCode">SAT</code> problem for
the following two sets:</p>
<div class="text-center my-4 excalifont">{ specification, <span class="Boolean">NOT</span> representation }&emsp; &emsp;{ representation, <span class="Boolean">NOT</span> specification }</div>
<p>In our example, the question is whether any of the following two sets is satisfiable:</p>
<div class="customBlock text-center my-4"><code class="customCode">
{ ((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y)) <span class="Boolean">OR</span> ((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> Y) <span class="Boolean">OR</span> (X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y)), <span class="Boolean">NOT</span>(<span class="Boolean">NOT</span> (X <span class="Boolean">AND</span> Y))}
</code></div>
<div class="customBlock text-center my-4"><code class="customCode">
{ (<span class="Boolean">NOT</span> (X <span class="Boolean">AND</span> Y)), <span class="Boolean">NOT</span>[((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y)) <span class="Boolean">OR</span> ((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> Y) <span class="Boolean">OR</span> (X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y))]}
</code></div>
<p>If any of the two sets is satisfiable, our circuit implementation does not
follow the specification. If neither of them is satisfiable, our circuit is
correct.—We&rsquo;ve reduced the verification of the circuit to a <code class="customCode">SAT</code> problem.</p>
<p>While it may look like we&rsquo;ve made things worse—the Boolean expressions we wrote
down are not <em>per se</em> easier to understand than the initial problem—we&rsquo;ve
actually massively improved our situation. We&rsquo;ve figured out a way of
<em>mechanically</em> translate the question whether our circuit functions according to
specification into a <code class="customCode">SAT</code>-problem. And as we&rsquo;ll see, the <code class="customCode">SAT</code> problem itself
allows for algorithmic approaches. This is the foundation for automated circuit
verification. Similar ideas are used for software verification</p>
<p>

<img src="https://logicalmethods.ai/textbook/sat/img/cpu_bug.png" class="rounded  float-start inert-img img-fluid m-2"  width="200px"  alt="" >


In industry practice, the setup is, of course, <em>much</em> more complicated. There
we&rsquo;re dealing with <em>huge</em> circuits and highly complex specifications, much more
complicated than our simple function table and relay circuit. To deal with this,
we use advanced technologies, like  <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Hardware_verification_language"
  target="_blank">hardware specification
languages</a> and
dedicated <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/SAT_solver"
  target="_blank"><code class="customCode">SAT</code> solvers</a>. But the
ultimate ideas are still the same.</p>
<p>The importance of these technologies is illustrated by the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug"
  target="_blank">Pentium
bug</a>, where an implementation
mistake lead to calculation errors in in certain division operations. Not only
was this catastrophic for Intel&rsquo;s bottom line, but imagine what could have
happened if the chips had been used in critical infrastructure setups where
high-level accuracy is crucial…</p>
<p>From a logical perspective, instead, <code class="customCode">SAT</code> is the foundation of an important
approach to automated deductive inference. Look again at our inference about the
weather from last chapter, again:</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN.</div> 
<p>According to the Boolean implementation of propositional logic, the validity of
this inference boils down to the following fact about valuations:</p>
<div class="text-center my-4 excalifont">[(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN]
<img src="/img/subseteq.png" alt="Subseteq" class="inline-icon" style="height:1em;width:auto;"/>
 [RAIN],</div>
<p>where:</p>
<ul>
<li><span class="excalifont">[(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] = { v : v(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN) = 1 }</span>,</li>
<li><span class="excalifont">[
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN] = { v : v(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN) = 1 }</span>, and</li>
<li><span class="excalifont">[RAIN] = { v : v(RAIN) = 1 }</span></li>
</ul>
<p>To verify that the inference is deductively valid, we checked that for each
valuation <span class="excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
 [(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN]</span>, we also have that <span class="excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
 [RAIN]</span>. We did this by calculating the propositions <span class="excalifont">[(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)], [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN], </span> and <span class="excalifont">[RAIN]</span> and inspecting logical space:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/ds_validity.png" class="rounded my-4 mx-auto d-block inert-img img-fluid"  width="350px"  alt="" >


<p>We found that indeed, the only member of<br>
<span class="excalifont">[(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN]</span>, viz. the assignment
with <span class="excalifont">v(SUN) = 0</span> and <span class="excalifont">v(RAIN) = 0</span>, is also a member of <span class="excalifont">[RAIN].</span> This shows to
us that every valuation where the premises are true is one where the conclusion
is true, i.e. <div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN 
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN.</div></p>
<p>But we could have asked the question slightly differently and would have gotten
the same answer. We could have asked whether there exists a valuation
<span class="excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
 [(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN]</span> such that <span class="excalifont">v 
<img src="/img/notin.png" alt="Not-element" class="inline-icon" style="height:1em;width:auto;"/>
[RAIN]</span>. The answer to <em>this</em> question gives us the same information as
the answer to the previous question:</p>
<ul>
<li>
<p>If there <em>is</em> such a valuation <span class="excalifont">v</span>, it is a
<abbr title="model where the premises are true and the conclusion isn&#39;t"><a  class="link-underline-opacity-0 link-body-emphasis"> countermodel</a></abbr>, which makes the premises true but not the conclusion.</p>
</li>
<li>
<p>If there <em>isn&rsquo;t</em> such a valuation <span class="excalifont">v</span>, then every valuation that makes the
premises true must make the conclusion true as well.</p>
</li>
</ul>
<p>Just check logical space to help see this: is there any model which is in <span class="excalifont">[(SUN

<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN]</span> but not in <span class="excalifont">[RAIN]</span>? <em>Of course</em>
not! Every element in the former is in the latter.</p>
<p>In the case of an invalid inference, such as our previous example:</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), SUN 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN,</div> 
<p>this works as well. Working out the relevant propositions gave us the following
picture of logical space:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/aff_countermodel.png" class="rounded my-4 mx-auto d-block inert-img img-fluid"  width="350px"  alt="" >


<p>Here we have a valuation <span class="excalifont">v</span>—the one with <span class="excalifont">v(SUN) = 1</span> and <span class="excalifont">v(RAIN) = 0</span>—such that <span class="excalifont">v</span> makes the premises true—<span class="excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
 ([SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [SUN])</span>—but the conclusion is not—<span class="excalifont">v 
<img src="/img/notin.png" alt="Not-element" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN]</span>. The inference is invalid:</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), SUN 
<img src="/img/nvDash.png" alt="nvDash" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN.</div> 
<p>Now we just need to make one observation to connect the validity test to <code class="customCode">SAT</code>,
which is that for every formula <span class="excalifont">A</span>, we have that <div class="text-center my-4 excalifont">v 
<img src="/img/notin.png" alt="Not-element" class="inline-icon" style="height:1em;width:auto;"/>
 [A] if and
only if v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
[
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 A]</div>
This mathematical fact derives from the general equation for the values of
negations: <div class="text-center my-4 excalifont">v(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A) = <span class="Boolean">NOT</span> v(A)</div>
Combining this with the fact that <div class="text-center my-4 excalifont"><span class="Boolean">NOT</span> 1 = 0     <span class="Boolean">NOT</span> 0 = 1</div>
allows us to see that:</p>
<div class="text-center my-4 excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
[
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A] = { v : v(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 A) = <span class="Boolean">NOT</span> v(A) = 1 } = { v
: v(A) = 0 }</div>
<div class="text-center my-4 excalifont">if and only if</div>
<div class="text-center my-4 excalifont">v
<img src="/img/notin.png" alt="Not-element" class="inline-icon" style="height:1em;width:auto;"/>
[A] = { v : v( A) = 1 }</div>
<p>Because no <span class="excalifont">v</span> can be both such that <span class="excalifont">v(A) = 0</span> <em>and</em> <span class="excalifont">v(A) = 1</span> at the same
time.</p>
<p>So, what we&rsquo;ve seen now is that to determine whether <span class="excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN),

<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN</span> is valid, we can ask whether there is a
valuation <span class="excalifont">v</span>, such that <span class="excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
 [(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN]</span> such that <span class="excalifont">v 
<img src="/img/notin.png" alt="Not-element" class="inline-icon" style="height:1em;width:auto;"/>
[RAIN]</span> (&quot;<span class="excalifont">v</span> makes the premises true and the conclusion false&quot;). And by the last observation about the propositions expressed by negations,
<span class="excalifont">v 
<img src="/img/notin.png" alt="Not-element" class="inline-icon" style="height:1em;width:auto;"/>
[RAIN]</span> means the same as <span class="excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
[
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN]</span>. So <div class="text-center my-4 excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
 [(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN] and v 
<img src="/img/notin.png" alt="Not-element" class="inline-icon" style="height:1em;width:auto;"/>
[RAIN]</div> is the same as <div class="text-center my-4 excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
 [(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN] and v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
[
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
A]</div>
applying the definition of 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
, we can say this even
simpler: <div class="text-center my-4 excalifont">v 
<img src="/img/in.png" alt="Element" class="inline-icon" style="height:1em;width:auto;"/>
[(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
 [
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN] 
<img src="/img/cap.png" alt="Intersection" class="inline-icon" style="height:1em;width:auto;"/>
[
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN]</div>. So what we&rsquo;re really asking is whether there&rsquo;s a <span class="excalifont">v</span>, such that:</p>
<div class="text-center my-4 excalifont">v((SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN)) = 1, v(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN) = 1, and v(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN) = 1</div>
<p>If such a <span class="excalifont">v</span> exists, then it is a countermodel to the inference—a model where
the premises are true and the conclusion isn&rsquo;t. The inference is invalid. If no such <span class="excalifont">v</span> exists, the inference is valid, instead.</p>
<p>Now you can hopefully see how the question is related to satisfiability. In
logical contexts, we say that a set of propositional formulas is <em>satisfiable</em>
just in case there exists a valuation <span class="excalifont">v</span>, which makes all the members of the set
true. That is, the validity of</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN</div>
boils down to the satisfiability of 
<div class="text-center my-4 excalifont">{ (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN }.</div>
<p>

<img src="https://logicalmethods.ai/textbook/sat/img/ai_two_sides.png" class="rounded  float-end inert-img img-fluid m-2"  width="250px"  alt="" >


And since this set is unsatisfiable in the logical sense, we can conclude that
the inference is valid.</p>
<p>The other inference,</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), SUN 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN,</div> 
<p>is invalid, instead, since the set</p>
<div class="text-center my-4 excalifont">{ (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN }</div>
<p><em>is</em> satisfiable.—In other words, deductive validity and <code class="customCode">SAT</code> a are two sides of the same coin.</p>
<p>One interesting observation is that the algebraic and the logical interpretation
of <code class="customCode">SAT</code> boil down to, essentially, the same thing. To see this, let&rsquo;s look at
the satisfiability of:</p>
<div class="text-center my-4 excalifont">{ (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN }.</div>
<p>A satisfying valuation <span class="excalifont">v</span> would need to be such that:</p>
<div class="text-center my-4 excalifont">v(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN) = 1, v(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN) = 1, and v(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN) = 1</div>
<p>But if we apply to this the implementation of the logical operators 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>

and 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 in terms of <span class="Boolean">OR</span> and <span class="Boolean">NOT</span>, respectively, we get a Boolean
expression, where the only remnants of logic is the use of <span class="excalifont">v</span> applied to the
propositional variables <span class="excalifont">SUN</span> and <span class="excalifont">RAIN</span>:</p>
<div class="text-center my-4 excalifont">(v(SUN) <span class="Boolean">OR</span> v(RAIN)) = 1, <span class="Boolean">NOT</span> v(SUN) = 1, and <span class="Boolean">NOT</span> v(RAIN) = 1</div>
<p>In fact, if we say <code class="customCode">X = v(SUN)</code> and <code class="customCode">Y = v(RAIN)</code>, the condition becomes:</p>
<div class="customBlock text-center my-4"><code class="customCode">
(X <span class="Boolean">OR</span> Y) = 1, (<span class="Boolean">NOT</span> X) = 1, and (<span class="Boolean">NOT</span> Y) = 1
</code></div>
<p>That that just asks whether the set</p>
<div class="customBlock text-center my-4"><code class="customCode">
{ (X <span class="Boolean">OR</span> Y), (<span class="Boolean">NOT</span> X), (<span class="Boolean">NOT</span> Y) }
</code></div>
<p>is satisfiable in the algebraic sense, which it isn&rsquo;t, of course. This is, by
the way, why we call <span class="excalifont">SUN,RAIN</span> &ldquo;propositional variables&rdquo; in propositional
logic.</p>
<p>To sum up, what we&rsquo;ve achieved so far is to reduce two important
problems—hardware verification and deductive inference—to <code class="customCode">SAT</code> problems. Now,
in the next step, we&rsquo;ll look at how we can automate the search for satisfying
assignments. We&rsquo;ll look at <strong><code class="customCode">SAT</code> solving</strong>.</p>
<h2 id="truth-tables">Truth-tables<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>The naive approach to <code class="customCode">SAT</code>-solving is <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Brute-force_search"
  target="_blank">brute
force</a>: to literally go
through all possible valuations and check in each case for the satisfaction of
the relevant expression(s).</p>
<p>

<img src="https://logicalmethods.ai/textbook/sat/img/exponential.png" class="rounded  float-start inert-img img-fluid m-2"  width="400px"  alt="" >


Since there can only be finitely many variables (propositional or Boolean) in a
given expression, the list of possible valuations is finite: by the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Rule_of_product"
  target="_blank">rule of
products</a>, if there are
<span class="excalifont">n</span>-variables, which can take two values each (<span class="excalifont">0</span> or <span class="excalifont">1</span>), then there <span class="excalifont">2ⁿ</span>-many
combinations of such values—each being a different valuation. This number grows
quickly, in fact
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Exponential_growth"
  target="_blank">exponentially</a>, but it will
<em>always</em> be finite. This means that we can go through it. And since a Boolean
expression will only ever contain finitely many operations (from <span class="Boolean">NOT</span>,
<span class="Boolean">AND</span>, and <span class="Boolean">OR</span>), for each valuation, we only have to carry out finitely
many calculations for each formula who&rsquo;s truth-value we want to know. What this
means is that if we have a finite set of Boolean expressions, we can check
whether it&rsquo;s satisfiable in finitely many steps—possibly a large finite number,
but finite nevertheless.</p>
<p>A direct consequence of this is that the <code class="customCode">SAT</code> problem is <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Decision_problem"
  target="_blank">decidable
problem</a>: there exists an
effective method, which after finitely many steps generates a correct
<span class="excalifont">yes/no</span>-answer to the question whether a given set of Boolean expressions is
satisfiable. Since deductive validity in propositional logic can be reduced to a
<code class="customCode">SAT</code> problem, this means that propositional logic is a <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Decidability_%28logic%29"
  target="_blank">decidable
logic</a>—we can
algorithmically automate checking for valid inference in propositional logic.</p>
<p>A procedure for deciding a problem—that is, giving a correct <span class="excalifont">yes/no</span>-answer in
finitely many steps—is called a <strong>decision procedure</strong>. The truth-table method
is such a decision procedure, which implements the naive approach described
above is an algorithmic fashion.</p>
<p>We can present the method in an algebraic or in a logical fashion. Here we chose
the logical flavor, but it will hopefully be clear how to carry out the method
in an algebraic fashion.</p>
<p>To describe the method, let&rsquo;s suppose that we have a set of formulas, of which
we want to know whether it is satisfiable. For concreteness sake, we take our
running example again and check for the satisfiability of:</p>
<div class="text-center my-4 excalifont">{ (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN }.</div>
<p>The first thing we need to do is to determine all the possible valuations. By
what we said above, all we need to do is to count the number of different propositional variables in our set. In our case, <span class="excalifont">#variables = 2</span>. This means that there are <span class="excalifont">2² = 4</span> different valuations to consider.</p>
<p>We need to write these valuations down in some order. We typically do this as
follows:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/truth_table_0.png" class="rounded mx-auto d-block inert-img img-fluid"  width="250px"  alt="" >


<p>The idea is that each row is a function table for one possible valuation. The
red little numbers are not part of the official table, but they illustrate a
nice little trick: if you want to determine all the valuations for <span class="excalifont">n</span>
propositional variables, just count the rows from <span class="excalifont">0</span> to <span class="excalifont">n-1</span> in binary. In our
case, we counted from <span class="excalifont">0</span> to <span class="excalifont">3</span>, which gives us our four rows. But if you have
three variables, say <span class="excalifont">SUN, RAIN, WIND</span>, you count from <span class="excalifont">0</span> to <span class="excalifont">7</span> in binary, and
get the following table:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/truth-table-3var.png" class="rounded mx-auto d-block inert-img img-fluid"  width="350px"  alt="" >


<p>But back to our example with two variables. Next, we need to parse the formulas
in our set. This is necessary for an algorithmic calculation of their
truth-values. Our case is rather simple. We get:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/parse_trees_valid.png" class="rounded mx-auto d-block inert-img img-fluid"  width="450px"  alt="" >


<p>In the next step, we calculate the truth-values of the formulas under each
possible distribution of truth-values. For this, we use the general rules, known
as the <strong>recursive clauses</strong> for the truth-values under a Boolean valuation:</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>v(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 A)     </td>
          <td>=</td>
          <td>  <span class="Boolean">NOT</span> v(A)</td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>v(A 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 B)  </td>
          <td>=</td>
          <td>  v(A) <span class="Boolean">AND</span> v(B)</td>
      </tr>
      <tr>
          <td> </td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>v(A 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 B)   </td>
          <td>=</td>
          <td>  v(A) <span class="Boolean">OR</span> v(B)</td>
      </tr>
  </tbody>
</table>
<p>We apply these clauses by tracing the parsing tree backwards and calculating the
value of the formula generated in the next step by applying the corresponding
recursive rule. We don&rsquo;t worry too much about the concrete implementation of
this recursive procedure here, but for this step, the correct parsing of the
formula is crucial.</p>
<p>We then document the resulting truth-values in our table like so:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/truth_table_valid_complete.png" class="rounded mx-auto d-block inert-img img-fluid"  width="850px"  alt="" >


<p>In the last step, we inspect our truth-table and see if we can find a row in
which each formula get&rsquo;s the value <code class="customCode">1</code>. If there is one, the set is satisfiable;
if there isn&rsquo;t—like in our case—the set isn&rsquo;t satisfiable.</p>
<p>This truth-table doubles as the proof of the validity of our inference:</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
  RAIN,</div> 
<p>since it shows that the set <div class="text-center my-4 excalifont">{ (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
  RAIN}</div> is unsatisfiable and the inference thus valid. Note very
crucially that the set has an extra 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 where the conclusion occurs—we&rsquo;re checking whether it&rsquo;s possible for the premises to be true and the conclusion <em>not</em> true.</p>
<p>For an example of a satisfiable set, let&rsquo;s take a set with <span class="excalifont">#variables = 3</span> and some more complex formulas to illustrate a few helpful methods:</p>
<div class="text-center my-4 excalifont">{ (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 (
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 WIND)), SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 WIND }</div>
<p>The satisfiability of this set corresponds to the <em>in</em>validity of the inference:</p>
<div class="text-center my-4 excalifont"> (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 (
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 WIND)), SUN 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
 WIND </div>
<p>I hope you can see that this is just a more complicated instance of <em>affirming a disjunct</em>*, a fallacy which we&rsquo;ve mentioned a couple of times before.</p>
<p>The possible valuations, we&rsquo;ve determined already above. So let&rsquo;s skip to
parsing. The relevant parse trees are as follows:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/parsing_three.png" class="rounded mx-auto d-block inert-img img-fluid"  width="850px"  alt="" >


<p>Now in this case, a more complex formula is involved, viz. <span class="excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 (
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 WIND))</span>. When we&rsquo;re calculating it&rsquo;s value under a given valuation, the parse tree comes in handy. It tells us in which order to apply the Boolean operations <span class="Boolean">NOT</span>, <span class="Boolean">AND</span>, and <span class="Boolean">OR</span> to calculate the truth-values. We can document the calculation in our truth-table as follows:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/truth_table_three_full.png" class="rounded mx-auto d-block inert-img img-fluid"  width="1100px"  alt="" >


<p>Here, I used color coding and arrows to indicate which recursive step yields
which truth-value, but you don&rsquo;t have to do that every time. You also don&rsquo;t <em>have</em> to write down the intermediate values, like that of <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN</span> or <span class="excalifont">(
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND)</span>, but it can be helpful.</p>
<p>What remains to be done is to check whether there&rsquo;s a valuation (&ldquo;row&rdquo;), where all formulas in the set get value <code class="customCode">1</code>. And indeed:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/truth-table-highlight.png" class="rounded mx-auto d-block inert-img img-fluid"  width="900px"  alt="" >


<p>There are indeed <em>two</em> valuations that make all formulas true. But that&rsquo;s alright, the more the merrier. Either row is enough to show that:</p>
<div class="text-center my-4 excalifont"> (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 (
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 WIND)), SUN 
<img src="/img/nvDash.png" alt="nvDash" class="inline-icon" style="height:1em;width:auto;"/>
 WIND </div>
<p>This is, in a nutshell, the method of truth-tables. The method is brute force,
but it&rsquo;s guaranteed to work. The main problem with the method is that how long
it takes grows <em>exponentially</em> with the number of inputs. In algorithmic terms,
the algorithm has exponential  <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Time_complexity"
  target="_blank">time
complexity</a>, which is about as
bad as it gets. Using <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Big_O_notation"
  target="_blank">big O
notation</a>, the time complexity of
the truth-table method is <span class="excalifont">O(2ⁿ)</span>, where <span class="excalifont">n</span> is the number of variables
involved. Worse even, the way we&rsquo;ve described the algorithm, we <em>always</em> run
for <span class="excalifont">O(2ⁿ)</span>-many steps, since we begin with the computationally most complex
step: enumerating the valuations. In this way, truth-tables suffer from what&rsquo;s
called  <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Combinatorial_explosion"
  target="_blank">combinatorial
explosion</a>.</p>
<p>The aim of other algorithms for <code class="customCode">SAT</code>-solving is to do better, at least in some
cases. It turns out that <code class="customCode">SAT</code> is connected to very deep problems in computer
science and the theory of computation. Finding an algorithm that solves all
<code class="customCode">SAT</code> problems in &ldquo;significantly less&rdquo; than exponential run-time would solve one of the most important open problems in theoretical computer science <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/P_versus_NP_problem"
  target="_blank">P vs. NP</a>. But the details are out of scope for us.</p>
<!-- The [Cook-Levin theorem](https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem) states that <code class="customCode">SAT</code> is [NP-complete](https://en.wikipedia.org/wiki/NP-completeness).  -->
<h2 id="normal-forms">Normal Forms<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>

<img src="https://logicalmethods.ai/textbook/sat/img/ai_in_love.png" class="rounded  float-start inert-img img-fluid m-2"  width="200px"  alt="" >


Many algorithms for <code class="customCode">SAT</code>-solving make use of so-called <strong>normal forms</strong>, which
are, in a sense, standardized ways of writing formulas or expressions. We can
think of it as our &ldquo;favorite&rdquo; way of writing a formula in a given context.</p>
<p>The two most important normal forms in logical theory are <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Conjunctive_normal_form"
  target="_blank">Disjunctive Normal
Forms (DNFs)</a> and
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Disjunctive_normal_form"
  target="_blank">Conjunctive Normal Forms
(CNFs)</a>. Both kinds of
normal forms are characterized by a very specific <em>syntactic form</em>. Both Boolean
expressions (with variables and operators), as well as logical formulas have
normal forms.</p>
<p>We&rsquo;ve already encountered DNFs when we transformed the truth-table for <span class="Boolean">NAND</span>
into a Boolean expression. The result was the expression:</p>
<div class="customBlock text-center my-4"><code class="customCode">
((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y)) <span class="Boolean">OR</span> ((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> Y) <span class="Boolean">OR</span> (X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y))
</code></div>
<p>Crucially, this expression was <strong>equivalent</strong> to the following expression, which
we&rsquo;ve derived from the circuit implementation:</p>
<div class="customBlock text-center my-4"><code class="customCode">
<span class="Boolean">NOT</span> (X <span class="Boolean">AND</span> Y)
</code></div>
<p>We&rsquo;ve seen that the two expressions are <em>equivalent</em> in the sense that they
always evaluate to the same truth-value for all values for <code class="customCode">X</code> and <code class="customCode">Y</code>.</p>
<p>Generally speaking, a Boolean expression in <em>DNF</em> is</p>
<ul>
<li>
<p>a _disjunction (&ldquo;chain of <span class="Boolean">OR</span>&rsquo;s&rdquo;) of</p>
</li>
<li>
<p><em>conjunctions</em> (&ldquo;chains of <span class="Boolean">AND</span>&rsquo;s&rdquo;) of</p>
</li>
<li>
<p><em>literals</em> (&ldquo;variables or <span class="Boolean">NOT</span>&rsquo;s of variables&rdquo;).</p>
</li>
</ul>
<p>Each chain in this definition can be just have a single element. So, for
example:</p>
<table>
  <thead>
      <tr>
          <th>

<img src="https://logicalmethods.ai/textbook/sat/img/dnf.png" class="inert-img" height="40px"  style="ZgotmplZ" alt="" >

</th>
          <th>     </th>
          <th>

<img src="https://logicalmethods.ai/textbook/sat/img/no_dnf.png" class="inert-img" height="40px"  style="ZgotmplZ" alt="" >

</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td>     </td>
          <td></td>
      </tr>
      <tr>
          <td><span class="excalifont">X, <span class="Boolean">NOT</span> X</span></td>
          <td></td>
          <td><span class="excalifont"><span class="Boolean">NOT</span> <span class="Boolean">NOT</span>  X</span></td>
      </tr>
      <tr>
          <td><span class="excalifont">X <span class="Boolean">AND</span>  <span class="Boolean">NOT</span> Y</span></td>
          <td></td>
          <td><span class="excalifont"><span class="Boolean">NOT</span> (X <span class="Boolean">AND</span>  Y)</span></td>
      </tr>
      <tr>
          <td><span class="excalifont">X <span class="Boolean">OR</span>  <span class="Boolean">NOT</span> Y</span></td>
          <td></td>
          <td><span class="excalifont"><span class="Boolean">NOT</span> (X <span class="Boolean">OR</span>  Y)</span></td>
      </tr>
      <tr>
          <td><span class="excalifont"><span class="Boolean">NOT</span> X <span class="Boolean">OR</span>  ( X <span class="Boolean">AND</span>  <span class="Boolean">NOT</span> Y )</span></td>
          <td></td>
          <td><span class="excalifont">X <span class="Boolean">AND</span>  ( <span class="Boolean">NOT</span> X <span class="Boolean">OR</span>  Y )</span></td>
      </tr>
      <tr>
          <td><span class="excalifont">(Z <span class="Boolean">AND</span> <span class="Boolean">NOT</span> X) <span class="Boolean">OR</span>  ( X <span class="Boolean">AND</span>  <span class="Boolean">NOT</span> Y )</span></td>
          <td></td>
          <td><span class="excalifont">X <span class="Boolean">AND</span>  ( <span class="Boolean">NOT</span> X <span class="Boolean">OR</span>  Y )</span></td>
      </tr>
      <tr>
          <td>⋮</td>
          <td></td>
          <td>⋮</td>
      </tr>
  </tbody>
</table>
<p>DNFs are intimately connected with truth-tables.  If we have a Boolean
expression in DNF, we can &ldquo;read off&rdquo; its truth-value distribution from the
logical form of the expression:</p>
<ul>
<li>
<p>Each disjunct, that is each chain of <span class="Boolean">AND</span>&rsquo;s in the chain of !!OR!&rsquo;s,
corresponds to one way the expression can evaluate to <code class="customCode">1</code>.</p>
</li>
<li>
<p>To obtain this way, we read an occurrence of a variable as that variable
having value <code class="customCode">1</code> and an occurrence of the <span class="Boolean">NOT</span> of a variable as that variable
having value <code class="customCode">0</code>.</p>
</li>
</ul>
<p>In this way, we can see that</p>
<div class="customBlock text-center my-4"><code class="customCode">
((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y)) <span class="Boolean">OR</span> ((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> Y) <span class="Boolean">OR</span> (X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y))
</code></div>
<p>has three ways of evaluating to <code class="customCode">1</code>:</p>
<ul>
<li>
<p><code class="customCode">X</code> and <code class="customCode">Y</code> are both <code class="customCode">0</code>, given by the first disjunct <code class="customCode">((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y))</code>,</p>
</li>
<li>
<p><code class="customCode">X</code> is <code class="customCode">0</code> and <code class="customCode">Y</code> is <code class="customCode">1</code>, given by the second disjunct <code class="customCode">((<span class="Boolean">NOT</span> X) <span class="Boolean">AND</span> Y</code>, or</p>
</li>
<li>
<p><code class="customCode">X</code> is <code class="customCode">1</code> and <code class="customCode">Y</code> is <code class="customCode">0</code> given by the third disjunct <code class="customCode">(X <span class="Boolean">AND</span> (<span class="Boolean">NOT</span> Y))</code>.</p>
</li>
</ul>
<p>In fact, we used this idea &ldquo;the other way around&rdquo; to generate the expression: we
directly &ldquo;read it off&rdquo; off the function table for <code class="customCode">(X <span class="Boolean">NAND</span> Y)</code>.</p>
<p>But the connection between truth-tables and DNFs is very deep. In fact, evidence
suggests that working with DNFs doesn&rsquo;t provide much of an advantage over
truth-tables in the context of automated <code class="customCode">SAT</code>-solving. It turns out that the
whether they do once more turns on deep issues like <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/P_versus_NP_problem"
  target="_blank">P vs.
NP</a>, but from a practical
perspective the other kind of normal form, CNFs, have historically been much
more fruitful in <code class="customCode">SAT</code> research.</p>
<p>We&rsquo;ve described DNFs for Boolean expressions, but we&rsquo;ll present CNFs for logical
formulas. As usual, the notion can be defined for both, but the algorithm we&rsquo;ll
discuss later is more naturally presented in logical terms than directly in
Boolean terms.</p>
<p>So, in logical terms, a formula in CNF is a formula which is the:</p>
<ul>
<li>
<p><em>conjunction</em> (&ldquo;chain of 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
&rsquo;s&rdquo;) of</p>
</li>
<li>
<p><em>disjunctions</em> (&ldquo;chain of 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
&rsquo;s&rdquo;) of</p>
</li>
<li>
<p><em>literals</em> (&ldquo;variables or their 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
&rsquo;s&rdquo;)</p>
</li>
</ul>
<p>Again, each &ldquo;chain&rdquo; in this definition can be just a single formula. So, for example:</p>
<table>
  <thead>
      <tr>
          <th>

<img src="https://logicalmethods.ai/textbook/sat/img/cnf.png" class="inert-img" height="40px"  style="ZgotmplZ" alt="" >

</th>
          <th>     </th>
          <th>

<img src="https://logicalmethods.ai/textbook/sat/img/no_cnf.png" class="inert-img" height="40px"  style="ZgotmplZ" alt="" >

</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td>     </td>
          <td></td>
      </tr>
      <tr>
          <td><span class="excalifont">RAIN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN</span></td>
          <td></td>
          <td>
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>

<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN</td>
      </tr>
      <tr>
          <td><span class="excalifont">RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND</span></td>
          <td></td>
          <td><span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
(RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 WIND)</span></td>
      </tr>
      <tr>
          <td><span class="excalifont">RAIN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND</span></td>
          <td></td>
          <td><span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
(RAIN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 WIND)</span></td>
      </tr>
      <tr>
          <td><span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 ( RAIN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND )</span></td>
          <td></td>
          <td><span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 ( RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND )</span></td>
      </tr>
      <tr>
          <td><span class="excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN) 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 ( RAIN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND )</span></td>
          <td></td>
          <td><span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
( RAIN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND )</span></td>
      </tr>
      <tr>
          <td>⋮</td>
          <td></td>
          <td>⋮</td>
      </tr>
  </tbody>
</table>
<p>While in a formula in DNF, each disjunct (from &ldquo;the chain of <span class="Boolean">OR</span>s&rdquo;)
represents one way for the formula to be true, the conjuncts of a CNF are more
like a &ldquo;menu&rdquo; to pick from. To make a formula in DNF true, one picks one
disjunct (that is one literal, a propositional variable or its negation) from
each conjunct in the long chain of 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
&rsquo;s. Take the following formula,
for example:</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN) 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 ( RAIN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND )</div>
<p>One way of making it true is to pick <span class="excalifont">SUN</span> from the first conjunct and <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND</span>
from the second. That is, the formula is true if the sun shines and it&rsquo;s not
windy. Another way of making it true is to pick <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN</span> from the first
and <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND</span> from the second. That is, the formula is true if it&rsquo;s
neither rainy nor windy. Obviously, we can&rsquo;t pick <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN</span> from the
first and <span class="excalifont">RAIN</span> from the second. This is not a way to make the formula true,
since its not a real possibility in Boolean logic that it both rains and it
doesn&rsquo;t. Excluding these kinds of possibilities from the search space in a
systematic fashion is what many <code class="customCode">SAT</code>-solving algorithms are designed to do.</p>
<p>But before we look at these kinds of algorithms, we need to talk about a
fundamental fact about normal forms: there are algorithms for transforming any
given expression or formula into an equivalent expression or formula in DNF or
CNF respectively. This mathematical fact is known as the <strong>DNF/CNF theorem</strong> for
Boolean logic. In this context, by &ldquo;equivalent&rdquo; we mean that for any assignment
of values, the original expression/formula always evaluates to the same value as
the formula in normal form. Typically, the normal form of an expression is not
<em>unique</em>: there is more than one expression in normal form, which is equivalent
to a given formula. We can obtain a uniqueness by putting additional
constraints, but for now we shall not occupy ourselves with such subtleties.</p>
<p>

<img src="https://logicalmethods.ai/textbook/sat/img/naive_approach.png" class="rounded  float-end inert-img img-fluid m-2"  width="400px"  alt="" >


There are different algorithms for finding an equivalent formula for a given
formula. In practice, we&rsquo;re interested in transforming a given input as quickly
and efficiently as possible, but for now we&rsquo;ll focus on the <em>naive</em> approach,
which though not efficient is straight-forward. When we&rsquo;re implementing
efficient <code class="customCode">SAT</code>-solvers, we&rsquo;ll rather use something like the <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Tseytin_transformation"
  target="_blank">Tseytin
transformation</a>, for
example, which transforms a formula into a formula that is not necessarily
equivalent but at least <em>equi-satisfiable</em> with the original formula: the two
formulas can have different truth-values under some assignments, but the
original formula is satisfiable if and only if the normal form formula is.</p>
<p>We describe the algorithm for transforming a formula into normal form using
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Rewriting"
  target="_blank">rewrite rules</a>, which are similar to
the ones we used in our definitions of grammars for formal languages. But rather
than rewriting basic expressions into complex formulas, our new rules apply
transformations to existing formulas to change them step-by-step from into
normal form.</p>
<p>The algorithms for transforming into CNF and DNF both start with the same three
rules:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/negation_transformations.png" class="rounded mx-auto d-block inert-img img-fluid"  width="450px"  alt="" >


<p>These rules are applied <em>recursively</em>, which means they are not only applied to
a full formula, but repeatedly to all subformulas during the entire
transformation.</p>
<p>This idea is illustrate in the following re-write sequence:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/rewrite_negation.png" class="rounded mx-auto d-block inert-img img-fluid"  width="900px"  alt="" >


<p>These rules &ldquo;push&rdquo; the negation &ldquo;inwards&rdquo;: formulas which begin with a negation
are replaced with equivalent formulas where the negation is &ldquo;closer to&rdquo; the
variables. Note that by the Boolean laws of &ldquo;Double Negation&rdquo; and the &ldquo;De Morgan
Identities&rdquo; the formulas we&rsquo;re replacing the originals with are indeed
equivalent.</p>
<p>Both for converting into DNF and for CNF, we apply these rules until we can&rsquo;t
anymore. The next step is different for the two:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/cnf_v_dnf.png" class="rounded mx-auto d-block inert-img img-fluid"  width="900px"  alt="" >


<p>Let&rsquo;s look at the CNF rule and leave the DNF rule as an exercise. With <span class="excalifont">r₄</span>, we
can continue our example as follows:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/cnf_distribution.png" class="rounded mx-auto d-block inert-img img-fluid"  width="900px"  alt="" >


<p>The resulting formula <span class="excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN ) 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 SUN)</span> is in CNF: it&rsquo;s a conjunction of disjunction of literals.</p>
<p>For what we want to do next, we could stop our transformation at this point. The
only thing you might find odd is that we have <span class="excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 SUN)</span> as our
second conjunct in this CNF. This is harmless, but we could further simplify
using rewrite rules like the following:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/idempotence_rewrite.png" class="rounded mx-auto d-block inert-img img-fluid"  width="600px"  alt="" >


<p>With these rules, we continue as follows:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/final_rewrite.png" class="rounded mx-auto d-block inert-img img-fluid"  width="800px"  alt="" >


<p>In this way, we can obtain what&rsquo;s called a <strong>canonical</strong> normal form, which is unique. Although, there&rsquo;s one idea missing, which we&rsquo;ll discuss in the exercises…</p>
<p>We&rsquo;re now in a place to convert formulas into CNF, which is the starting point
of many <code class="customCode">SAT</code>-solving algorithms. As we mentioned, in industry applications,
we&rsquo;d typically use more efficient algorithms, like Tseytin transformations. But
the naive recursive re-write method gets the job done. It&rsquo;s worth pointing out,
however, where the inefficiency lies with this method. Note that in the step
where we applied <span class="excalifont">r₄</span>, our formula got <em>longer</em>. In the worst case, this can
happen multiple times during a transformation, leading to every growing
formulas, where the CNF <em>or</em> DNF is significantly longer than the original,
non-canonical formula. This &ldquo;exponential blowout&rdquo; is a main roadblock for
practical applications.</p>
<h2 id="resolution">Resolution<button class="btn btn-back-to-top">
    
    <i class="bi bi-chevron-double-up"></i>
    
  </button>
</h2>
<hr>

<p>

<img src="https://logicalmethods.ai/textbook/sat/img/ai_resolution.png" class="rounded  float-start inert-img img-fluid m-2"  width="400px"  alt="" >


One of the main algorithms for <code class="customCode">SAT</code>-solving in logic-based context is based on
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Resolution_%28logic%29"
  target="_blank">resolution</a>, which is a rule
of inference that operates on CNFs to determine whether a given set of formulas
is satisfiable. We shall now describe how it works.</p>
<p>The starting point for the algorithm is a set of formulas that we want to test
for satisfiability, and the <span class="excalifont">0</span>th step of the algorithm is to transform all of
the formulas in the set into CNF. In the following, we assume that this step has
been carried out.</p>
<p>For concreteness sake, let&rsquo;s start with our very simple example of the
inference:</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN.</div> 
<p>We know that this inference is valid just in case the set</p>
<div class="text-center my-4 excalifont">{ (SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN,  
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN }</div> 
<p>is unsatisfiable. As luck will have it, all the formulas in our set are already
in CNF, so we don&rsquo;t have to do anything for the <span class="excalifont">0</span>th step.</p>
<p>To begin the algorithm, we first transform all the formulas inside the set
themselves into sets. It is possible to define the algorithm purely on formulas,
but it is easier to work with sets. In our case, the resulting sets are:</p>
<div class="text-center my-4 excalifont">{ SUN , RAIN } &emsp; { 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN } &emsp; {
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN }</div> 
<p>The idea is that we turn each conjunct of each formula into a set—the set of
its disjuncts and we consider all these sets as the starting points.</p>
<p>If our set would have contained <div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN ) 
<img src="/img/conjunction.png" alt="Conjunction" class="inline-icon" style="height:1em;width:auto;"/>
 SUN,</div> as well, we&rsquo;d have to add the following two sets:</p>
<div class="text-center my-4 excalifont">{ (SUN , 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN } &emsp; { SUN }</div> 
<p>The <strong>resolution rule</strong> is a <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Rule_of_inference"
  target="_blank">rule of
inference</a>, which allows us to
derive new sets from the sets we already have in our collection. For example,
the rule allows us to reason as follows:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/resolution_application.png" class="rounded mx-auto d-block inert-img img-fluid"  width="300px"  alt="" >


<p>What is going on here is that we have to <strong>complementary</strong> literals in the two
sets: <span class="excalifont">SUN</span> and <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN</span>. The resolution rule removes this pair and
infers the set that contains the remaining literals from both sets.</p>
<p>That is, if our sets had been <span class="excalifont">{ SUN, RAIN }</span> and <span class="excalifont">{ 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND }</span>, respectively, the result would have been <span class="excalifont">{ RAIN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
WIND }</span>.</p>
<p>The idea behind the resolution rule is that to make each formula in our initial
set true, we need to make at least one disjunct of each conjunction of each CNF
true. In our case, we need to make at least one formula from <span class="excalifont">{ SUN, RAIN }</span> and
one formula from <span class="excalifont">{
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN }</span> true. But that formula can&rsquo;t be <span class="excalifont">SUN</span>, nor
can it be <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN</span>—because making the one true makes the other false and
vice versa. So, we can eliminate the pair <span class="excalifont">SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
SUN</span> from
consideration and leave the others as live candidates, which is what the
resolution rule does.</p>
<p>This inference is also called &ldquo;<strong>clausal resolution</strong>&rdquo;. The resolution method
consists in repeatedly resolving, while adding the results to our initial set.
If we ever get across a set of like <div class="text-center my-4 excalifont">{ SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN, RAIN },</div> we can
kick it out from our search, since it is trivially satisfied and doesn&rsquo;t
constrain our search (keeping it around might get us into loops, but that&rsquo;s
another story). We keep doing this until one of two things happens:</p>
<ol>
<li>
<p>We end up with an empty set <span class="excalifont">{ }</span> of clauses.</p>
</li>
<li>
<p>We cannot resolve any further.</p>
</li>
</ol>
<p>If the former happens, we infer the initial set is unsatisfiable. This is
reasonable because we have arrived at the conclusion that we need to make at
least one formula from <span class="excalifont">{ }</span> true to make the whole set true, but this is
impossible. If, instead, the latter happens, we <em>can</em> pick a member from each
set to make true and we infer that the original set is satisfiable. The way in
which we do this is something we&rsquo;ll discuss at another occasion, but for now we
leave it at that.</p>
<p>If we continue applying the rule in our case, resolution yields the expected
result:</p>


<img src="https://logicalmethods.ai/textbook/sat/img/resolution_final.png" class="rounded mx-auto d-block inert-img img-fluid"  width="500px"  alt="" >


<p>We can derive the empty set <span class="excalifont">{ }</span> to witness the unsatisfiability of:</p>
<div class="text-center my-4 excalifont">{ SUN , RAIN } &emsp; { 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN } &emsp; {
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN },</div> 
<p>and corresponding validity of the inference in question:</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN), 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 SUN 
<img src="/img/vDash.png" alt="vDash" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN.</div> 
<p>Let&rsquo;s apply the method to our <em>invalid</em> inference, instead:</p>
<div class="text-center my-4 excalifont">(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN),  SUN 
<img src="/img/therefore.png" alt="Therefore" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN.</div> 
<p>To check for validity, we need to check the following set for <code class="customCode">SAT</code>:</p>
<div class="text-center my-4 excalifont">{(SUN 
<img src="/img/disjunction.png" alt="Disjunction" class="inline-icon" style="height:1em;width:auto;"/>
 RAIN),  SUN, 
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN}</div> 
<p>We need to do a simple application of <span class="excalifont">r₁</span> to transform <span class="excalifont">
<img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
 
 <img src="/img/negation.png" alt="Negation" class="inline-icon" style="height:1em;width:auto;"/>
RAIN</span> into its CNF <span class="excalifont">RAIN</span>, and transforming to sets, we get:</p>
<div class="text-center my-4 excalifont">{ SUN,  RAIN } &emsp; { SUN } &emsp; { RAIN }.</div> 
<p>But to this collection of sets no resolutions can be applied.</p>
<p>In fact, if we inspect this list, we can see that there&rsquo;s precisely one way of
picking a member of each set: pick <span class="excalifont">SUN</span> from <span class="excalifont">{ SUN,  RAIN }</span> and <span class="excalifont">{ SUN }</span>,
as well as <span class="excalifont">RAIN</span> from <span class="excalifont">{RAIN }</span>. This gives us our final countermodel <span class="excalifont">v</span> with
<span class="excalifont">v(SUN) = 1</span> and <span class="excalifont">v(RAIN) = 1</span>—the same as before, but now we found it in a
mechanized fashion.</p>
<p>The resolution method described like this is a <strong>sound and complete</strong> decision
procedure for satisfiability in the sense that for <em>any</em> set of formulas it
correctly determines in finitely many steps <em>whether</em> the set is satisfiable. In
many cases, it does so much quicker than the truth-table method. For example, in
our valid inference, two applications of resolution where enough, even though we
needed to check four valuations using truth-tables.</p>
<p>Worst-case the method performs as bad as truth-tables. One bottle-neck is the
translation into CNF, which we&rsquo;ve seen can have exponential blowout. But even if
we use smart methods, like Tseytin transformations, resolution might still need
many applications of the resolution rule to get the desired result: especially
when it comes to satisfiable sets, where we need to go through every case.</p>
<p>In any case, resolution is one of the main methods of <code class="customCode">SAT</code>-solving, which is
the basis for state-of-the art automated reasoning technologies, like
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Prover9"
  target="_blank">Prover9</a>,
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Z3_Theorem_Prover"
  target="_blank">Z3</a>, and
<i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Vampire_%28theorem_prover%29"
  target="_blank">Vampire</a>. These systems
are regularly used for hardware verification and automated inference. But once
we&rsquo;ve enriched our language with conditionals, we can even use it for activities
such as AI <i class="bi bi-box-arrow-up-right h-6"></i>
<a class="link-dark" href="https://en.wikipedia.org/wiki/Satplan"
  target="_blank">planning</a>.</p>


  </div>
   <p><em>Last edited: </em>21/09/2025</p>
</div>


<ul class="navbar-nav flex-row justify-content-between mt-auto">
  
  <li class="nav-item">
    <a href="/textbook/boolean/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-left"></i>
    </a>
    
  </li>
  <li class="nav-item">
    <button class="btn btn-back-to-top">
    <i class="bi bi-chevron-double-up"></i>
  </button>
  </li>
  <li class="nav-item">
    
    <a href="/textbook/conditionals/" class="btn" tabindex="-1" role="button" aria-disabled="true">
      <i class="bi bi-chevron-right"></i>
    </a>
    
  </li>
</ul>

    </main>
    <footer class="align-self-center d-flex flex-column mt-md-1 p-0" data-bs-theme="dark">
      <nav class="navbar bg-dark shadow" data-bs-theme="dark" aria-label="footer-navbar">
  <div class="container-sm align-self-center px-3">
    <a class="navbar-brand fs-6" href="/about" aria-label="copyright-link">&copy; 2025 jkorbmacher et al. </a>
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link fs-6" href="https://github.com/jkorb/logicalmethods.ai" target="_blank"><i class="bi bi-github"></i></a>
      </li>
    </ul>
  </div>
</nav>
 
      <script src="https://logicalmethods.ai/js/helpers.js"></script>
      <script src="https://logicalmethods.ai/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
      
      
    </footer>
  </body>
</html>
